import ProjectConfig._
import PipelineConfig._
import Directories._
import StoreHelpers._
import ProjectStores._
import ArrayStores._
import Prepare._
import Harmonize._
import Load._
import FilterForQc._
import Kinship._
import Ancestry._
import Pca._
import SampleQc._
import FilterFinal._
import Impute._
import VariantAssoc._
//import CrossCohort._
//import Meta._
//import ResultsSummary._
import AssocStores._
//import Phenotype._
import QcReport._
//import AnalysisReport._

import loamstream.conf.DataConfig
import loamstream.googlecloud.HailSupport._
import loamstream.model.Store
import loamstream.util.CanBeClosed.enclosed

// Array specific QC steps up to ancestry inferrence
for {
  array <- projectConfig.Arrays
} yield { 

  Prepare(array.id)
  Harmonize(array.id)
  Load(array.id)
  FilterForQc(array.id)
  Kinship(array.id)
  AncestryPca(array.id)
  AncestryCluster(array.id)

}

// Reconcile inferred ancestry
MergeInferredAncestry()

// Array specific QC steps post ancestry inference
for {
  array <- projectConfig.Arrays
} yield { 

  Pca(array.id)
  SampleQc(array.id)
  FilterFinal(array.id)

}

// QC Report
QcReport()

// Generate imputation ready data files
for {
  array <- projectConfig.Arrays
} yield { 

  FilterImpute(array.id)

}

// Cohort variant association
for {
  run <- projectConfig.Runs
  model <- projectConfig.Models.filter(e => run.models contains e.id)
  cohort <- projectConfig.Cohorts.filter(e => run.cohorts contains e.id)
} yield {

  VariantAssoc(configModel = model, configCohort = cohort, configMeta = None)

}

// Cohort variant association for known loci
for {
  run <- projectConfig.Runs
  model <- projectConfig.Models.filter(e => run.models contains e.id)
  cohort <- projectConfig.Cohorts.filter(e => run.cohorts contains e.id)
  known <- projectConfig.Knowns.filter(e => run.knowns contains e.id)
} yield { 

  KnownLociAssoc(configModel = model, configCohort = cohort, configKnown = known, configMeta = None)

}

//// Meta-analysis cross-cohort qc prep
//for {
//  run <- projectConfig.Runs
//  model <- projectConfig.Models.filter(e => run.models contains e.id)
//  meta <- projectConfig.Metas.filter(e => run.metas contains e.id)
//  cohort <- projectConfig.Cohorts.filter(e => meta.cohorts contains e.id)
//} yield {
//
//  CrossCohortPrep(configModel = model, configCohort = cohort, configMeta = meta)
//
//}
//
//// Meta-analysis cross-array kinship
//for {
//  run <- projectConfig.Runs
//  meta <- projectConfig.Metas.filter(e => run.metas contains e.id)
//} yield {
//
//  CrossCohortKinship(meta)
//
//}
//
//// Meta-analysis calculate cross-cohort kinship sample exclusions
//for {
//  run <- projectConfig.Runs
//  meta <- projectConfig.Metas.filter(e => run.metas contains e.id)
//  cohort <- projectConfig.Cohorts.filter(e => meta.cohorts contains e.id)
//} yield {
//
//  CrossCohortExclude(configCohort = cohort, configMeta = meta)
//
//}
//
//// Meta-analysis specific cohort variant association
//for {
//  run <- projectConfig.Runs
//  model <- projectConfig.Models.filter(e => run.models contains e.id)
//  meta <- projectConfig.Metas.filter(e => run.metas contains e.id)
//  cohort <- projectConfig.Cohorts.filter(e => meta.cohorts contains e.id)
//} yield { 
//
//  VariantAssoc(configModel = model, configCohort = cohort, configMeta = Some(meta))
//
//}
//
//// Meta-analysis specific cohort variant association for known loci
//for {
//  run <- projectConfig.Runs
//  model <- projectConfig.Models.filter(e => run.models contains e.id)
//  meta <- projectConfig.Metas.filter(e => run.metas contains e.id)
//  cohort <- projectConfig.Cohorts.filter(e => meta.cohorts contains e.id)
//  known <- projectConfig.Knowns.filter(e => run.knowns contains e.id)
//} yield { 
//
//  KnownLociAssoc(configModel = model, configCohort = cohort, configKnownLoci = known, configMeta = Some(meta))
//
//}
//
//
//
//
//// Meta-analysis
//for {
//  meta <- projectConfig.Metas
//  model <- projectConfig.Models
//} yield {
//
//  MetaAnalysis(configModel = model, configMeta = meta)
//
//}
//
//// Meta-analysis for known loci
//for {
//  meta <- projectConfig.Metas if meta.report
//  known <- projectConfig.KnownLoci
//} yield {
//
//  MetaAnalysisKnownLoci(configKnownLoci = known, configMeta = meta)
//
//}
//
//// Cohort Results Summary
//for {
//  cohort <- projectConfig.Cohorts if cohort.report
//  model <- projectConfig.Models
//} yield { 
//
//  ResultsSummary(configModel = model, id = cohort.id, results = assocStores((None, cohort, model)).results)
//
//}
//
//// Meta Results Summary
//for {
//  meta <- projectConfig.Metas if meta.report
//  model <- projectConfig.Models
//} yield { 
//
//  ResultsSummary(configModel = model, id = meta.id, results = metaStores(meta.id).metaResultsData(model).results)
//
//}
//
//// Cohort Known Loci Results Summary
//for {
//  cohort <- projectConfig.Cohorts if cohort.report
//  known <- projectConfig.KnownLoci
//} yield { 
//
//  ResultsKnownLociSummary(configKnownLoci = known, id = cohort.id, results = knownLociStores((None, cohort, known)).assoc.results, known_data = knownLociStores((None, cohort, known)).data, hiLd = knownLociStores((None, cohort, known)).hiLd)
//
//}
//
//// Meta Known Loci Results Summary
//for {
//  meta <- projectConfig.Metas if meta.report
//  known <- projectConfig.KnownLoci
//} yield { 
//
//  ResultsKnownLociSummary(configKnownLoci = known, id = meta.id, results = metaStores(meta.id).metaKnownLociResultsData(known).results, known_data = knownLociStores((None, projectConfig.Cohorts.filter(e => e.id == meta.cohorts(0))(0), known)).data, hiLd = knownLociStores((None, projectConfig.Cohorts.filter(e => e.id == meta.cohorts(0))(0), known)).hiLd)
//
//}
//
//// Generate Phenotype Figures for Cohorts
//for {
//  cohort <- projectConfig.Cohorts
//  phenotype <- projectConfig.Models.map(m => m.pheno).distinct
//} yield { 
//
//  PhenotypeDistPlots(configCohort = cohort, pheno = phenotype)
//
//}
//
//// Generate Phenotype Figures for Meta Cohorts
//for {
//  meta <- projectConfig.Metas
//  cohort <- projectConfig.Cohorts.filter(e => meta.cohorts contains e.id)
//  phenotype <- projectConfig.Models.map(m => m.pheno).distinct
//} yield { 
//
//  PhenotypeDistPlots(configCohort = cohort, pheno = phenotype, configMeta = Some(meta))
//
//}
//
//// Analysis Report Global
//for {
//  phase <- projectConfig.Models.map(m => m.phase).distinct.sorted
//} yield {
//
//  AnalysisReportGlobal(phase = phase)
//
//}
//
//// Analysis Report Pheno
//for {
//  phase <- projectConfig.Models.map(m => m.phase).distinct.sorted
//  pheno <- projectConfig.Models.filter(e => e.phase == phase).map(m => m.pheno).distinct
//} yield {
//
//  AnalysisReportPheno(phase = phase, pheno = pheno, name = projectConfig.Phenos.filter(e => e.pheno == pheno)(0).name)
//
//}
//
//// Analysis Report Compile
//for {
//  phase <- projectConfig.Models.map(m => m.phase).distinct.sorted
//} yield {
//
//AnalysisReportCompile(phase = phase)
//
//}
