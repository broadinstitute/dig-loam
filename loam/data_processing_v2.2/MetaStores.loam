import ProjectConfig._
import PipelineConfig._
import StoreHelpers._
import CohortStores._

final case class MetaCohortData(
  data: Seq[Store],
  base: Path,
  samples: Store,
  famMerge: Store,
  kinshipSamplesExclude: Store)

final case class MetaKinshipData(
  mergeList: Store,
  dataFiltered: Seq[Store],
  baseFiltered: Path,
  baseKinship: Path,
  log: Store,
  kin0: Store,
  kin0Related: Store)

final case class MetaResultsData(
  results: Store,
  resultsGoogle: Store,
  tbi: Store)

final case class Meta(
  commonVariants: Store,
  metaCohortData: Map[String, MetaCohortData],
  metaKinshipData: MetaKinshipData,
  metaResultsData: Map[ConfigModel, MetaResultsData],
  metaKnownLociResultsData: Map[ConfigKnownLoci, MetaResultsData])

val metaStores = projectConfig.Metas.map(m => m.id).map { meta =>

  val baseString = s"${projectConfig.projectId}.${meta}"
  val baseRefFilteredString = s"${baseString}.ref.filtered"
  val baseKinshipString = s"${baseString}.kinship"

  val commonVariants = store(localOutDir / s"${baseRefFilteredString}.common_variants.txt")

  val metaCohortData = projectConfig.Cohorts.filter(e => projectConfig.Metas.filter(e => e.id == meta)(0).cohorts contains e.id).map(c => c.id).map { cohort =>

    val cohortBaseString = s"${projectConfig.projectId}.${meta}.${cohort}"
    val cohortRefBaseString = s"${cohortBaseString}.ref"
    val cohortKinshipBaseString = s"${cohortBaseString}.kinship"

    cohort -> MetaCohortData(
      data = bedBimFam(localOutDir / cohortRefBaseString),
      base = localOutDir / cohortRefBaseString,
      samples = store(localOutDir / s"${cohortBaseString}.samples"),
      famMerge = store(localOutDir / s"${cohortRefBaseString}.fam.merge"),
      kinshipSamplesExclude = store(localOutDir / s"${cohortKinshipBaseString}.samples.exclude"))

  }.toMap

  val metaKinshipData = MetaKinshipData(
    mergeList= store(localOutDir / s"${baseRefFilteredString}.merge_list.txt"),
    dataFiltered = bedBimFam(localOutDir / baseRefFilteredString),
    baseFiltered = localOutDir / baseRefFilteredString,
    baseKinship = localOutDir / baseKinshipString,
    log = store(localOutDir / s"${baseKinshipString}.log"),
    kin0 = store(localOutDir / s"${baseKinshipString}.kin0"),
    kin0Related = store(localOutDir / s"${baseKinshipString}.kin0.related"))

  val metaResultsData = projectConfig.Models.map { model =>

    val modelCovarsString = model.covars.replace("+","_").replace("[","").replace("]","")
    val metaResultsBaseString = s"${projectConfig.projectId}.${meta}.${model.pheno}.${model.trans}.${modelCovarsString}.${model.test}"

    model -> MetaResultsData(
      results = store(localOutDir / s"${metaResultsBaseString}.results.tsv.bgz"),
      resultsGoogle = store(googleOutDir / s"${metaResultsBaseString}.results.tsv.bgz"),
      tbi = store(localOutDir / s"${metaResultsBaseString}.results.tsv.bgz.tbi"))

  }.toMap

  val metaKnownLociResultsData = projectConfig.KnownLoci.map { known =>

    val modelCovarsString = known.model.covars.replace("+","_").replace("[","").replace("]","")
    val metaKnownLociResultsBaseString = s"${projectConfig.projectId}.${meta}.${known.model.pheno}.${known.model.trans}.${modelCovarsString}.${known.model.test}.known_loci"

    known -> MetaResultsData(
      results = store(localOutDir / s"${metaKnownLociResultsBaseString}.results.tsv.bgz"),
      resultsGoogle = store(googleOutDir / s"${metaKnownLociResultsBaseString}.results.tsv.bgz"),
      tbi = store(localOutDir / s"${metaKnownLociResultsBaseString}.results.tsv.bgz.tbi"))

  }.toMap

  meta -> Meta(
    commonVariants = commonVariants,
    metaCohortData = metaCohortData,
    metaKinshipData = metaKinshipData,
    metaResultsData = metaResultsData,
    metaKnownLociResultsData = metaKnownLociResultsData)

}.toMap
