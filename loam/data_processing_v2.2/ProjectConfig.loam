val dataConfig = loadConfig("dataConfig", "")

final case class ConfigArray(
  id: String,
  filename: String,
  format: String,
  partitions: Int,
  liftOver: Option[String] = None,
  xChr: Boolean,
  yChr: Boolean,
  mtChr: Boolean,
  skipGh: Seq[String],
  ancestryOutliersKeep: Seq[String],
  duplicatesKeep: Seq[String],
  famsizeKeep: Seq[String],
  sampleqcKeep: Seq[String],
  sexcheckKeep: Seq[String])

final case class ConfigCohort(
  id: String,
  array: String,
  ancestry: Seq[String],
  partitions: Int)

final case class ConfigMeta(
  id: String,
  cohorts: Seq[String],
  partitions: Int)

final case class ConfigMerge(
  id: String,
  cohorts_metas: Seq[String],
  partitions: Int)

final case class ConfigPheno(
  id: String,
  name: String)

final case class ConfigModel(
  id: String,
  pheno: String,
  trans: String,
  test: String,
  covars: Seq[String])

final case class ConfigKnown(
  id: String,
  data: String,
  hiLd: String,
  n: String,
  nCase: String,
  nCtrl: String,
  desc: String,
  citation: String)

final case class ConfigSection(
  models: Seq[String],
  cohorts: Option[Seq[String]],
  metas: Option[Seq[String]],
  merges: Option[Seq[String]],
  knowns: Option[Seq[String]])

final case class ConfigReport(
  name: String,
  sections: Seq[ConfigSection])

final case class ProjectConfig(
  projectId: String,
  referenceGenome: String,
  regionsExclude: String,
  regionsExcludeGoogle: String,
  genePositions: String,
  kgPurcellVcf: String,
  kgPurcellVcfGoogle: String,
  kgSample: String,
  kgSampleGoogle: String,
  kgSampleId: String,
  kgSamplePop: String,
  kgSampleGroup: String,
  kgVcf: String,
  kgIds: String,
  humanReferenceWild: String,
  phenoFile: String,
  phenoFileId: String,
  phenoFileSrSex: String,
  phenoFileMaleCode: String,
  phenoFileFemaleCode: String,
  phenoFileSrRace: String,
  phenoFileStatus: String,
  qcReportAuthors: Seq[String],
  analysisReportAuthors: Seq[String],
  analysisReportAcknowledgements: Seq[String],
  nAncestryInferenceFeatures: Int,
  sampleQcMetrics: Seq[String],
  ancestryInferenceFeatures: String,
  nArrays: Int,
  nCohorts: Int,
  nMetas: Int,
  nMetrics: Int,
  Arrays: Seq[ConfigArray],
  Cohorts: Seq[ConfigCohort],
  Metas: Seq[ConfigMeta],
  Merges: Seq[ConfigMerge],
  Phenos: Seq[ConfigPheno],
  Models: Seq[ConfigModel],
  Knowns: Seq[ConfigKnown],
  Reports: Seq[ConfigReport])

val projectConfig = ProjectConfig(

  // required global values in conf file
  projectId = dataConfig.getStr("projectId"),
  referenceGenome = dataConfig.getStr("referenceGenome"),
  regionsExclude = dataConfig.getStr("regionsExclude"),
  regionsExcludeGoogle = dataConfig.getStr("regionsExcludeGoogle"),
  genePositions = dataConfig.getStr("genePositions"),
  kgPurcellVcf = dataConfig.getStr("kgPurcellVcf"),
  kgPurcellVcfGoogle = dataConfig.getStr("kgPurcellVcfGoogle"),
  kgSample = dataConfig.getStr("kgSample"),
  kgSampleGoogle = dataConfig.getStr("kgSampleGoogle"),
  kgSampleId = dataConfig.getStr("kgSampleId"),
  kgSamplePop = dataConfig.getStr("kgSamplePop"),
  kgSampleGroup = dataConfig.getStr("kgSampleGroup"),
  kgVcf = dataConfig.getStr("kgVcf"),
  kgIds = dataConfig.getStr("kgIds"),
  humanReferenceWild = dataConfig.getStr("humanReferenceWild"),
  phenoFile = dataConfig.getStr("phenoFile"),
  phenoFileId = dataConfig.getStr("phenoFileId"),
  phenoFileSrSex = dataConfig.getStr("phenoFileSrSex"),
  phenoFileMaleCode = dataConfig.getStr("phenoFileMaleCode"),
  phenoFileFemaleCode = dataConfig.getStr("phenoFileFemaleCode"),
  phenoFileSrRace = dataConfig.getStr("phenoFileSrRace"),
  phenoFileStatus = dataConfig.getStr("phenoFileStatus"),
  qcReportAuthors = dataConfig.getStrList("qcReportAuthors"),
  analysisReportAuthors = dataConfig.getStrList("analysisReportAuthors"),
  analysisReportAcknowledgements = dataConfig.getStrList("analysisReportAcknowledgements"),
  nAncestryInferenceFeatures = dataConfig.getInt("nAncestryInferenceFeatures"),
  sampleQcMetrics = dataConfig.getStrList("sampleQcMetrics"),

  // inferred global values
  ancestryInferenceFeatures = if (dataConfig.isDefined("nAncestryInferenceFeatures")) { "1" * dataConfig.getInt("nAncestryInferenceFeatures") + "0" * (20 - dataConfig.getInt("nAncestryInferenceFeatures")) } else { "1" * 3 + "0" * (20 - 3) },
  nArrays = dataConfig.getObjList("arrays").size,
  nCohorts = dataConfig.getObjList("cohorts").size,
  nMetas = dataConfig.getObjList("metas").size,
  nMetrics = dataConfig.getStrList("sampleQcMetrics").size,

  // arrays
  Arrays = {

    for {
      array <- dataConfig.getObjList("arrays")
    } yield {

      ConfigArray(
        id = array.getStr("id"),
        filename = array.getStr("filename"),
        format = array.getStr("format"),
        partitions = array.getInt("partitions"),
        liftOver = if (array.isDefined("liftOverChain")) { Some(array.getStr("liftOverChain")) } else { None },
        xChr = array.getBool("xChr"),
        yChr = array.getBool("yChr"),
        mtChr = array.getBool("mtChr"),
        skipGh = array.getStrList("skipGh"),
        ancestryOutliersKeep = array.getStrList("ancestryOutliersKeep"),
        duplicatesKeep = array.getStrList("duplicatesKeep"),
        famsizeKeep = array.getStrList("famsizeKeep"),
        sampleqcKeep = array.getStrList("sampleqcKeep"),
        sexcheckKeep = array.getStrList("sexcheckKeep"))

    }

  },

  Cohorts = {

    for {
      cohort <- dataConfig.getObjList("cohorts")
    } yield {

      ConfigCohort(
        id = cohort.getStr("id"),
        array = cohort.getStr("array"),
        ancestry = cohort.getStrList("ancestry"),
        partitions = cohort.getInt("partitions"))

    }

  },

  Metas = {

    for {
      meta <- dataConfig.getObjList("metas")
    } yield {

      ConfigMeta(
        id = meta.getStr("id"),
        cohorts = meta.getStrList("cohorts"),
        partitions = meta.getInt("partitions"))

    }

  },

  Merges = {

    for {
      merge <- dataConfig.getObjList("merges")
    } yield {

      ConfigMerge(
        id = merge.getStr("id"),
        cohorts_metas = merge.getStrList("cohorts_metas"),
        partitions = merge.getInt("partitions"))

    }

  },

  Phenos = {

    for {
      pheno <- dataConfig.getObjList("phenos")
    } yield {

      ConfigPheno(
        id = pheno.getStr("id"),
        name = pheno.getStr("name"))

    }

  },

  Models = {

    for {
      model <- dataConfig.getObjList("models")
    } yield {

      ConfigModel(
        id = model.getStr("id"),
        pheno = model.getStr("pheno"),
        trans = model.getStr("trans"),
        test = model.getStr("test"),
        covars = model.getStrList("covars"))
    }

  },

  Knowns = {

    for {
      known <- dataConfig.getObjList("knowns")
    } yield {

      ConfigKnown(
        id = known.getStr("id"),
        data = known.getStr("data"),
        hiLd = known.getStr("hiLd"),
        n = if ( known.isDefined("n") ) { known.getStr("n") } else { "" },
        nCase = if ( known.isDefined("nCase") ) { known.getStr("nCase") } else { "" },
        nCtrl = if ( known.isDefined("nCtrl") ) { known.getStr("nCtrl") } else { "" },
        desc = known.getStr("desc"),
        citation = known.getStr("citation"))

    }

  },

  Reports = {

    for {
      report <- dataConfig.getObjList("reports")
    } yield {

      ConfigReport(
        name = report.getStr("name"),
        sections = for {
          section <- report.getObjList("sections")
        } yield {

          ConfigSection(
            models = section.getStrList("models"),
            cohorts = if ( section.isDefined("cohorts") ) { Some(section.getStrList("cohorts")) } else { None },
            metas = if ( section.isDefined("metas") ) { Some(section.getStrList("metas")) } else { None },
            merges = if ( section.isDefined("merges") ) { Some(section.getStrList("merges")) } else { None },
            knowns = if ( section.isDefined("knowns") ) { Some(section.getStrList("knowns")) } else { None })
        
        })
    }

  }

)

final case class CohortAssoc(
    model: ConfigModel,
    cohort: ConfigCohort) {
  def canEqual(a: Any) = a.isInstanceOf[CohortAssoc]
  override def equals(that: Any): Boolean = that match {
    case that: CohortAssoc => that.canEqual(this) && this.hashCode == that.hashCode
    case _ => false
  }
  override def hashCode: Int = {
      val prime = 31
      var result = 1
      result = prime * result + model.id.hashCode
      result = prime * result + cohort.id.hashCode
      result
  }
}

final case class CohortKnownAssoc(
    model: ConfigModel,
    cohort: ConfigCohort,
    known: ConfigKnown) {
  def canEqual(a: Any) = a.isInstanceOf[CohortKnownAssoc]
  override def equals(that: Any): Boolean = that match {
    case that: CohortKnownAssoc => that.canEqual(this) && this.hashCode == that.hashCode
    case _ => false
  }
  override def hashCode: Int = {
      val prime = 31
      var result = 1
      result = prime * result + model.id.hashCode
      result = prime * result + cohort.id.hashCode
      result = prime * result + known.id.hashCode
      result
  }
}

final case class CohortMetaAssoc(
    model: ConfigModel,
    cohort: ConfigCohort,
    meta: ConfigMeta) {
  def canEqual(a: Any) = a.isInstanceOf[CohortMetaAssoc]
  override def equals(that: Any): Boolean = that match {
    case that: CohortMetaAssoc => that.canEqual(this) && this.hashCode == that.hashCode
    case _ => false
  }
  override def hashCode: Int = {
      val prime = 31
      var result = 1
      result = prime * result + model.id.hashCode
      result = prime * result + cohort.id.hashCode
      result = prime * result + meta.id.hashCode
      result
  }
}

final case class CohortMetaKnownAssoc(
    model: ConfigModel,
    cohort: ConfigCohort,
    meta: ConfigMeta,
    known: ConfigKnown) {
  def canEqual(a: Any) = a.isInstanceOf[CohortMetaKnownAssoc]
  override def equals(that: Any): Boolean = that match {
    case that: CohortMetaKnownAssoc => that.canEqual(this) && this.hashCode == that.hashCode
    case _ => false
  }
  override def hashCode: Int = {
      val prime = 31
      var result = 1
      result = prime * result + model.id.hashCode
      result = prime * result + cohort.id.hashCode
      result = prime * result + meta.id.hashCode
      result = prime * result + known.id.hashCode
      result
  }
}

final case class ModelMeta(
    model: ConfigModel,
    meta: ConfigMeta) {
  def canEqual(a: Any) = a.isInstanceOf[ModelMeta]
  override def equals(that: Any): Boolean = that match {
    case that: ModelMeta => that.canEqual(this) && this.hashCode == that.hashCode
    case _ => false
  }
  override def hashCode: Int = {
      val prime = 31
      var result = 1
      result = prime * result + model.id.hashCode
      result = prime * result + meta.id.hashCode
      result
  }
}

final case class ModelMerge(
    model: ConfigModel,
    merge: ConfigMerge) {
  def canEqual(a: Any) = a.isInstanceOf[ModelMerge]
  override def equals(that: Any): Boolean = that match {
    case that: ModelMerge => that.canEqual(this) && this.hashCode == that.hashCode
    case _ => false
  }
  override def hashCode: Int = {
      val prime = 31
      var result = 1
      result = prime * result + model.id.hashCode
      result = prime * result + merge.id.hashCode
      result
  }
}

final case class ModelMetaKnown(
    model: ConfigModel,
    meta: ConfigMeta,
    known: ConfigKnown) {
  def canEqual(a: Any) = a.isInstanceOf[ModelMetaKnown]
  override def equals(that: Any): Boolean = that match {
    case that: ModelMetaKnown => that.canEqual(this) && this.hashCode == that.hashCode
    case _ => false
  }
  override def hashCode: Int = {
      val prime = 31
      var result = 1
      result = prime * result + model.id.hashCode
      result = prime * result + meta.id.hashCode
      result = prime * result + known.id.hashCode
      result
  }
}

val cohortAssocs: Seq[CohortAssoc] = {

  val x = for {
    section <- projectConfig.Reports.flatMap(e => e.sections).filter(e => e.cohorts.isDefined)
  } yield {
   
    for {
      m <- section.models
      c <- section.cohorts.get
    } yield {
      CohortAssoc(
        model = projectConfig.Models.filter(e => e.id == m).head,
        cohort = projectConfig.Cohorts.filter(e => e.id == c).head)
    }
  
  }

  val y = for {
    section <- projectConfig.Reports.flatMap(e => e.sections).filter(e => e.merges.isDefined)
  } yield {
   
    for {
      m <- section.models
      g <- section.merges.get
      c <- projectConfig.Merges.filter(e => e.id == g).head.cohorts_metas if projectConfig.Cohorts.filter(e => e.id == c).size > 0
    } yield {
      CohortAssoc(
        model = projectConfig.Models.filter(e => e.id == m).head,
        cohort = projectConfig.Cohorts.filter(e => e.id == c).head)
    }
  
  }
  x ++ y

}.flatten.distinct

val cohortKnownAssocs: Seq[CohortKnownAssoc] = {

  val x = for {
    section <- projectConfig.Reports.flatMap(e => e.sections).filter(e => e.cohorts.isDefined && e.knowns.isDefined)
  } yield {
   
    for {
      m <- section.models
      c <- section.cohorts.get
      k <- section.knowns.get
    } yield {
      CohortKnownAssoc(
        model = projectConfig.Models.filter(e => e.id == m).head,
        cohort = projectConfig.Cohorts.filter(e => e.id == c).head,
        known = projectConfig.Knowns.filter(e => e.id == k).head)
    }

  }

  val y = for {
    section <- projectConfig.Reports.flatMap(e => e.sections).filter(e => e.merges.isDefined && e.knowns.isDefined)
  } yield {
   
    for {
      m <- section.models
      g <- section.merges.get
      c <- projectConfig.Merges.filter(e => e.id == g).head.cohorts_metas if projectConfig.Cohorts.filter(e => e.id == c).size > 0
      k <- section.knowns.get
    } yield {
      CohortKnownAssoc(
        model = projectConfig.Models.filter(e => e.id == m).head,
        cohort = projectConfig.Cohorts.filter(e => e.id == c).head,
        known = projectConfig.Knowns.filter(e => e.id == k).head)
    }
  
  }
  x ++ y

}.flatten.distinct

val cohortMetaAssocs: Seq[CohortMetaAssoc] = {

  val x = for {
    section <- projectConfig.Reports.flatMap(e => e.sections).filter(e => e.metas.isDefined)
  } yield {
   
    for {
      m <- section.models
      t <- section.metas.get
      c <- projectConfig.Metas.filter(e => e.id == t).head.cohorts
    } yield {
      CohortMetaAssoc(
        model = projectConfig.Models.filter(e => e.id == m).head,
        meta = projectConfig.Metas.filter(e => e.id == t).head,
        cohort = projectConfig.Cohorts.filter(e => e.id == c).head)
    }
  
  }

  val y = for {
    section <- projectConfig.Reports.flatMap(e => e.sections).filter(e => e.merges.isDefined)
  } yield {
   
    for {
      m <- section.models
      g <- section.merges.get
      t <- projectConfig.Merges.filter(e => e.id == g).head.cohorts_metas if projectConfig.Metas.filter(e => e.id == t).size > 0
      c <- projectConfig.Cohorts.filter(e => projectConfig.Metas.filter(e => e.id == t).head.cohorts contains e.id).map(e => e.id)
    } yield {
      CohortMetaAssoc(
        model = projectConfig.Models.filter(e => e.id == m).head,
        meta = projectConfig.Metas.filter(e => e.id == t).head,
        cohort = projectConfig.Cohorts.filter(e => e.id == c).head)
    }
  
  }
  x ++ y

}.flatten.distinct

val cohortMetaKnownAssocs: Seq[CohortMetaKnownAssoc] = {

  val x = for {
    section <- projectConfig.Reports.flatMap(e => e.sections).filter(e => e.metas.isDefined && e.knowns.isDefined)
  } yield {
   
    for {
      m <- section.models
      t <- section.metas.get
      c <- projectConfig.Metas.filter(e => e.id == t).head.cohorts
      k <- section.knowns.get
    } yield {
      CohortMetaKnownAssoc(
        model = projectConfig.Models.filter(e => e.id == m).head,
        meta = projectConfig.Metas.filter(e => e.id == t).head,
        cohort = projectConfig.Cohorts.filter(e => e.id == c).head,
        known = projectConfig.Knowns.filter(e => e.id == k).head)
    }

  }

  val y = for {
    section <- projectConfig.Reports.flatMap(e => e.sections).filter(e => e.merges.isDefined && e.knowns.isDefined)
  } yield {
   
    for {
      m <- section.models
      g <- section.merges.get
      t <- projectConfig.Merges.filter(e => e.id == g).head.cohorts_metas if projectConfig.Metas.filter(e => e.id == t).size > 0
      c <- projectConfig.Cohorts.filter(e => projectConfig.Metas.filter(e => e.id == t).head.cohorts contains e.id).map(e => e.id)
      k <- section.knowns.get
    } yield {
      CohortMetaKnownAssoc(
        model = projectConfig.Models.filter(e => e.id == m).head,
        meta = projectConfig.Metas.filter(e => e.id == t).head,
        cohort = projectConfig.Cohorts.filter(e => e.id == c).head,
        known = projectConfig.Knowns.filter(e => e.id == k).head)
    }
  
  }
  x ++ y

}.flatten.distinct

val metas: Seq[ConfigMeta] = {

  val x = for {
    section <- projectConfig.Reports.flatMap(e => e.sections).filter(e => e.metas.isDefined)
  } yield {
    for {
      t <- section.metas.get
    } yield {
      projectConfig.Metas.filter(e => e.id == t).head
    }
  }

  val y = for {
    section <- projectConfig.Reports.flatMap(e => e.sections).filter(e => e.merges.isDefined)
  } yield {
    for {
      g <- section.merges.get
      t <- projectConfig.Merges.filter(e => e.id == g).head.cohorts_metas if projectConfig.Metas.filter(e => e.id == t).size > 0
    } yield {
      projectConfig.Metas.filter(e => e.id == t).head
    }
  }
  x ++ y

}.flatten.distinct

val merges: Seq[ConfigMerge] = {

  for {
    section <- projectConfig.Reports.flatMap(e => e.sections).filter(e => e.merges.isDefined)
  } yield {
    for {
      m <- section.merges.get
    } yield {
      projectConfig.Merges.filter(e => e.id == m).head
    }
  }

}.flatten.distinct

val modelMetas: Seq[ModelMeta] = {

  val x = for {
    section <- projectConfig.Reports.flatMap(e => e.sections).filter(e => e.metas.isDefined)
  } yield {
    for {
      m <- section.models
      t <- section.metas.get
    } yield {
      ModelMeta(
        model = projectConfig.Models.filter(e => e.id == m).head,
        meta = projectConfig.Metas.filter(e => e.id == t).head)
    }
  }

  val y = for {
    section <- projectConfig.Reports.flatMap(e => e.sections).filter(e => e.merges.isDefined)
  } yield {
    for {
      m <- section.models
      g <- section.merges.get
      t <- projectConfig.Merges.filter(e => e.id == g).head.cohorts_metas if projectConfig.Metas.filter(e => e.id == t).size > 0
    } yield {
      ModelMeta(
        model = projectConfig.Models.filter(e => e.id == m).head,
        meta = projectConfig.Metas.filter(e => e.id == t).head)
    }
  }
  x ++ y

}.flatten.distinct

val modelMerges: Seq[ModelMerge] = {

  for {
    section <- projectConfig.Reports.flatMap(e => e.sections).filter(e => e.merges.isDefined)
  } yield {
    for {
      m <- section.models
      t <- section.merges.get
    } yield {
      ModelMerge(
        model = projectConfig.Models.filter(e => e.id == m).head,
        merge = projectConfig.Merges.filter(e => e.id == t).head)
    }
  }

}

val modelMetaKnowns: Seq[ModelMetaKnown] = {

  val x = for {
    section <- projectConfig.Reports.flatMap(e => e.sections).filter(e => e.metas.isDefined && e.knowns.isDefined)
  } yield {
    for {
      m <- section.models
      t <- section.metas.get
      k <- section.knowns.get
    } yield {
      ModelMetaKnown(
        model = projectConfig.Models.filter(e => e.id == m).head,
        meta = projectConfig.Metas.filter(e => e.id == t).head,
        known = projectConfig.Knowns.filter(e => e.id == k).head)
    }
  }

  val y = for {
    section <- projectConfig.Reports.flatMap(e => e.sections).filter(e => e.merges.isDefined && e.knowns.isDefined)
  } yield {
    for {
      m <- section.models
      g <- section.merges.get
      t <- projectConfig.Merges.filter(e => e.id == g).head.cohorts_metas if projectConfig.Metas.filter(e => e.id == t).size > 0
      k <- section.knowns.get
    } yield {
      ModelMetaKnown(
        model = projectConfig.Models.filter(e => e.id == m).head,
        meta = projectConfig.Metas.filter(e => e.id == t).head,
        known = projectConfig.Knowns.filter(e => e.id == k).head)
    }
  }
  x ++ y

}.flatten.distinct

