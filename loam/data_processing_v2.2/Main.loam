import ProjectConfig._
import PipelineConfig._
import Directories._
import StoreHelpers._
import ProjectStores._
import ArrayStores._
import Prepare._
import Harmonize._
import Load._
import FilterForQc._
import Kinship._
import Ancestry._
import Pca._
import SampleQc._
import FilterFinal._
import Impute._
import VariantAssoc._
import CrossCohort._
import Meta._
import Merge._
//import ResultsSummary._
import AssocStores._
//import Phenotype._
import QcReport._
//import AnalysisReport._

import loamstream.conf.DataConfig
import loamstream.googlecloud.HailSupport._
import loamstream.model.Store
import loamstream.util.CanBeClosed.enclosed

//throw new Exception(s"\ncohorts to be run:\n%s\ncohortKnowns to be run:\n%s\nmeta cohorts to be run:\n%s\nmeta cohortKnowns to be run:\n%s\n".format(s"${cohortAssocs.mkString("\n")}",s"${cohortKnownAssocs.mkString("\n")}",s"${cohortMetaAssocs.mkString("\n")}",s"${cohortMetaKnownAssocs.mkString("\n")}"))
//throw new Exception(s"metas:\n%s\n".format(s"${metas.mkString("\n")}"))
//throw new Exception(s"model metas:\n%s\n".format(s"${modelMetas.mkString("\n")}"))
//throw new Exception(s"model meta knowns:\n%s\n".format(s"${modelMetaKnowns.mkString("\n")}"))

// Array specific QC steps up to ancestry inferrence
for {
  array <- projectConfig.Arrays
} yield { 

  Prepare(array.id)
  Harmonize(array.id)
  Load(array.id)
  FilterForQc(array.id)
  Kinship(array.id)
  AncestryPca(array.id)
  AncestryCluster(array.id)

}

// Reconcile inferred ancestry
MergeInferredAncestry()

// Array specific QC steps post ancestry inference
for {
  array <- projectConfig.Arrays
} yield { 

  Pca(array.id)
  SampleQc(array.id)
  FilterFinal(array.id)

}

// QC Report
QcReport()

// Generate imputation ready data files
for {
  array <- projectConfig.Arrays
} yield { 

  FilterImpute(array.id)

}

// Cohort variant association
for {
  x <- cohortAssocs
} yield {

  VariantAssoc(configModel = x.model, configCohort = x.cohort, configMeta = None)

}

// Cohort variant association for known loci
for {
  x <- cohortKnownAssocs
} yield {

  KnownLociAssoc(configModel = x.model, configCohort = x.cohort, configKnown = x.known, configMeta = None)

}

// Meta-analysis cross-cohort common variants search
for {
  meta <- metas
} yield {

  CrossCohortCommonVars(configMeta = meta)

}

// Meta-analysis cross-cohort qc prep
for {
  meta <- metas
  cohort <- projectConfig.Cohorts.filter(e => meta.cohorts contains e.id)
} yield {

  CrossCohortPrep(configMeta = meta, configCohort = cohort)

}

// Meta-analysis cross-array kinship
for {
  meta <- metas
} yield {

  CrossCohortKinship(meta)

}

// Meta-analysis calculate cross-cohort kinship sample exclusions
for {
  meta <- metas
  cohort <- projectConfig.Cohorts.filter(e => meta.cohorts contains e.id)
} yield {

  CrossCohortExclude(configMeta = meta, configCohort = cohort)

}

// Meta-analysis specific cohort variant association
for {
  x <- cohortMetaAssocs
} yield { 

  VariantAssoc(configCohort = x.cohort, configModel = x.model, configMeta = Some(x.meta))

}

// Meta-analysis specific cohort variant association for known loci
for {
  x <- cohortMetaKnownAssocs
} yield { 

  KnownLociAssoc(configModel = x.model, configCohort = x.cohort, configKnown = x.known, configMeta = Some(x.meta))

}

// Meta-analysis
for {
  x <- modelMetas
} yield {

  MetaAnalysis(configModel = x.model, configMeta = x.meta)

}

// Meta-analysis for known loci
for {
  x <- modelMetaKnowns
} yield {

  MetaAnalysisKnownLoci(configModel = x.model, configMeta = x.meta, configKnown = x.known)

}

// Merge results
for {
  x <- modelMerges
} yield {

  MergeAssoc(configModel = x.model, configMerge = x.merge)

}

//// Cohort Results Summary
//for {
//  cohort <- projectConfig.Cohorts if cohort.report
//  model <- projectConfig.Models
//} yield { 
//
//  ResultsSummary(configModel = model, id = cohort.id, results = assocStores((None, cohort, model)).results)
//
//}
//
//// Meta Results Summary
//for {
//  meta <- projectConfig.Metas if meta.report
//  model <- projectConfig.Models
//} yield { 
//
//  ResultsSummary(configModel = model, id = meta.id, results = metaStores(meta.id).metaResultsData(model).results)
//
//}
//
//// Cohort Known Loci Results Summary
//for {
//  cohort <- projectConfig.Cohorts if cohort.report
//  known <- projectConfig.KnownLoci
//} yield { 
//
//  ResultsKnownLociSummary(configKnownLoci = known, id = cohort.id, results = knownLociStores((None, cohort, known)).assoc.results, known_data = knownLociStores((None, cohort, known)).data, hiLd = knownLociStores((None, cohort, known)).hiLd)
//
//}
//
//// Meta Known Loci Results Summary
//for {
//  meta <- projectConfig.Metas if meta.report
//  known <- projectConfig.KnownLoci
//} yield { 
//
//  ResultsKnownLociSummary(configKnownLoci = known, id = meta.id, results = metaStores(meta.id).metaKnownLociResultsData(known).results, known_data = knownLociStores((None, projectConfig.Cohorts.filter(e => e.id == meta.cohorts(0))(0), known)).data, hiLd = knownLociStores((None, projectConfig.Cohorts.filter(e => e.id == meta.cohorts(0))(0), known)).hiLd)
//
//}
//
//// Generate Phenotype Figures for Cohorts
//for {
//  cohort <- projectConfig.Cohorts
//  phenotype <- projectConfig.Models.map(m => m.pheno).distinct
//} yield { 
//
//  PhenotypeDistPlots(configCohort = cohort, pheno = phenotype)
//
//}
//
//// Generate Phenotype Figures for Meta Cohorts
//for {
//  meta <- projectConfig.Metas
//  cohort <- projectConfig.Cohorts.filter(e => meta.cohorts contains e.id)
//  phenotype <- projectConfig.Models.map(m => m.pheno).distinct
//} yield { 
//
//  PhenotypeDistPlots(configCohort = cohort, pheno = phenotype, configMeta = Some(meta))
//
//}
//
//// Analysis Report Global
//for {
//  phase <- projectConfig.Models.map(m => m.phase).distinct.sorted
//} yield {
//
//  AnalysisReportGlobal(phase = phase)
//
//}
//
//// Analysis Report Pheno
//for {
//  phase <- projectConfig.Models.map(m => m.phase).distinct.sorted
//  pheno <- projectConfig.Models.filter(e => e.phase == phase).map(m => m.pheno).distinct
//} yield {
//
//  AnalysisReportPheno(phase = phase, pheno = pheno, name = projectConfig.Phenos.filter(e => e.pheno == pheno)(0).name)
//
//}
//
//// Analysis Report Compile
//for {
//  phase <- projectConfig.Models.map(m => m.phase).distinct.sorted
//} yield {
//
//AnalysisReportCompile(phase = phase)
//
//}
