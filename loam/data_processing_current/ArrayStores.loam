import ProjectConfig._
import PipelineConfig._
import StoreHelpers._

final case class RawData(
  data: Seq[Store],
  base: Path,
  rawBase: Path,
  unplaced: Store,
  unique: Store,
  indel: Store,
  lmiss: Store,
  imiss: Store,
  imissRemove: Store,
  freq: Store,
  mono: Store,
  dupRemove: Store)

final case class PreparedData(
  data: Seq[Store],
  base: Path,
  multiallelic: Store,
  chain: Option[Store] = None,
  bed: Option[Store] = None,
  lifted: Option[Store] = None,
  unlifted: Option[Store] = None,
  liftedUpdate: Option[Store] = None,
  liftedExtract: Option[Store] = None)

final case class AnnotatedData(
  data: Seq[Store],
  base: Path)

final case class AnnotatedChrData(
  data: Seq[Store],
  base: Path,
  mergedKgBase: Path,
  mergedKg: Seq[Store],
  mergedKgHuRefBase: Path,
  mergedKgHuRef: Seq[Store],
  mergedKgNonKgBase: Path,
  nonKgRemove: Store,
  nonKgIgnore: Store,
  nonKgMono: Store,
  nonKgNomatch: Store,
  nonKgFlip: Store,
  nonKgForceA1: Store,
  mergedKgVarIdUpdate: Store,
  mergedKgVarSnpLog: Store)

final case class HarmonizedData(
  data: Seq[Store],
  base: Path,
  mergeList: Store,
  nonKgRemove: Store,
  nonKgIgnore: Store,
  nonKgMono: Store,
  nonKgNomatch: Store,
  nonKgFlip: Store,
  nonKgForceA1: Store,
  mergedKgVarIdUpdate: Store,
  mergedKgVarSnpLog: Store,
  forceA2: Store,
  refData: Seq[Store],
  refBase: Path,
  vcf: Store,
  tbi: Store,
  vcfGoogle: Store,
  tbiGoogle: Store,
  vdsGoogle: Store,
  variantQcGoogle: Store)

final case class FilteredData(
  dataGoogle: Seq[Store],
  baseGoogle: URI,
  prunedInGoogle: Store,
  data: Seq[Store],
  base: Path,
  vdsGoogle: Store)

final case class Array(
  rawData: RawData,
  preparedData: PreparedData,
  annotatedData: AnnotatedData,
  annotatedChrData: Map[Int, AnnotatedChrData],
  harmonizedData: HarmonizedData,
  filteredData: FilteredData)

val arrayStores = projectConfig.Arrays.map(a => a.id).map { array =>

  val arrayCfg = projectConfig.Arrays.filter(_.id == array)(0)
  val rawBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.raw"
  val preparedBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.prepared"
  val annotatedBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.prepared.annotated"
  val harmonizedBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.harmonized"
  val refBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.ref"
  val filteredBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.ref.filtered"

  val rawData = RawData(
    data = Seq(store.at(path(arrayCfg.filename + s".bed")).asInput,store.at(path(arrayCfg.filename + s".bim")).asInput,store.at(path(arrayCfg.filename + s".fam")).asInput),
    base = path(arrayCfg.filename),
    rawBase = localOutDir / rawBaseString,
    unplaced = store.at(localOutDir / s"${rawBaseString}.unplaced"),
    unique = store.at(localOutDir / s"${rawBaseString}.unique"),
    indel = store.at(localOutDir / s"${rawBaseString}.indel"),
    lmiss = store.at(localOutDir / s"${rawBaseString}.missing.lmiss"),
    imiss = store.at(localOutDir / s"${rawBaseString}.missing.imiss"),
    imissRemove = store.at(localOutDir / s"${rawBaseString}.missing.imiss.remove"),
    freq = store.at(localOutDir / s"${rawBaseString}.freq.frq"),
    mono = store.at(localOutDir / s"${rawBaseString}.mono"),
    dupRemove = store.at(localOutDir / s"${rawBaseString}.dup.remove"))

  val preparedData = PreparedData(
    data = bedBimFam(localOutDir / preparedBaseString),
    base = localOutDir / preparedBaseString,
    multiallelic = store.at(localOutDir / s"${preparedBaseString}.multiallelic"),
    chain = arrayCfg.liftOver.map(s => store.at(path(s)).asInput),
    bed = arrayCfg.liftOver.map(s => store.at(localOutDir / s"${preparedBaseString}.liftover.bed")),
    lifted = arrayCfg.liftOver.map(s => store.at(localOutDir / s"${preparedBaseString}.lifted")),
    unlifted = arrayCfg.liftOver.map(s => store.at(localOutDir / s"${preparedBaseString}.unlifted")),
    liftedUpdate = arrayCfg.liftOver.map(s => store.at(localOutDir / s"${preparedBaseString}.lifted.update")),
    liftedExtract = arrayCfg.liftOver.map(s => store.at(localOutDir / s"${preparedBaseString}.lifted.extract")))

  val annotatedData = AnnotatedData(
    data = arrayCfg.liftOver match {
      case Some(s) => bedBimFam(localOutDir / annotatedBaseString)
      case None => preparedData.data 
    },
    base = arrayCfg.liftOver match {
      case Some(s) => localOutDir / annotatedBaseString
      case None => localOutDir / preparedBaseString 
    })

  val annotatedChrData = ( 1 to { if ( arrayCfg.xChr ) 23 else 22 } ).map { chr =>

    val chrBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.chr${chr}"
    val mergedKgBaseString = s"${chrBaseString}.harmkg"
    val mergedKgHuRefBaseString = s"${mergedKgBaseString}.huref"
    val mergedKgNonKgBaseString = s"${mergedKgBaseString}.nonkg"

    chr -> AnnotatedChrData(
      data = bedBimFam(localOutDir / chrBaseString),
      base = localOutDir / chrBaseString,
      mergedKgBase = localOutDir / mergedKgBaseString,
      mergedKg = bedBimFam(localOutDir / mergedKgBaseString),
      mergedKgHuRefBase = localOutDir / mergedKgHuRefBaseString,
      mergedKgHuRef = bedBimFam(localOutDir / mergedKgHuRefBaseString),
      mergedKgNonKgBase = localOutDir / mergedKgNonKgBaseString,
      nonKgRemove = store.at(localOutDir / s"${mergedKgNonKgBaseString}.remove"),
      nonKgIgnore = store.at(localOutDir / s"${mergedKgNonKgBaseString}.ignore"),
      nonKgMono = store.at(localOutDir / s"${mergedKgNonKgBaseString}.mono"),
      nonKgNomatch = store.at(localOutDir / s"${mergedKgNonKgBaseString}.nomatch"),
      nonKgFlip = store.at(localOutDir / s"${mergedKgNonKgBaseString}.flip"),
      nonKgForceA1 = store.at(localOutDir / s"${mergedKgNonKgBaseString}.force_a1"),
      mergedKgVarIdUpdate = store.at(localOutDir / s"${mergedKgBaseString}_idUpdates.txt"),
      mergedKgVarSnpLog = store.at(localOutDir / s"${mergedKgBaseString}_snpLog.log"))

  }.toMap

  val harmonizedData = HarmonizedData(
    data = bedBimFam(localOutDir / harmonizedBaseString),
    base = localOutDir / harmonizedBaseString,
    mergeList = store.at(localOutDir / s"${harmonizedBaseString}.merge.txt"),
    nonKgRemove = store.at(localOutDir / s"${harmonizedBaseString}.nonkg.remove"),
    nonKgIgnore = store.at(localOutDir / s"${harmonizedBaseString}.nonkg.ignore"),
    nonKgMono = store.at(localOutDir / s"${harmonizedBaseString}.nonkg.mono"),
    nonKgNomatch = store.at(localOutDir / s"${harmonizedBaseString}.nonkg.nomatch"),
    nonKgFlip = store.at(localOutDir / s"${harmonizedBaseString}.nonkg.flip"),
    nonKgForceA1 = store.at(localOutDir / s"${harmonizedBaseString}.nonkg.force_a1"),
    mergedKgVarIdUpdate = store.at(localOutDir / s"${harmonizedBaseString}_idUpdates.txt"),
    mergedKgVarSnpLog = store.at(localOutDir / s"${harmonizedBaseString}_snpLog.log"),
    forceA2 = store.at(localOutDir / s"${refBaseString}.force_a2.txt"),
    refData = bedBimFam(localOutDir / refBaseString),
    refBase = localOutDir / refBaseString,
    vcf = store.at(localOutDir / s"${refBaseString}.vcf.gz"),
    tbi = store.at(localOutDir / s"${refBaseString}.vcf.gz.tbi"),
    vcfGoogle = store.at(googleOutDir / s"${refBaseString}.vcf.gz"),
    tbiGoogle = store.at(googleOutDir / s"${refBaseString}.vcf.gz.tbi"),
    vdsGoogle = store.at(googleOutDir / s"${refBaseString}.vds"),
    variantQcGoogle = store.at(googleOutDir / s"${refBaseString}.variantqc.tsv"))

  val filteredData = FilteredData(
    dataGoogle = bedBimFam(googleOutDir / filteredBaseString),
    baseGoogle = googleOutDir / filteredBaseString,
    prunedInGoogle = store.at(googleOutDir / s"${filteredBaseString}.prunedin.tsv"),
    data = bedBimFam(localOutDir / filteredBaseString),
    base = localOutDir / filteredBaseString,
    vdsGoogle = store.at(googleOutDir / s"${filteredBaseString}.vds"))

  array -> Array(
    rawData = rawData,
    preparedData = preparedData,
    annotatedData = annotatedData,
    annotatedChrData = annotatedChrData,
    harmonizedData = harmonizedData,
    filteredData = filteredData)

}.toMap
