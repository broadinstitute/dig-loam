import scala.util.{Try, Success, Failure}
import scala.util.control.NonFatal
import java.nio.file.{Paths, Files}
import java.io.{File, BufferedWriter, FileWriter}

final case class CfgException(s: String) extends Exception(s)

trait Debug{
  def debugVars(): Any = {
    val vars = this.getClass.getDeclaredFields
    val name = this.getClass.getName.split("\\$")(1)
    for(v <- vars) {
      v.setAccessible(true)
      println("Class: " + name + " Field: " + v.getName() + " => " + v.get(this))
    }
  }
}

final case class Dir(
  base: String,
  data: String,
  kinship: String,
  ancestry: String) extends Debug

final case class Data(
  id: String,
  file: Either[Store, Seq[Store]],
  format: String,
  tech: String,
  desc: String,
  build: String,
  nAncPcs: Int,
  metrics: Seq[String],
  ancestryOutliersKeep: Option[Seq[String]],
  duplicatesKeep: Option[Seq[String]],
  famsizeKeep: Option[Seq[String]],
  sampleqcKeep: Option[Seq[String]],
  sexcheckKeep: Option[Seq[String]]) extends Debug

final case class Cfg(
  dir: Dir,
  id: String,
  regExcl: Option[String],
  genePos: String,
  aimRef: String,
  refSam: Store,
  refSamId: String,
  refSamPop: String,
  refSamGrp: String,
  refVcfs: Map[String, Store],
  refVcfsIDs: Map[String, Store],
  huRefs: Map[String, Store],
  pheno: Store,
  phenoStatus: String,
  phenoId: String,
  phenoSex: String,
  phenoRace: String,
  qcReportAuthors: Seq[String],
  analysisReportAuthors: Seq[String],
  analysisReportAcknowledgements: Seq[String],
  data: Seq[Data]) extends Debug

object Cfg{

  def requiredStr(config: loamstream.conf.DataConfig, field: String, regex: String = ".*", default: Option[String] = None): String = {
    Try(config.getStr(field)) match {
      case Success(o) =>
        o.matches(regex) match {
          case false => throw new CfgException("requiredStr: field " + field + " value " + o + " does not match regex format " + regex)
          case true => o
        }
      case Failure(NonFatal(e)) => 
        default match {
          case Some(s) => s
          case None => throw new CfgException("requiredStr: field '" + field + "' not found")
        }
      case Failure(_)           => throw new CfgException("requiredStr: field '" + field + "' fatal error")
    }
  }

  def optionalStr(config: loamstream.conf.DataConfig, field: String, regex: String = ".*"): Option[String] = {
    Try(config.getStr(field)) match {
      case Success(o) =>
        o.matches(regex) match {
          case false => throw new CfgException("optionalStr: field " + field + " value " + o + " does not match regex format " + regex)
          case true => Some(o)
        }
      case Failure(NonFatal(e)) => None
      case Failure(_)           => throw new CfgException("optionalStr: field '" + field + "' fatal error")
    }
  }
  
  def requiredInt(config: loamstream.conf.DataConfig, field: String, default: Option[Int]): Int = {
    Try(config.getInt(field)) match {
      case Success(o) => o
      case Failure(NonFatal(e)) =>
        default match {
          case Some(i) => i
          case None => throw new CfgException("requiredInt: field '" + field + "' not found")
        }
      case Failure(_)           => throw new CfgException("requiredInt: field '" + field + "' fatal error")
    }
  }
  
  def requiredStrList(config: loamstream.conf.DataConfig, field: String, default: Option[Seq[String]] = None): Seq[String] = {
    Try(config.getStrList(field)) match {
      case Success(o)           => o
      case Failure(NonFatal(e)) => 
        default match {
          case Some(s) => s
          case None => throw new CfgException("requiredStrList: field '" + field + "' not found")
        }
      case Failure(_)           => throw new CfgException("requiredStrList: field '" + field + "' fatal error")
    }
  }
  
  def optionalStrList(config: loamstream.conf.DataConfig, field: String): Option[Seq[String]] = {
    Try(config.getStrList(field)) match {
      case Success(o)           => Some(o)
      case Failure(NonFatal(e)) => None
      case Failure(_)           => throw new CfgException("optionalStrList: field '" + field + "' fatal error")
    }
  }

  def checkPath(s: String): String = {
    Files.exists(Paths.get(s)) match {
      case false => throw new CfgException("checkPath: " + s + " not found")
      case true  => s
    }
  }

  def initDir(s: String): String = {
    val dir = Paths.get(s)
    Files.exists(dir) match {
      case false =>
        Files.createDirectory(dir)
        s
      case true  => s
    }
  }

  def parse(config: loamstream.conf.DataConfig): Cfg = {

    val id = requiredStr(config = config, field = "id", regex = "^[a-zA-Z0-9]*$")

    val dir = {

      val base = initDir("results")
      val data = initDir(base + "/data")
      val kinship = initDir(base + "/kinship")
      val ancestry = initDir(base + "/ancestry")

      new Dir(
        base = base,
        data = data,
        kinship = kinship,
        ancestry = ancestry)

    }

    val regExcl = optionalStr(config = config, field = "regExcl")
    val genePos = checkPath(requiredStr(config = config, field = "genePos"))
    val aimRef = checkPath(requiredStr(config = config, field = "aimRef"))

    val refSam = store.at(checkPath(requiredStr(config = config, field = "refSam"))).asInput
    val refSamId = requiredStr(config = config, field = "refSamId", default = Some("ID"))
    val refSamPop = requiredStr(config = config, field = "refSamPop", default = Some("POP"))
    val refSamGrp = requiredStr(config = config, field = "refSamGrp", default = Some("GROUP"))
    val chrSeq = (1 to 22).map(e => e.toString).toSeq ++ Seq("X","Y","MT")
    val refVcfs = chrSeq.map { chr =>
      val vcf = store.at(checkPath(requiredStr(config = config, field = "refVcfs").replace("[CHROMOSOME]", s"$chr"))).asInput
      chr -> vcf
    }.toMap
    val refVcfsIDs = chrSeq.map { chr =>
      val vcfsIDs = store.at(checkPath(requiredStr(config = config, field = "refVcfsIDs").replace("[CHROMOSOME]", s"$chr"))).asInput
      chr -> vcfsIDs
    }.toMap
    val huRefs = chrSeq.map { chr =>
      val huRef = store.at(checkPath(requiredStr(config = config, field = "huRefs").replace("[CHROMOSOME]", s"$chr"))).asInput
      chr -> huRef
    }.toMap

    val pheno = store.at(checkPath(requiredStr(config = config, field = "pheno"))).asInput
    val phenoStatus = requiredStr(config = config, field = "phenoStatus")
    val phenoId = requiredStr(config = config, field = "phenoId", default = Some("ID"))
    val phenoSex = requiredStr(config = config, field = "phenoSex", default = Some("SEX"))
    val phenoRace = requiredStr(config = config, field = "phenoRace", default = Some("RACE"))

    val qcReportAuthors = requiredStrList(config = config, field = "qcReportAuthors")
    val analysisReportAuthors = requiredStrList(config = config, field = "analysisReportAuthors")
    val analysisReportAcknowledgements = requiredStrList(config = config, field = "analysisReportAcknowledgements")

    val data = {
      for {
        dat <- config.getObjList("data")
      } yield {
        val format = requiredStr(config = dat, field = "format", regex = "vcf|plink")
        val file = {
          format match {
            case "plink" =>
              Right(Seq(store.at(checkPath(requiredStr(config = dat, field = "file") + ".bed")).asInput, store.at(checkPath(requiredStr(config = dat, field = "file") + ".bim")).asInput, store.at(checkPath(requiredStr(config = dat, field = "file") + ".fam")).asInput))
            case _ =>
              Left(store.at(checkPath(requiredStr(config = dat, field = "file"))).asInput)
          }
        }
        Data(
          id = requiredStr(config = dat, field = "id", regex = "^[a-zA-Z0-9_]*$"),
          file = file,
          format = format,
          tech = requiredStr(config = dat, field = "tech", regex = "ex_array|gwas_array|custom_array|wes|wgs"),
          desc = requiredStr(config = dat, field = "desc"),
          build = requiredStr(config = dat, field = "build", regex = "hg18|hg19|hg38"),
          nAncPcs = requiredInt(config = dat, field = "nAncPcs", default = Some(3)),
          metrics = requiredStrList(config = dat, field = "sampleQcMetrics", default = Some(Seq("nNonRef_res","nHet_res","nCalled_res","callRate_res","rTiTv_res","het_res","hetLow_res","hetHigh_res","nHomVar_res","rHetHomVar_res"))),
          ancestryOutliersKeep = optionalStrList(config = dat, field = "ancestryOutliersKeep"),
          duplicatesKeep = optionalStrList(config = dat, field = "duplicatesKeep"),
          famsizeKeep = optionalStrList(config = dat, field = "famsizeKeep"),
          sampleqcKeep = optionalStrList(config = dat, field = "sampleqcKeep"),
          sexcheckKeep = optionalStrList(config = dat, field = "sexcheckKeep"))
      }
    }

	new Cfg(
      dir = dir,
      id = id,
      regExcl = regExcl,
      genePos = genePos,
      aimRef = aimRef,
      refSam = refSam,
      refSamId = refSamId,
      refSamPop = refSamPop,
      refSamGrp = refSamGrp,
      refVcfs = refVcfs,
      refVcfsIDs = refVcfsIDs,
      huRefs = huRefs,
      pheno = pheno,
      phenoStatus = phenoStatus,
      phenoId = phenoId,
      phenoSex = phenoSex,
      phenoRace = phenoRace,
      qcReportAuthors = qcReportAuthors,
      analysisReportAuthors = analysisReportAuthors,
      analysisReportAcknowledgements = analysisReportAcknowledgements,
      data = data)

  }

}

def writeCfg(cfg: Cfg): Any = {
  val f = new File(cfg.dir.base + "/.cfg")
  val bw = new BufferedWriter(new FileWriter(f))
  val objs = Seq(cfg.dir, cfg) ++ cfg.data
  for ( o <- objs ) {
    val vars = o.getClass.getDeclaredFields
    val name = o.getClass.getName.split("\\$")(1)
    bw.write("Class: " + name + "\n")
    for ( v <- vars ) {
      v.setAccessible(true)
      bw.write("  " + v.getName() + " => " + v.get(o).toString + "\n")
    }
    bw.write("\n")
  }
  bw.close()
}
