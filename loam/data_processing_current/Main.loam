import ProjectConfig._
import PipelineConfig._
import Directories._
import StoreHelpers._
import ProjectStores._
import ArrayStores._
import Prepare._
import Harmonize._
import Load._
import FilterForQc._
import Kinship._
import Ancestry._
import Pca._
import SampleQc._
import FilterFinal._
import VariantAssoc._
import CrossCohort._
import Impute._
import Meta._
import QcReport._

import loamstream.conf.DataConfig
import loamstream.googlecloud.HailSupport._
import loamstream.model.Store
import loamstream.util.CanBeClosed.enclosed

// Array specific QC steps up to ancestry inferrence
for {
  array <- projectConfig.Arrays
} yield { 

  Prepare(array.id)
  Harmonize(array.id)
  Load(array.id)
  FilterForQc(array.id)
  Kinship(array.id)
  AncestryPca(array.id)
  AncestryCluster(array.id)

}

// Reconcile inferred ancestry
MergeInferredAncestry()

// Array specific QC steps post ancestry inference
for {
  array <- projectConfig.Arrays
} yield { 

  Pca(array.id)
  SampleQc(array.id)
  FilterFinal(array.id)

}

// Generate imputation ready data files
for {
  array <- projectConfig.Arrays
} yield { 

  FilterImpute(array.id)

}

// Cohort variant association
for {
  cohort <- projectConfig.Cohorts if cohort.report;
  model <- projectConfig.Models
} yield { 

  VariantAssoc(configCohort = cohort, configModel = model, configMeta = None)

}

// Cohort variant association for known loci
for {
  cohort <- projectConfig.Cohorts if cohort.report;
  known <- projectConfig.KnownLoci
} yield { 

  KnownLociAssoc(configCohort = cohort, configKnownLoci = known, configMeta = None)

}

// Meta-analysis cross-cohort qc prep
for {
  meta <- projectConfig.Metas if meta.report;
  cohort <- projectConfig.Cohorts.filter(e => meta.cohorts contains e.id)
} yield {

  CrossCohortPrep(configMeta = meta, configCohort = cohort)

}

// Meta-analysis cross-array kinship
for {
  meta <- projectConfig.Metas if meta.report
} yield {

  CrossCohortKinship(meta)

}

// Meta-analysis calculate cross-cohort kinship sample exclusions
for {
  meta <- projectConfig.Metas if meta.report;
  cohort <- projectConfig.Cohorts.filter(e => meta.cohorts contains e.id)
} yield {

  CrossCohortExclude(configMeta = meta, configCohort = cohort)

}

// Meta-analysis specific cohort variant association
for {
  meta <- projectConfig.Metas if meta.report;
  cohort <- projectConfig.Cohorts.filter(e => meta.cohorts contains e.id);
  model <- projectConfig.Models
} yield { 

  VariantAssoc(configCohort = cohort, configModel = model, configMeta = Some(meta))

}

// Meta-analysis specific cohort variant association for known loci
for {
  meta <- projectConfig.Metas if meta.report;
  cohort <- projectConfig.Cohorts.filter(e => meta.cohorts contains e.id);
  known <- projectConfig.KnownLoci
} yield { 

  KnownLociAssoc(configCohort = cohort, configKnownLoci = known, configMeta = Some(meta))

}

// Meta-analysis
for {
  meta <- projectConfig.Metas if meta.report;
  model <- projectConfig.Models
} yield {

  MetaAnalysis(configModel = model, configMeta = meta)

}

// Meta-analysis for known loci
for {
  meta <- projectConfig.Metas if meta.report;
  known <- projectConfig.KnownLoci
} yield {

  MetaAnalysisKnownLoci(configKnownLoci = known, configMeta = meta)

}

// QC Report
QcReport()

