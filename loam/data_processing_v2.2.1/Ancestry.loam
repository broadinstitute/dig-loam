/**
  * Ancestry PCA Step
  *  Description: Calculate PCs combined with 1KG Phase 3 Purcell 5k data
  *  Requires: Hail, R, $rPlotAncestryPca
  *  Notes:
  *     To perform ancestry inference and clustering with 1KG data, we must combine on common variants with reference data (clustering does not work when only using PCA loadings and projecting)
  */
import ProjectConfig._
import PipelineConfig._
import ArrayStores._
import ProjectStores._

def AncestryPca(array: String): Unit = {

  hailCloud match {

    case true =>

      google {
      
        hail"""$pyHailAncestryPcaMerge1kg --
          --reference-genome ${projectConfig.referenceGenome}
          --mt-in ${arrayStores(array).harmonizedData.mtGoogle.get}
          --kg-vcf-in ${ProjectStores.kgPurcellVcfGoogle.get}
          --kg-sample ${ProjectStores.kgSampleGoogle.get}
          --vcf-out ${arrayStores(array).ref1kgData.vcfGoogle.get}"""
          .in(arrayStores(array).harmonizedData.mtGoogle.get, ProjectStores.kgPurcellVcfGoogle.get, ProjectStores.kgSampleGoogle.get)
          .out(arrayStores(array).ref1kgData.vcfGoogle.get)
          .tag(s"${arrayStores(array).ref1kgData.base}.google".split("/").last)
      
      }
      
      local {
      
        googleCopy(arrayStores(array).ref1kgData.vcfGoogle.get, arrayStores(array).ref1kgData.vcf)
      
      }

    case false =>

      drmWith(imageName = s"$imgHail", cores=4, mem=2) {

        cmd"""$binPython $pyHailAncestryPcaMerge1kg
          --reference-genome ${projectConfig.referenceGenome}
          --mt-in ${arrayStores(array).harmonizedData.mt.get}
          --kg-vcf-in ${ProjectStores.kgPurcellVcf}
          --kg-sample ${ProjectStores.kgSample}
          --vcf-out ${arrayStores(array).ref1kgData.vcf}"""
          .in(arrayStores(array).harmonizedData.mt.get, ProjectStores.kgPurcellVcf, ProjectStores.kgSample)
          .out(arrayStores(array).ref1kgData.vcf)
          .tag(s"${arrayStores(array).ref1kgData.base}".split("/").last)

      }

  }

  drm {

    cmd"""$binPlink --vcf ${arrayStores(array).ref1kgData.vcf} --make-bed --out ${arrayStores(array).ref1kgData.base}""".in(arrayStores(array).ref1kgData.vcf).out(arrayStores(array).ref1kgData.data).tag(s"${arrayStores(array).ref1kgData.base}.convertPlink".split("/").last)

  }

  drmWith(cores=4, mem=4) {

    cmd"""$binRscript --vanilla --verbose
      $rPcair
      --cpus 4
      --plink-in ${arrayStores(array).ref1kgData.base}
      --gds-out ${arrayStores(array).ref1kgData.gds}
      --scores ${arrayStores(array).ancestryPcaData.scores}
      --id ${projectConfig.projectId}
      --force-unrel ${projectConfig.kgSampleId} ${ProjectStores.kgSample}
      --update-pop ${projectConfig.kgSampleId} ${projectConfig.kgSamplePop} ${ProjectStores.kgSample}
      --update-group ${projectConfig.kgSampleId} ${projectConfig.kgSampleGroup} ${ProjectStores.kgSample}
      > ${arrayStores(array).ancestryPcaData.log}"""
      .in(arrayStores(array).ref1kgData.data :+ ProjectStores.kgSample)
      .out(arrayStores(array).ref1kgData.gds, arrayStores(array).ancestryPcaData.log, arrayStores(array).ancestryPcaData.scores)
      .tag(s"${arrayStores(array).ancestryPcaData.scores}".split("/").last)

  }

  drmWith(imageName = s"$imgR34") {

    cmd"""$binRscript --vanilla --verbose
      $rPlotAncestryPca
      --id ${projectConfig.projectId}
      --pca-scores ${arrayStores(array).ancestryPcaData.scores}
      --out ${arrayStores(array).ancestryPcaData.plots}"""
      .in(arrayStores(array).ancestryPcaData.scores)
      .out(arrayStores(array).ancestryPcaData.plots)
      .tag(s"${arrayStores(array).ancestryPcaData.plots}".split("/").last)

  }

}
  
/**
  * Ancestry Cluster Step
  *  Description: Cluster with 1KG samples using Gaussian Mixture Modeling and infer ancestry
  *  Requires: Hail, R
  *  Notes:
  *     *.ancestry.inferred.tsv contains the final inferred ancestry for each sample, including OUTLIERS
  *     This file is array specific
  */

def AncestryCluster(array: String): Unit = {

  drmWith(imageName = s"$imgTools") {

    cmd"""(echo 20; sed '1d' ${arrayStores(array).ancestryPcaData.scores} | cut -f4- | sed 's/\t/ /g') > ${arrayStores(array).ancestryClusterData.fet}"""
      .in(arrayStores(array).ancestryPcaData.scores)
      .out(arrayStores(array).ancestryClusterData.fet)
      .tag(s"${arrayStores(array).ancestryClusterData.fet}".split("/").last)

  }

  drmWith(imageName = s"$imgTools", mem=8) {
  
    cmd"""$binKlustakwik ${arrayStores(array).ancestryClusterData.base} 1 -UseFeatures ${projectConfig.ancestryInferenceFeatures} -UseDistributional 0 > ${arrayStores(array).ancestryClusterData.log}"""
      .in(arrayStores(array).ancestryClusterData.fet)
      .out(arrayStores(array).ancestryClusterData.clu, arrayStores(array).ancestryClusterData.klg, arrayStores(array).ancestryClusterData.log)
      .tag(s"${arrayStores(array).ancestryClusterData.base}.binKlustakwik".split("/").last)

  }

  drmWith(imageName = s"$imgR34") {
  
    cmd"""$binRscript --vanilla --verbose
      $rPlotAncestryCluster
      --pca-scores ${arrayStores(array).ancestryPcaData.scores}
      --cluster ${arrayStores(array).ancestryClusterData.clu}
      --pheno-file ${ProjectStores.phenoFile}
      --id ${projectConfig.projectId}
      --pheno ${projectConfig.phenoFileId}
      --sr-race ${projectConfig.phenoFileSrRace}
      --cluster-plots ${arrayStores(array).ancestryClusterData.plots}
      --xtabs ${arrayStores(array).ancestryClusterData.xtab}
      --plots-centers ${arrayStores(array).ancestryClusterData.centerPlots}
      --cluster-groups ${arrayStores(array).ancestryClusterData.groups}
      --ancestry-inferred ${arrayStores(array).ancestryData.inferred}
      --cluster-plots-no1kg ${arrayStores(array).ancestryClusterData.no1kgPlots}"""
      .in(arrayStores(array).ancestryPcaData.scores, arrayStores(array).ancestryClusterData.clu, ProjectStores.phenoFile)
      .out(arrayStores(array).ancestryClusterData.plots, arrayStores(array).ancestryClusterData.xtab, arrayStores(array).ancestryClusterData.centerPlots, arrayStores(array).ancestryClusterData.groups, arrayStores(array).ancestryData.inferred, arrayStores(array).ancestryClusterData.no1kgPlots)
      .tag(s"${arrayStores(array).ancestryPcaData.scores}.rPlotAncestryCluster".split("/").last)

  }

}

/**
  * Merge Inferred Ancestry
  *  Description: Merge inferred ancestry from all arrays
  *  Requires: R
  *  Notes:
  */

def MergeInferredAncestry(): Unit = {

  val inferredList = projectConfig.Arrays.map(_.id).map(arrayStores(_).ancestryData.inferred).map(_.path).mkString(",")

  drmWith(imageName = s"$imgR34") {
  
    cmd"""$binRscript --vanilla --verbose
      $rAncestryClusterMerge
      --ancestry-in $inferredList
      --out-table ${ProjectStores.ancestryInferred}
      --out-outliers ${ProjectStores.ancestryOutliers}"""
      .in(projectConfig.Arrays.map(_.id).map(arrayStores(_).ancestryData.inferred))
      .out(ProjectStores.ancestryInferred, ProjectStores.ancestryOutliers)
      .tag(s"${ProjectStores.ancestryInferred}".split("/").last)
  
  }

}
