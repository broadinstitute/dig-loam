import ProjectConfig._
import PipelineConfig._
import StoreHelpers._

final case class ResultsSummaryData(
  sigRegions: Store,
  top1000: Store,
  top1000Genes: Store,
  top20AnnotAlignedRisk: Store,
  qqPlotPng: Store,
  mhtPlotPng: Store,
  regPlotsPdf: Store,
  regPlotsBase: Path)

final case class ResultsKnownLociSummaryData(
  top50: Store)

final case class ResultsSummary(
  resultsSummaryData: ResultsSummaryData)

final case class ResultsKnownLociSummary(
  resultsKnownLociSummaryData: ResultsKnownLociSummaryData)

val resultsSummaryStores = (
    (
      for {
        r <- projectConfig.Runs
        m <- projectConfig.Models.filter(e => r.models contains e.id)
        c <- projectConfig.Cohorts.filter(e => r.cohorts contains e.id)
      } yield {
        (m, c)
      }
    ) ++
    (
      for {
        r <- projectConfig.Runs
        m <- projectConfig.Models.filter(e => r.models contains e.id)
        t <- projectConfig.Metas.filter(e => r.metas contains e.id)
      } yield {
        (m, t)
      }
    )
  ).map { rs => 

  val model = rs._1
  val cohort: Either[ConfigCohort, ConfigMeta] = rs._2

  val prefix = s"${projectConfig.projectId}.${cohort.get.id}.${model.id}"

  val regPlotsBaseString = s"${prefix}.results.regplots"

  val resultsSummaryData = ResultsSummaryData(
    sigRegions = store(localOutDir / s"${prefix}.results.sigregions.tsv"),
    top1000 = store(localOutDir / s"${prefix}.results.top1000.tsv"),
    top1000Genes = store(localOutDir / s"${prefix}.results.top1000.genes.tsv"),
    top20AnnotAlignedRisk = store(localOutDir / s"${prefix}.results.top20.annot.aligned_risk.tsv"),
    qqPlotPng = store(localOutDir / s"${prefix}.results.qq.png"),
    mhtPlotPng = store(localOutDir / s"${prefix}.results.mht.png"),
    regPlotsBase = localOutDir / s"${prefix}.results.regplots",
    regPlotsPdf = store(localOutDir / s"${prefix}.results.regplots.pdf"))

  rs -> ResultsSummary(
    resultsSummaryData = resultsSummaryData)

}.toMap

val resultsKnownLociSummaryStores = (
    (
      for {
        r <- projectConfig.Runs
        m <- projectConfig.Models.filter(e => r.models contains e.id)
        c <- projectConfig.Cohorts.filter(e => r.cohorts contains e.id)
        k <- projectConfig.Knowns.filter(e => r.knowns contains e.id)
      } yield {
        (m, c, k)
      }
    ) ++
    (
      for {
        r <- projectConfig.Runs
        m <- projectConfig.Models.filter(e => r.models contains e.id)
        t <- projectConfig.Metas.filter(e => r.metas contains e.id)
        c <- projectConfig.Cohorts.filter(e => t.cohorts contains e.id)
        k <- projectConfig.Knowns.filter(e => r.knowns contains e.id)
      } yield {
        (m, t, k)
      }
    )
  ).map { rskl => 

  val model = rskl._1
  val cohort: Either[ConfigCohort, ConfigMeta] = rskl._2
  val known = rskl._3

  val prefix = s"${projectConfig.projectId}.${cohort.get.id}.${model.id},${known.id}"

  val resultsKnownLociSummaryData = ResultsKnownLociSummaryData(
    top50 = store(localOutDir / s"${prefix}.top50.tsv"))

  rskl -> ResultsKnownLociSummary(
    resultsKnownLociSummaryData = resultsKnownLociSummaryData)

}.toMap
