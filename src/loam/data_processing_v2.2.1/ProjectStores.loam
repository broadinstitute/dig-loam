import ProjectConfig._
import PipelineConfig._

object ProjectStores {

  val chrSeq = (1 to 22).map(e => e.toString).toSeq ++ Seq("X","Y","MT")

  val kgVcf = chrSeq.map { chr =>
  
    val vcf = store(projectConfig.kgVcf.replace("[CHROMOSOME]", s"$chr")).asInput
  
    chr -> vcf
  
  }.toMap
  
  val kgIds = chrSeq.map { chr =>
  
    val ids = store(projectConfig.kgIds.replace("[CHROMOSOME]", s"$chr")).asInput
  
    chr -> ids
  
  }.toMap
  
  val humanReference = chrSeq.map { chr =>
  
    val ref = store(projectConfig.humanReferenceWild.replace("[CHROMOSOME]", s"$chr")).asInput
  
    chr -> ref
  
  }.toMap
  
  val regionsExclude = store(path(projectConfig.regionsExclude)).asInput
  val regionsExcludeGoogle = hailCloud match { case true => Some(store(uri(projectConfig.regionsExcludeGoogle)).asInput); case false => None }
  val genePositions = store(path(projectConfig.genePositions)).asInput
  val kgPurcellVcf = store(path(projectConfig.kgPurcellVcf)).asInput
  val kgPurcellVcfGoogle = hailCloud match { case true => Some(store(uri(projectConfig.kgPurcellVcfGoogle)).asInput); case false => None }
  val kgSample = store(path(projectConfig.kgSample)).asInput
  val kgSampleGoogle = hailCloud match { case true => Some(store(uri(projectConfig.kgSampleGoogle)).asInput); case false => None }
  val phenoFile = store(path(projectConfig.phenoFile)).asInput
  val phenoFileGoogle = hailCloud match { case true => Some(store(googleOutDir / s"${projectConfig.phenoFile}".split("/").last)); case false => None }
  val ancestryInferred = store(localOutDir / s"${projectConfig.projectId}.ancestry.inferred.tsv")
  val ancestryInferredGoogle = hailCloud match { case true => Some(store(googleOutDir / s"${projectConfig.projectId}.ancestry.inferred.tsv")); case false => None }
  val ancestryOutliers = store(localOutDir / s"${projectConfig.projectId}.ancestry.inferred.outliers.tsv")

}
