/**
  * Harmonize Step
  *  Description: Align data strand to 1KG reference. Also, update reference allele and variant ID to match 1KG
  *  Requires: Plink1.9 and, at least, Genotype Harmonizer v1.4.18
  *  Notes:
  *     Could also add --variants and --mafAlign as pipeline options, but for now these are static
  *     To save time, this will be run in parallel by chromosome number
  */
import ProjectConfig._
import ArrayStores._
import ProjectStores._

import scala.collection.immutable.ListMap

def Harmonize(arrayCfg: ConfigArray): Unit = {

  for {

    (chr, chrData) <- arrayStores(arrayCfg).annotatedChrData.get

  } yield { 

    drmWith(imageName = s"${utils.image.imgTools}", cores = projectConfig.resources.harmonizePlinkFull.cpus, mem = projectConfig.resources.harmonizePlinkFull.mem, maxRunTime = projectConfig.resources.harmonizePlinkFull.maxRunTime) {

	  cmd"""${utils.binary.binPlink} --bfile ${arrayStores(arrayCfg).annotatedData.get.plink.base} --allow-no-sex --chr $chr --keep-allele-order --make-bed --out ${chrData.plink.base} --output-chr MT --memory ${projectConfig.resources.harmonizePlinkFull.mem * 0.9 * 1000}"""
        .in(arrayStores(arrayCfg).annotatedData.get.plink.data)
        .out(chrData.plink.data)
        .tag(s"${chrData.plink.base}".split("/").last)

    }

    drmWith(imageName = s"${utils.image.imgTools}", cores = projectConfig.resources.harmonizeGenotypeHarmonizer.cpus, mem = projectConfig.resources.harmonizeGenotypeHarmonizer.mem, maxRunTime = projectConfig.resources.harmonizeGenotypeHarmonizer.maxRunTime) {
    
      cmd"""java -Xms${projectConfig.resources.harmonizeGenotypeHarmonizer.mem * 0.9 * 1000}m -Xmx${projectConfig.resources.harmonizeGenotypeHarmonizer.mem * 0.9 * 1000}m -jar ${utils.binary.binGenotypeHarmonizer}
      --input ${chrData.plink.base}
      --inputType PLINK_BED
      --output ${chrData.mergedKgPlink.base}
      --outputType PLINK_BED
      --ref ${ProjectStores.kgVcf(chr)}
      --refType VCF
      --keep
      --update-id
      --variants 1000
      --mafAlign 0.1
      --update-id
      --update-reference-allele
      --debug"""
        .in(chrData.plink.data :+ ProjectStores.kgVcf(chr))
        .out(chrData.mergedKgPlink.data :+ chrData.mergedKgVarIdUpdate :+ chrData.mergedKgVarSnpLog)
        .tag(s"${chrData.mergedKgPlink.base}".split("/").last)
    
    }

    drmWith(imageName = s"${utils.image.imgPython27}", cores = projectConfig.resources.harmonizeAlignNon1kgVariants.cpus, mem = projectConfig.resources.harmonizeAlignNon1kgVariants.mem, maxRunTime = projectConfig.resources.harmonizeAlignNon1kgVariants.maxRunTime) {
      
      cmd"""${utils.binary.binPython} ${utils.python.pyAlignNon1kgVariants}
      --kg-ids ${ProjectStores.kgIds(chr)}
      --bim ${chrData.mergedKgPlink.base}.bim
      --ref ${ProjectStores.humanReference(chr)}
      --out-remove ${chrData.nonKgRemove}
      --out-ignore ${chrData.nonKgIgnore}
      --out-mono ${chrData.nonKgMono}
      --out-nomatch ${chrData.nonKgNomatch}
      --out-flip ${chrData.nonKgFlip}
      --out-force-a1 ${chrData.nonKgForceA1}"""
        .in(chrData.mergedKgPlink.data :+ ProjectStores.kgIds(chr) :+ chrData.mergedKgVarIdUpdate :+ chrData.mergedKgVarSnpLog)
        .out(chrData.nonKgRemove, chrData.nonKgIgnore, chrData.nonKgMono,chrData.nonKgNomatch, chrData.nonKgFlip, chrData.nonKgForceA1)
        .tag(s"${chrData.mergedKgNonKgBase}".split("/").last)

    }

    drmWith(imageName = s"${utils.image.imgTools}", cores = projectConfig.resources.harmonizePlinkChr.cpus, mem = projectConfig.resources.harmonizePlinkChr.mem, maxRunTime = projectConfig.resources.harmonizePlinkChr.maxRunTime) {
      
      cmd"""${utils.binary.binPlink} --bfile ${chrData.mergedKgPlink.base} --allow-no-sex --exclude ${chrData.nonKgRemove} --flip ${chrData.nonKgFlip} --a1-allele ${chrData.nonKgForceA1} --output-chr MT --make-bed --out ${chrData.mergedKgHuRefPlink.base} --memory ${projectConfig.resources.harmonizePlinkChr.mem * 0.9 * 1000}"""
        .in(chrData.mergedKgPlink.data :+ chrData.nonKgRemove :+ chrData.nonKgFlip :+ chrData.nonKgForceA1)
        .out(chrData.mergedKgHuRefPlink.data)
        .tag(s"${chrData.mergedKgHuRefPlink.base}".split("/").last)
    
    }
  
  }

  val mergedKgHuRefLines = {

    for {
      chr <- arrayStores(arrayCfg).annotatedChrData.get.map(e => e._1).toSeq.sortWith(_ < _)
    } yield {

      s"${arrayStores(arrayCfg).annotatedChrData.get(chr).mergedKgHuRefPlink.base}"

    }

  }

  drmWith(imageName = s"${utils.image.imgTools}") {
  
    cmd"""echo "${mergedKgHuRefLines.drop(1).mkString("\n")}" > ${arrayStores(arrayCfg).harmonizedData.get.mergeList}"""
      .out(arrayStores(arrayCfg).harmonizedData.get.mergeList)
      .tag(s"${arrayStores(arrayCfg).harmonizedData.get.mergeList}".split("/").last)

  }

  drmWith(imageName = s"${utils.image.imgTools}", cores = projectConfig.resources.harmonizePlinkFull.cpus, mem = projectConfig.resources.harmonizePlinkFull.mem, maxRunTime = projectConfig.resources.harmonizePlinkFull.maxRunTime) {
  
    cmd"""${utils.binary.binPlink} --bfile ${mergedKgHuRefLines.head} --allow-no-sex --merge-list ${arrayStores(arrayCfg).harmonizedData.get.mergeList} --output-chr MT --make-bed --keep-allele-order --out ${arrayStores(arrayCfg).harmonizedData.get.plink.base} --memory ${projectConfig.resources.harmonizePlinkFull.mem * 0.9 * 1000}"""
      .in(arrayStores(arrayCfg).annotatedChrData.get.map(e => e._2).flatMap(e => e.mergedKgHuRefPlink.data).toSeq :+ arrayStores(arrayCfg).harmonizedData.get.mergeList)
      .out(arrayStores(arrayCfg).harmonizedData.get.plink.data)
      .tag(s"${arrayStores(arrayCfg).harmonizedData.get.plink.base}".split("/").last)

  }

  drmWith(imageName = s"${utils.image.imgTools}") {
  
    cmd"""awk '{print $$2,$$5}' ${arrayStores(arrayCfg).harmonizedData.get.plink.base}.bim > ${arrayStores(arrayCfg).harmonizedData.get.forceA2}"""
      .in(arrayStores(arrayCfg).harmonizedData.get.plink.data)
      .out(arrayStores(arrayCfg).harmonizedData.get.forceA2)
      .tag(s"${arrayStores(arrayCfg).harmonizedData.get.forceA2}".split("/").last)

  }

  drmWith(imageName = s"${utils.image.imgTools}", cores = projectConfig.resources.harmonizePlinkFull.cpus, mem = projectConfig.resources.harmonizePlinkFull.mem, maxRunTime = projectConfig.resources.harmonizePlinkFull.maxRunTime) {
  
    cmd"""${utils.binary.binPlink} --bfile ${arrayStores(arrayCfg).harmonizedData.get.plink.base} --allow-no-sex --real-ref-alleles --a2-allele ${arrayStores(arrayCfg).harmonizedData.get.forceA2} --output-chr MT --make-bed --out ${arrayStores(arrayCfg).refData.plink.get.base.local.get} --memory ${projectConfig.resources.harmonizePlinkFull.mem * 0.9 * 1000}"""
      .in(arrayStores(arrayCfg).harmonizedData.get.plink.data :+ arrayStores(arrayCfg).harmonizedData.get.forceA2)
      .out(arrayStores(arrayCfg).refData.plink.get.data.local.get)
      .tag(s"${arrayStores(arrayCfg).refData.plink.get.base.local.get}".split("/").last)

    cmd"""${utils.bash.shPlinkToVcfNoHalfCalls} ${utils.binary.binPlink} ${arrayStores(arrayCfg).harmonizedData.get.plink.base} ${arrayStores(arrayCfg).harmonizedData.get.forceA2} ${arrayStores(arrayCfg).refData.vcf.get.base.local.get} ${projectConfig.resources.harmonizePlinkFull.mem * 0.9 * 1000} ${arrayStores(arrayCfg).refData.vcf.get.data.local.get}"""
      .in(arrayStores(arrayCfg).harmonizedData.get.plink.data :+ arrayStores(arrayCfg).harmonizedData.get.forceA2)
      .out(arrayStores(arrayCfg).refData.vcf.get.data.local.get)
      .tag(s"${arrayStores(arrayCfg).refData.vcf.get.data.local.get}".split("/").last)

  }

  drmWith(imageName = s"${utils.image.imgTools}") {
    
    cmd"""${utils.binary.binTabix} -f -p vcf ${arrayStores(arrayCfg).refData.vcf.get.data.local.get}"""
      .in(arrayStores(arrayCfg).refData.vcf.get.data.local.get)
      .out(arrayStores(arrayCfg).refData.vcf.get.tbi.local.get)
      .tag(s"${arrayStores(arrayCfg).refData.vcf.get.tbi.local.get}".split("/").last)
  
  }

  val nonKgRemoveString = ListMap(arrayStores(arrayCfg).annotatedChrData.get.toSeq.sortBy(_._1):_*).map(e => e._2).map{ e => s"""${e.nonKgRemove.toString.split("@")(1)}"""}.mkString(",")
  val nonKgMonoString = ListMap(arrayStores(arrayCfg).annotatedChrData.get.toSeq.sortBy(_._1):_*).map(e => e._2).map{ e => s"""${e.nonKgMono.toString.split("@")(1)}"""}.mkString(",")
  val nonKgNomatchString = ListMap(arrayStores(arrayCfg).annotatedChrData.get.toSeq.sortBy(_._1):_*).map(e => e._2).map{ e => s"""${e.nonKgNomatch.toString.split("@")(1)}"""}.mkString(",")
  val nonKgIgnoreString = ListMap(arrayStores(arrayCfg).annotatedChrData.get.toSeq.sortBy(_._1):_*).map(e => e._2).map{ e => s"""${e.nonKgIgnore.toString.split("@")(1)}"""}.mkString(",")
  val nonKgFlipString = ListMap(arrayStores(arrayCfg).annotatedChrData.get.toSeq.sortBy(_._1):_*).map(e => e._2).map{ e => s"""${e.nonKgFlip.toString.split("@")(1)}"""}.mkString(",")
  val nonKgForceA1String = ListMap(arrayStores(arrayCfg).annotatedChrData.get.toSeq.sortBy(_._1):_*).map(e => e._2).map{ e => s"""${e.nonKgForceA1.toString.split("@")(1)}"""}.mkString(",")
  val mergedKgVarIdUpdateString = ListMap(arrayStores(arrayCfg).annotatedChrData.get.toSeq.sortBy(_._1):_*).map(e => e._2).map{ e => s"""${e.mergedKgVarIdUpdate.toString.split("@")(1)}"""}.mkString(",")
  val mergedKgVarSnpLogString = ListMap(arrayStores(arrayCfg).annotatedChrData.get.toSeq.sortBy(_._1):_*).map(e => e._2).map{ e => s"""${e.mergedKgVarSnpLog.toString.split("@")(1)}"""}.mkString(",")
  
  drmWith(imageName = s"${utils.image.imgPython27}") {
  
    cmd"""${utils.binary.binPython} ${utils.python.pyMergeVariantLists}
      --remove-in "$nonKgRemoveString"
      --remove-mono-in "$nonKgMonoString"
      --remove-nomatch-in "$nonKgNomatchString"
      --ignore-in "$nonKgIgnoreString"
      --flip-in "$nonKgFlipString"
      --force-a1-in "$nonKgForceA1String"
      --id-updates-in "$mergedKgVarIdUpdateString"
      --snp-log-in "$mergedKgVarSnpLogString"
      --remove-out ${arrayStores(arrayCfg).harmonizedData.get.nonKgRemove}
      --remove-mono-out ${arrayStores(arrayCfg).harmonizedData.get.nonKgMono}
      --remove-nomatch-out ${arrayStores(arrayCfg).harmonizedData.get.nonKgNomatch}
      --ignore-out ${arrayStores(arrayCfg).harmonizedData.get.nonKgIgnore}
      --flip-out ${arrayStores(arrayCfg).harmonizedData.get.nonKgFlip}
      --force-a1-out ${arrayStores(arrayCfg).harmonizedData.get.nonKgForceA1}
      --id-updates-out ${arrayStores(arrayCfg).harmonizedData.get.mergedKgVarIdUpdate}
      --snp-log-out ${arrayStores(arrayCfg).harmonizedData.get.mergedKgVarSnpLog}
      """
      .in(arrayStores(arrayCfg).annotatedChrData.get.map(e => e._2).map(e => e.nonKgRemove).toSeq ++ arrayStores(arrayCfg).annotatedChrData.get.map(e => e._2).map(e => e.nonKgMono).toSeq ++ arrayStores(arrayCfg).annotatedChrData.get.map(e => e._2).map(e => e.nonKgNomatch).toSeq ++ arrayStores(arrayCfg).annotatedChrData.get.map(e => e._2).map(e => e.nonKgIgnore).toSeq ++ arrayStores(arrayCfg).annotatedChrData.get.map(e => e._2).map(e => e.nonKgFlip).toSeq ++ arrayStores(arrayCfg).annotatedChrData.get.map(e => e._2).map(e => e.nonKgForceA1).toSeq ++arrayStores(arrayCfg).annotatedChrData.get.map(e => e._2).map(e => e.mergedKgVarIdUpdate).toSeq ++ arrayStores(arrayCfg).annotatedChrData.get.map(e => e._2).map(e => e.mergedKgVarSnpLog).toSeq)
      .out(arrayStores(arrayCfg).harmonizedData.get.nonKgRemove, arrayStores(arrayCfg).harmonizedData.get.nonKgNomatch, arrayStores(arrayCfg).harmonizedData.get.nonKgMono, arrayStores(arrayCfg).harmonizedData.get.nonKgIgnore, arrayStores(arrayCfg).harmonizedData.get.nonKgFlip, arrayStores(arrayCfg).harmonizedData.get.nonKgForceA1, arrayStores(arrayCfg).harmonizedData.get.mergedKgVarIdUpdate, arrayStores(arrayCfg).harmonizedData.get.mergedKgVarSnpLog)
      .tag(s"${arrayStores(arrayCfg).harmonizedData.get.plink.base}.pyMergeVariantLists".split("/").last)
  
  }

}
