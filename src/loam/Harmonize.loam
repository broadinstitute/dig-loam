/**
  * Harmonize Step
  *  Description: Align data strand to 1KG reference. Also, update reference allele and variant ID to match 1KG
  *  Requires: Plink1.9 and, at least, Genotype Harmonizer v1.4.18
  *  Notes:
  *     Could also add --variants and --mafAlign as pipeline options, but for now these are static
  *     To save time, this will be run in parallel by chromosome number
  */
import ProjectConfig._
import PipelineConfig._
import ArrayStores._
import ProjectStores._

import scala.collection.immutable.ListMap

def Harmonize(array: String): Unit = {

  val arrayCfg = projectConfig.Arrays.filter(_.id == array)(0)

  for {

    (chr, chrData) <- arrayStores(array).annotatedChrData.get

  } yield { 

    drmWith(imageName = s"$imgTools", cores = projectConfig.resources.harmonizePlinkFull.cpus, mem = projectConfig.resources.harmonizePlinkFull.mem, maxRunTime = projectConfig.resources.harmonizePlinkFull.maxRunTime) {

	  cmd"""$binPlink --bfile ${arrayStores(array).annotatedData.get.base} --chr $chr --keep-allele-order --make-bed --out ${chrData.base} --output-chr MT --memory ${projectConfig.resources.harmonizePlinkFull.mem * 0.9 * 1000}"""
        .in(arrayStores(array).annotatedData.get.data)
        .out(chrData.data)
        .tag(s"${chrData.base}".split("/").last)

    }

    if (! arrayCfg.skipGh.contains(chr)) {

      drmWith(imageName = s"$imgTools", cores = projectConfig.resources.harmonizeGenotypeHarmonizer.cpus, mem = projectConfig.resources.harmonizeGenotypeHarmonizer.mem, maxRunTime = projectConfig.resources.harmonizeGenotypeHarmonizer.maxRunTime) {
      
        cmd"""$binGenotypeHarmonizer
        --input ${chrData.base}
        --inputType PLINK_BED
        --output ${chrData.mergedKgBase}
        --outputType PLINK_BED
        --ref ${ProjectStores.kgVcf(chr)}
        --refType VCF
        --keep
        --update-id
        --variants 1000
        --mafAlign 0.1
        --update-id
        --update-reference-allele
        --debug"""
          .in(chrData.data :+ ProjectStores.kgVcf(chr))
          .out(chrData.mergedKg :+ chrData.mergedKgVarIdUpdate :+ chrData.mergedKgVarSnpLog)
          .tag(s"${chrData.mergedKgBase}".split("/").last)
      
      }

    } else {

      local {

        cmd"""echo -e "chr\tpos\toriginalId\tnewId" > ${chrData.mergedKgVarIdUpdate}; echo -e "chr\tpos\tid\talleles\taction\tmessage" > ${chrData.mergedKgVarSnpLog}"""
          .in(chrData.data)
          .out(chrData.mergedKgVarIdUpdate, chrData.mergedKgVarSnpLog)
          .tag(s"${chrData.mergedKgBase}.skipGh".split("/").last)

      }

    }

    drmWith(imageName = s"$imgPython27", cores = projectConfig.resources.harmonizeAlignNon1kgVariants.cpus, mem = projectConfig.resources.harmonizeAlignNon1kgVariants.mem, maxRunTime = projectConfig.resources.harmonizeAlignNon1kgVariants.maxRunTime) {
      
      cmd"""$binPython $pyAlignNon1kgVariants
      --kg-ids ${ProjectStores.kgIds(chr)}
      --bim ${chrData.mergedKgBase}.bim
      --ref ${ProjectStores.humanReference(chr)}
      --out-remove ${chrData.nonKgRemove}
      --out-ignore ${chrData.nonKgIgnore}
      --out-mono ${chrData.nonKgMono}
      --out-nomatch ${chrData.nonKgNomatch}
      --out-flip ${chrData.nonKgFlip}
      --out-force-a1 ${chrData.nonKgForceA1}"""
        .in(chrData.mergedKg :+ ProjectStores.kgIds(chr) :+ chrData.mergedKgVarIdUpdate :+ chrData.mergedKgVarSnpLog)
        .out(chrData.nonKgRemove, chrData.nonKgIgnore, chrData.nonKgMono,chrData.nonKgNomatch, chrData.nonKgFlip, chrData.nonKgForceA1)
        .tag(s"${chrData.mergedKgNonKgBase}".split("/").last)

    }

    drmWith(imageName = s"$imgTools", cores = projectConfig.resources.harmonizePlinkChr.cpus, mem = projectConfig.resources.harmonizePlinkChr.mem, maxRunTime = projectConfig.resources.harmonizePlinkChr.maxRunTime) {
      
      cmd"""$binPlink --bfile ${chrData.mergedKgBase} --exclude ${chrData.nonKgRemove} --flip ${chrData.nonKgFlip} --a1-allele ${chrData.nonKgForceA1} --output-chr MT --make-bed --out ${chrData.mergedKgHuRefBase} --memory ${projectConfig.resources.harmonizePlinkChr.mem * 0.9 * 1000}"""
        .in(chrData.mergedKg :+ chrData.nonKgRemove :+ chrData.nonKgFlip :+ chrData.nonKgForceA1)
        .out(chrData.mergedKgHuRef)
        .tag(s"${chrData.mergedKgHuRefBase}".split("/").last)
    
    }
  
  }

  val mergedKgHuRefLines = {

    for {
      chr <- arrayStores(array).annotatedChrData.get.map(e => e._1).toSeq.sortWith(_ < _)
    } yield {

      s"${arrayStores(array).annotatedChrData(chr).mergedKgHuRefBase}"

    }

  }

  drmWith(imageName = s"$imgTools") {
  
    cmd"""echo "${mergedKgHuRefLines.drop(1).mkString("\n")}" > ${arrayStores(array).harmonizedData.get.mergeList}"""
      .out(arrayStores(array).harmonizedData.get.mergeList)
      .tag(s"${arrayStores(array).harmonizedData.get.mergeList}".split("/").last)

  }

  drmWith(imageName = s"$imgTools", cores = projectConfig.resources.harmonizePlinkFull.cpus, mem = projectConfig.resources.harmonizePlinkFull.mem, maxRunTime = projectConfig.resources.harmonizePlinkFull.maxRunTime) {
  
    cmd"""$binPlink --bfile ${mergedKgHuRefLines.head} --merge-list ${arrayStores(array).harmonizedData.get.mergeList} --output-chr MT --make-bed --keep-allele-order --out ${arrayStores(array).harmonizedData.get.base} --memory ${projectConfig.resources.harmonizePlinkFull.mem * 0.9 * 1000}"""
      .in(arrayStores(array).annotatedChrData.get.map(e => e._2).flatMap(e => e.mergedKgHuRef).toSeq :+ arrayStores(array).harmonizedData.get.mergeList)
      .out(arrayStores(array).harmonizedData.get.data)
      .tag(s"${arrayStores(array).harmonizedData.get.base}".split("/").last)

  }

  drmWith(imageName = s"$imgTools") {
  
    cmd"""awk '{print $$2,$$5}' ${arrayStores(array).harmonizedData.get.base}.bim > ${arrayStores(array).harmonizedData.get.forceA2}"""
      .in(arrayStores(array).harmonizedData.get.data)
      .out(arrayStores(array).harmonizedData.get.forceA2)
      .tag(s"${arrayStores(array).harmonizedData.get.forceA2}".split("/").last)

  }

  drmWith(imageName = s"$imgTools", cores = projectConfig.resources.harmonizePlinkFull.cpus, mem = projectConfig.resources.harmonizePlinkFull.mem, maxRunTime = projectConfig.resources.harmonizePlinkFull.maxRunTime) {
  
    cmd"""$binPlink --bfile ${arrayStores(array).harmonizedData.get.base} --real-ref-alleles --a2-allele ${arrayStores(array).harmonizedData.get.forceA2} --output-chr MT --make-bed --out ${arrayStores(array).refData.base} --memory ${projectConfig.resources.harmonizePlinkFull.mem * 0.9 * 1000}"""
      .in(arrayStores(array).harmonizedData.get.data :+ arrayStores(array).harmonizedData.get.forceA2)
      .out(arrayStores(array).refData.data)
      .tag(s"${arrayStores(array).refData.base}".split("/").last)
    
    cmd"""$binPlink --bfile ${arrayStores(array).harmonizedData.get.base} --output-chr MT --recode vcf-iid bgz --real-ref-alleles --a2-allele ${arrayStores(array).harmonizedData.get.forceA2} --out ${arrayStores(array).refData.base} --memory ${projectConfig.resources.harmonizePlinkFull.mem * 0.9 * 1000}"""
      .in(arrayStores(array).harmonizedData.get.data :+ arrayStores(array).harmonizedData.get.forceA2)
      .out(arrayStores(array).refData.vcf)
      .tag(s"${arrayStores(array).refData.vcf}".split("/").last)

  }

  drmWith(imageName = s"$imgTools") {
    
    cmd"""$binTabix -f -p vcf ${arrayStores(array).refData.vcf}"""
      .in(arrayStores(array).refData.vcf)
      .out(arrayStores(array).refData.tbi)
      .tag(s"${arrayStores(array).refData.tbi}".split("/").last)
  
  }

  val nonKgRemoveString = ListMap(arrayStores(array).annotatedChrData.get.toSeq.sortBy(_._1):_*).map(e => e._2).map{ e => s"""${e.nonKgRemove.toString.split("@")(1)}"""}.mkString(",")
  val nonKgMonoString = ListMap(arrayStores(array).annotatedChrData.get.toSeq.sortBy(_._1):_*).map(e => e._2).map{ e => s"""${e.nonKgMono.toString.split("@")(1)}"""}.mkString(",")
  val nonKgNomatchString = ListMap(arrayStores(array).annotatedChrData.get.toSeq.sortBy(_._1):_*).map(e => e._2).map{ e => s"""${e.nonKgNomatch.toString.split("@")(1)}"""}.mkString(",")
  val nonKgIgnoreString = ListMap(arrayStores(array).annotatedChrData.get.toSeq.sortBy(_._1):_*).map(e => e._2).map{ e => s"""${e.nonKgIgnore.toString.split("@")(1)}"""}.mkString(",")
  val nonKgFlipString = ListMap(arrayStores(array).annotatedChrData.get.toSeq.sortBy(_._1):_*).map(e => e._2).map{ e => s"""${e.nonKgFlip.toString.split("@")(1)}"""}.mkString(",")
  val nonKgForceA1String = ListMap(arrayStores(array).annotatedChrData.get.toSeq.sortBy(_._1):_*).map(e => e._2).map{ e => s"""${e.nonKgForceA1.toString.split("@")(1)}"""}.mkString(",")
  val mergedKgVarIdUpdateString = ListMap(arrayStores(array).annotatedChrData.get.toSeq.sortBy(_._1):_*).map(e => e._2).map{ e => s"""${e.mergedKgVarIdUpdate.toString.split("@")(1)}"""}.mkString(",")
  val mergedKgVarSnpLogString = ListMap(arrayStores(array).annotatedChrData.get.toSeq.sortBy(_._1):_*).map(e => e._2).map{ e => s"""${e.mergedKgVarSnpLog.toString.split("@")(1)}"""}.mkString(",")
  
  drmWith(imageName = s"$imgPython27") {
  
    cmd"""$binPython $pyMergeVariantLists
      --remove-in "$nonKgRemoveString"
      --remove-mono-in "$nonKgMonoString"
      --remove-nomatch-in "$nonKgNomatchString"
      --ignore-in "$nonKgIgnoreString"
      --flip-in "$nonKgFlipString"
      --force-a1-in "$nonKgForceA1String"
      --id-updates-in "$mergedKgVarIdUpdateString"
      --snp-log-in "$mergedKgVarSnpLogString"
      --remove-out ${arrayStores(array).harmonizedData.get.nonKgRemove}
      --remove-mono-out ${arrayStores(array).harmonizedData.get.nonKgMono}
      --remove-nomatch-out ${arrayStores(array).harmonizedData.get.nonKgNomatch}
      --ignore-out ${arrayStores(array).harmonizedData.get.nonKgIgnore}
      --flip-out ${arrayStores(array).harmonizedData.get.nonKgFlip}
      --force-a1-out ${arrayStores(array).harmonizedData.get.nonKgForceA1}
      --id-updates-out ${arrayStores(array).harmonizedData.get.mergedKgVarIdUpdate}
      --snp-log-out ${arrayStores(array).harmonizedData.get.mergedKgVarSnpLog}
      """
      .in(arrayStores(array).annotatedChrData.get.map(e => e._2).map(e => e.nonKgRemove).toSeq ++ arrayStores(array).annotatedChrData.get.map(e => e._2).map(e => e.nonKgMono).toSeq ++ arrayStores(array).annotatedChrData.get.map(e => e._2).map(e => e.nonKgNomatch).toSeq ++ arrayStores(array).annotatedChrData.get.map(e => e._2).map(e => e.nonKgIgnore).toSeq ++ arrayStores(array).annotatedChrData.get.map(e => e._2).map(e => e.nonKgFlip).toSeq ++ arrayStores(array).annotatedChrData.get.map(e => e._2).map(e => e.nonKgForceA1).toSeq ++arrayStores(array).annotatedChrData.get.map(e => e._2).map(e => e.mergedKgVarIdUpdate).toSeq ++ arrayStores(array).annotatedChrData.get.map(e => e._2).map(e => e.mergedKgVarSnpLog).toSeq)
      .out(arrayStores(array).harmonizedData.get.nonKgRemove, arrayStores(array).harmonizedData.get.nonKgNomatch, arrayStores(array).harmonizedData.get.nonKgMono, arrayStores(array).harmonizedData.get.nonKgIgnore, arrayStores(array).harmonizedData.get.nonKgFlip, arrayStores(array).harmonizedData.get.nonKgForceA1, arrayStores(array).harmonizedData.get.mergedKgVarIdUpdate, arrayStores(array).harmonizedData.get.mergedKgVarSnpLog)
      .tag(s"${arrayStores(array).harmonizedData.get.base}.pyMergeVariantLists".split("/").last)
  
  }

}
