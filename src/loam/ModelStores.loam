import ProjectConfig._
import StoreHelpers._
import Stores._
import Fxns._
import DirTree._
import Collections._

final case class Model(
  samplesMap: Store,
  samplesAvailable: Store,
  samplesAvailableLog: Store)

val modelStores = (
  for {
    x <- modelCohorts
  } yield {
    (x.model, x.cohort)
  }).map { sm =>

    val model = sm._1
    val cohort = sm._2

    val baseString = s"${projectConfig.projectId}.${model.id}.${cohort.id}"
        
    sm -> Model(
      samplesMap = model.design match {
        case "strat" => store(dirTree.analysisPhenoMap(projectConfig.Phenos.filter(e => e.id == model.pheno).head).models(model).cohorts(cohort).local.get / s"${baseString}.samples.map.tsv")
        case _ => store(dirTree.analysisPhenoMap(projectConfig.Phenos.filter(e => e.id == model.pheno).head).models(model).base.local.get / s"${baseString}.samples.map.tsv")
      },
      samplesAvailable = model.design match {
        case "strat" => store(dirTree.analysisPhenoMap(projectConfig.Phenos.filter(e => e.id == model.pheno).head).models(model).cohorts(cohort).local.get / s"${baseString}.samples.available.txt")
        case _ => store(dirTree.analysisPhenoMap(projectConfig.Phenos.filter(e => e.id == model.pheno).head).models(model).base.local.get / s"${baseString}.samples.available.txt")
      },
      samplesAvailableLog = model.design match {
        case "strat" => store(dirTree.analysisPhenoMap(projectConfig.Phenos.filter(e => e.id == model.pheno).head).models(model).cohorts(cohort).local.get / s"${baseString}.samples.available.log")
        case _ => store(dirTree.analysisPhenoMap(projectConfig.Phenos.filter(e => e.id == model.pheno).head).models(model).base.local.get / s"${baseString}.samples.available.log")
      }
    )

  }.toMap
