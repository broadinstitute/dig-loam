import ProjectConfig._
import StoreHelpers._
import Stores._
import Fxns._
import DirTree._
import Collections._

final case class Model(
  sampleMap: Store,
  cohortMap: Store,
  cohortMapGoogle: Option[Store],
  phenoPrelim: Store,
  samplesAvailable: Store,
  samplesAvailableLog: Store,
  pcaBase: Path,
  pcaScores: Store, 
  pcaEigenVecs: Store, 
  pcaLoadings: Store, 
  pcaEigenVals: Store, 
  pcaPve: Store, 
  pcaMeansd: Store, 
  outliers: Store, 
  pcaLog: Store,
  pheno: Store,
  phenoGoogle: Option[Store],
  pedEpacts: Option[Store],
  pcsInclude: Store,
  pcsIncludeGoogle: Option[Store],
  filters: Store,
  filtersGoogle: Option[Store],
  cohortFilters: Option[Store],
  cohortFiltersGoogle: Option[Store],
  knockoutFilters: Option[Store],
  knockoutFiltersGoogle: Option[Store],
  masks: Store,
  masksGoogle: Option[Store],
  variantsStats: Store,
  variantsStatsGoogle: Option[Store],
  variantsStatsHt: Option[Store],
  variantsStatsHtGoogle: Option[Store],
  variantsStatsHailLog: Store,
  variantsStatsHailLogGoogle: Option[Store],
  cohortVariantsStats: Option[Map[ConfigCohort, Store]],
  cohortVariantsStatsGoogle: Option[Map[ConfigCohort, Store]],
  cohortVariantsStatsHt: Option[Map[ConfigCohort, Store]],
  cohortVariantsStatsHtGoogle: Option[Map[ConfigCohort, Store]],
  cohortVariantsStatsHailLog: Option[Map[ConfigCohort, Store]],
  cohortVariantsStatsHailLogGoogle: Option[Map[ConfigCohort, Store]],
  variantFilterTable: Store,
  variantFilterTableGoogle: Option[Store],
  variantFilterHailTable: Option[Store],
  variantFilterHailTableGoogle: Option[Store],
  variantFilterHtCheckpoint: Option[Store],
  variantFilterHtCheckpointGoogle: Option[Store],
  variantFilterHailLog: Store,
  variantFilterHailLogGoogle: Option[Store],
  groupFile: Option[Store],
  groupFileGoogle: Option[Store],
  groupFileHailLog: Option[Store],
  groupFileHailLogGoogle: Option[Store],
  maskedGroupFile: Option[Map[MaskFilter, Store]],
  maskedGroupFileGoogle: Option[Map[MaskFilter, Store]],
  vcf: Option[MultiPathVcf],
  vcfHailLog: Option[Store],
  vcfHailLogGoogle: Option[Store]
)

val modelStores = (
  (for {
    x <- modelCohorts
  } yield {
    (x.model, x.cohorts, None)
  }) ++
  (for {
    x <- modelMetaCohorts
  } yield {
    (x.model, x.cohorts, Some(x.meta))
  })).map { sm =>

  val model = sm._1
  val cohorts = sm._2
  val meta: Option[ConfigMeta] = sm._3

  val array = projectConfig.Arrays.filter(e => e.id == cohorts.head.array).head

  val baseString = meta match {
    case Some(s) =>
      model.design match {
        case "full" => s"${projectConfig.projectId}.${model.id}.${meta.get.id}"
        case "strat" => s"${projectConfig.projectId}.${model.id}.${meta.get.id}.${cohorts.head.id}"
      }
    case None =>
      model.design match {
        case "full" => s"${projectConfig.projectId}.${model.id}"
        case "strat" => s"${projectConfig.projectId}.${model.id}.${cohorts.head.id}"
      }
  }

  val local_dir = model.design match {
      case "full" => dirTree.analysisPhenoMap(projectConfig.Phenos.filter(e => e.id == model.pheno).head).models(model).base.local.get
      case "strat" => dirTree.analysisPhenoMap(projectConfig.Phenos.filter(e => e.id == model.pheno).head).models(model).cohorts(cohorts.head).local.get
  }

  val cloud_dir = (model.design, projectConfig.hailCloud) match {
      case ("full", true) => Some(dirTree.analysisPhenoMap(projectConfig.Phenos.filter(e => e.id == model.pheno).head).models(model).base.google.get)
      case ("strat", true) => Some(dirTree.analysisPhenoMap(projectConfig.Phenos.filter(e => e.id == model.pheno).head).models(model).cohorts(cohorts.head).google.get)
      case _ => None
  }

  val vcf = nonHailTests.contains(model.test) match {

    case true =>

      (model.knockoutFilters, array.exportCleanVcf) match {

        case (Some(_), _) | (_, false) =>

          Some(MultiPathVcf(
            base = MultiPath(
              local = Some(local_dir / baseString),
              google = projectConfig.hailCloud match { case true => Some(cloud_dir.get / baseString); case false => None }
            ),
            data = MultiStore(
              local = Some(store(local_dir / s"${baseString}.vcf.bgz")),
              google = projectConfig.hailCloud match { case true => Some(store(cloud_dir.get / s"${baseString}.vcf.bgz")); case false => None }
            ),
            tbi = MultiStore(local = Some(store(local_dir / s"${baseString}.vcf.bgz.tbi")), google = None)
          ))

        case _ => None

      }

    case _ => None

  }

  val vcfHailLog = nonHailTests.contains(model.test) match {

    case true =>

      (model.knockoutFilters, array.exportCleanVcf, projectConfig.hailCloud) match {

        case (Some(_), _, false) | (_, false, false) =>  Some(store(local_dir / s"${baseString}.vcf.hail.log"))

        case _ => None

      }

    case false => None

  }

  val vcfHailLogGoogle = nonHailTests.contains(model.test) match {

    case true =>

      (model.knockoutFilters, array.exportCleanVcf, projectConfig.hailCloud) match {

        case (Some(_), _, true) | (_, false, true) =>  Some(store(cloud_dir.get / s"${baseString}.vcf.hail.log"))

        case _ => None

      }

    case false => None

  }

  val cohortFilters = model.design match {
    case "full" => Some(store(local_dir / s"${baseString}.variant.cohortfilters.txt"))
    case _ => None
  }

  val cohortFiltersGoogle = (projectConfig.hailCloud, model.design) match {
    case (true, "full") => Some(store(cloud_dir.get / s"${baseString}.variant.cohortfilters.txt"))
    case _ => None
  }

  val knockoutFilters = model.design match {
    case "full" => Some(store(local_dir / s"${baseString}.variant.knockoutfilters.txt"))
    case _ => None
  }

  val knockoutFiltersGoogle = (projectConfig.hailCloud, model.design) match {
    case (true, "full") => Some(store(cloud_dir.get / s"${baseString}.variant.knockoutfilters.txt"))
    case _ => None
  }

  val cohortVariantsStats = (model.design, model.filterCohorts.size) match {
    case ("full", n) if n > 0 => Some(cohorts.filter(e => model.filterCohorts.contains(e.id)).map { cohort => cohort -> store(local_dir / s"${baseString}.${cohort.id}.variant.stats.tsv.bgz") }.toMap)
    case _ => None
  }

  val cohortVariantsStatsGoogle = (model.design, model.filterCohorts.size) match {
    case ("full", n) if n > 0 => projectConfig.hailCloud match { case true => Some(cohorts.filter(e => model.filterCohorts.contains(e.id)).map { cohort => cohort -> store(cloud_dir.get / s"${baseString}.${cohort.id}.variant.stats.tsv.bgz") }.toMap); case false => None }
    case _ => None
  }

  val cohortVariantsStatsHt = (model.design, model.filterCohorts.size) match {
    case ("full", n) if n > 0 => Some(cohorts.filter(e => model.filterCohorts.contains(e.id)).map { cohort => cohort -> store(local_dir / s"${baseString}.${cohort.id}.variant.stats.ht") }.toMap)
    case _ => None
  }

  val cohortVariantsStatsHtGoogle = (model.design, model.filterCohorts.size) match {
    case ("full", n) if n > 0 => projectConfig.hailCloud match { case true => Some(cohorts.filter(e => model.filterCohorts.contains(e.id)).map { cohort => cohort -> store(cloud_dir.get / s"${baseString}.${cohort.id}.variant.stats.ht") }.toMap); case false => None }
    case _ => None
  }

  val cohortVariantsStatsHailLog = (model.design, model.filterCohorts.size) match {
    case ("full", n) if n > 0 => Some(cohorts.filter(e => model.filterCohorts.contains(e.id)).map { cohort => cohort -> store(local_dir / s"${baseString}.${cohort.id}.variant.stats.hail.log") }.toMap)
    case _ => None
  }

  val cohortVariantsStatsHailLogGoogle = (model.design, model.filterCohorts.size) match {
    case ("full", n) if n > 0 => projectConfig.hailCloud match { case true => Some(cohorts.filter(e => model.filterCohorts.contains(e.id)).map { cohort => cohort -> store(cloud_dir.get / s"${baseString}.${cohort.id}.variant.stats.hail.log") }.toMap); case false => None }
    case _ => None
  }

  val maskedGroupFile = model.masks match {
    case Some(s) =>
      model.masks.get.size match {
        case n if n > 0 => Some(model.masks.get.map { mask => mask -> store(local_dir / s"${baseString}.variant.groupfile.${mask.id}.tsv") }.toMap)
        case _ => None
      }
    case None => None
  }

  val maskedGroupFileGoogle = model.masks match {
    case Some(s) =>
      model.masks.get.size match {
        case n if n > 0 => projectConfig.hailCloud match { case true => Some(model.masks.get.map { mask => mask -> store(cloud_dir.get / s"${baseString}.variant.groupfile.${mask.id}.tsv") }.toMap); case false => None }
        case _ => None
      }
    case None => None
  }

  sm -> Model(
    sampleMap = store(local_dir / s"${baseString}.sample.map.tsv"),
    cohortMap = store(local_dir / s"${baseString}.cohort.map.tsv"),
    cohortMapGoogle = projectConfig.hailCloud match { case true => Some(store(cloud_dir.get / s"${baseString}.cohort.map.tsv")); case false => None },
    phenoPrelim = store(local_dir / s"${baseString}.pheno.prelim.tsv"),
    samplesAvailable = store(local_dir / s"${baseString}.samples.available.txt"),
    samplesAvailableLog = store(local_dir / s"${baseString}.samples.available.log"),
    pcaBase = local_dir / s"${baseString}.pca",
    pcaScores = store(local_dir / s"${baseString}.pca.scores.tsv"),
    pcaEigenVecs = store(local_dir / s"${baseString}.pca.eigenvecs.tsv"),
    pcaLoadings = store(local_dir / s"${baseString}.pca.loadings.tsv"),
    pcaEigenVals = store(local_dir / s"${baseString}.pca.eigenvals.txt"),
    pcaPve = store(local_dir / s"${baseString}.pca.pve.txt"),
    pcaMeansd = store(local_dir / s"${baseString}.pca.meansd.tsv"),
    outliers = store(local_dir / s"${baseString}.pca.outliers.txt"),
    pcaLog = store(local_dir / s"${baseString}.pca.log"),
    pheno = store(local_dir / s"${baseString}.pheno.tsv"),
    phenoGoogle = projectConfig.hailCloud match { case true => Some(store(cloud_dir.get / s"${baseString}.pheno.tsv")); case false => None },
    pedEpacts = model.assocPlatform match { case "epacts" => Some(store(local_dir / s"${baseString}.epacts.ped")); case _ => None },
    pcsInclude = store(local_dir / s"${baseString}.pcs.include.txt"),
    pcsIncludeGoogle = projectConfig.hailCloud match { case true => Some(store(cloud_dir.get / s"${baseString}.pcs.include.txt")); case false => None },
    filters = store(local_dir / s"${baseString}.variant.filters.txt"),
    filtersGoogle = projectConfig.hailCloud match { case true => Some(store(cloud_dir.get / s"${baseString}.variant.filters.txt")); case false => None },
    cohortFilters = cohortFilters,
    cohortFiltersGoogle = cohortFiltersGoogle,
    knockoutFilters = knockoutFilters,
    knockoutFiltersGoogle = knockoutFiltersGoogle,
    masks = store(local_dir / s"${baseString}.variant.masks.txt"),
    masksGoogle = projectConfig.hailCloud match { case true => Some(store(cloud_dir.get / s"${baseString}.variant.masks.txt")); case false => None },
    variantsStats = store(local_dir / s"${baseString}.variant.stats.tsv.bgz"),
    variantsStatsGoogle = projectConfig.hailCloud match { case true => Some(store(cloud_dir.get / s"${baseString}.variant.stats.tsv.bgz")); case false => None },
    variantsStatsHt = projectConfig.hailCloud match { case false => Some(store(local_dir / s"${baseString}.variant.stats.ht")); case true => None },
    variantsStatsHtGoogle = projectConfig.hailCloud match { case true => Some(store(cloud_dir.get / s"${baseString}.variant.stats.ht")); case false => None },
    cohortVariantsStats = cohortVariantsStats,
    cohortVariantsStatsGoogle = cohortVariantsStatsGoogle,
    cohortVariantsStatsHt = cohortVariantsStatsHt,
    cohortVariantsStatsHtGoogle = cohortVariantsStatsHtGoogle,
    variantsStatsHailLog = store(local_dir / s"${baseString}.variant.stats.hail.log"),
    variantsStatsHailLogGoogle = projectConfig.hailCloud match { case true => Some(store(cloud_dir.get / s"${baseString}.variant.stats.hail.log")); case false => None },
    cohortVariantsStatsHailLog = cohortVariantsStatsHailLog,
    cohortVariantsStatsHailLogGoogle = cohortVariantsStatsHailLogGoogle,
    variantFilterTable = store(local_dir / s"${baseString}.variant.filters.tsv.bgz"),
    variantFilterTableGoogle = projectConfig.hailCloud match { case true => Some(store(cloud_dir.get / s"${baseString}.variant.filters.tsv.bgz")); case false => None },
    variantFilterHtCheckpoint = projectConfig.hailCloud match { case false => Some(store(local_dir / s"${baseString}.variant.filters.ht.checkpoint")); case true => None },
    variantFilterHtCheckpointGoogle = projectConfig.hailCloud match { case true => Some(store(cloud_dir.get / s"${baseString}.variant.filters.ht.checkpoint")); case false => None },
    variantFilterHailTable = projectConfig.hailCloud match { case false => Some(store(local_dir / s"${baseString}.variant.filters.ht")); case true => None },
    variantFilterHailTableGoogle = projectConfig.hailCloud match { case true => Some(store(cloud_dir.get / s"${baseString}.variant.filters.ht")); case false => None },
    variantFilterHailLog = store(local_dir / s"${baseString}.variant.filters.hail.log"),
    variantFilterHailLogGoogle = projectConfig.hailCloud match { case true => Some(store(cloud_dir.get / s"${baseString}.variant.filters.hail.log")); case false => None },
    groupFile = groupTests.contains(model.test) match { case true => Some(store(local_dir / s"${baseString}.variant.groupfile.txt")); case false => None },
	groupFileGoogle = (groupTests.contains(model.test) && projectConfig.hailCloud) match { case true => Some(store(cloud_dir.get / s"${baseString}.variant.groupfile.txt")); case false => None },
    groupFileHailLog = groupTests.contains(model.test) match { case true => Some(store(local_dir / s"${baseString}.variant.groupfile.hail.log")); case false => None },
    groupFileHailLogGoogle = (groupTests.contains(model.test) && projectConfig.hailCloud) match { case true => Some(store(cloud_dir.get / s"${baseString}.variant.groupfile.hail.log")); case false => None },
    maskedGroupFile = maskedGroupFile,
    maskedGroupFileGoogle = maskedGroupFileGoogle,
    vcf = vcf,
    vcfHailLog = vcfHailLog,
    vcfHailLogGoogle = vcfHailLogGoogle
  )

}.toMap
