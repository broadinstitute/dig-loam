import ProjectConfig._
import StoreHelpers._
import Stores._
import Fxns._
import DirTree._
import Collections._

final case class ModelBaseCohortStore(
  base: MultiStore,
  cohorts: Map[ConfigCohort, MultiStore])

final case class ModelBaseMaskStore(
  base: MultiStore,
  masks: Map[MaskFilter, MultiStore])

final case class ModelGroup(
  results: Store,
  groupFile: Store)

final case class ModelResult(
  results: MultiStore,
  filteredResults: Option[Store],
  mergeList: Option[Store],
  groups: Map[String, ModelGroup]
)

final case class ModelTest(
  base: Map[String, ModelResult],
  masks: Map[String, Map[MaskFilter, ModelResult]])

final case class Model(
  sampleMap: Store,
  cohortMap: MultiStore,
  phenoPrelim: Store,
  samplesAvailable: Store,
  samplesAvailableLog: Store,
  pcaBase: Path,
  pcaScores: Store, 
  pcaEigenVecs: Store, 
  pcaLoadings: Store, 
  pcaEigenVals: Store, 
  pcaPve: Store, 
  pcaMeansd: Store, 
  outliers: Store, 
  pcaLog: Store,
  pheno: MultiStore,
  pedEpacts: Option[Store],
  modelVarsEpacts: Option[Store],
  pcsInclude: MultiStore,
  filters: MultiStore,
  cohortFilters: MultiStore,
  knockoutFilters: MultiStore,
  masks: MultiStore,
  variantsStats: ModelBaseCohortStore,
  variantsStatsHt: ModelBaseCohortStore,
  variantsStatsHailLog: ModelBaseCohortStore,
  variantFilterTable: MultiStore,
  variantFilterHailTable: MultiStore,
  variantFilterHtCheckpoint: MultiStore,
  variantFilterHailLog: MultiStore,
  groupFile: Option[ModelBaseMaskStore],
  groupFileHailLog: Option[MultiStore],
  vcf: Option[MultiPathVcf],
  vcfHailLog: MultiStore,
  assoc: ModelTest
)

val modelStores = (
  (for {
    x <- modelCohorts
  } yield {
    (x.model, x.cohorts, None)
  }) ++
  (for {
    x <- modelMetaCohorts
  } yield {
    (x.model, x.cohorts, Some(x.meta))
  })).map { sm =>

  val model = sm._1
  val cohorts = sm._2
  val meta: Option[ConfigMeta] = sm._3

  val array = projectConfig.Arrays.filter(e => e.id == cohorts.head.array).head

  val nullString = meta match {
    case Some(s) => s"${projectConfig.projectId}.${model.id}.${meta.get.id}"
    case None => s"${projectConfig.projectId}.${model.id}"
  }

  val baseString = model.design match {
    case "full" => s"${nullString}"
    case "strat" => s"${nullString}.${cohorts.head.id}"
  }

  val local_dir = dirTree.analysisPhenoMap(projectConfig.Phenos.filter(e => e.id == model.pheno).head).modelsMap(model).base.local.get

  val cloud_dir = projectConfig.hailCloud match {
      case true => Some(dirTree.analysisPhenoMap(projectConfig.Phenos.filter(e => e.id == model.pheno).head).modelsMap(model).base.google.get)
      case false => None
  }

  val groupFile = groupTests.intersect(model.tests).size match {
    case n if n > 0 =>
      Some(ModelBaseMaskStore(
        base = MultiStore(
          local = Some(store(local_dir / s"${baseString}.variant.groupfile.tsv")),
          google = projectConfig.hailCloud match { case true => Some(store(cloud_dir.get / s"${baseString}.variant.groupfile.tsv")); case false => None }
        ),
        masks = model.masks match {
          case Some(_) =>
            model.masks.get.size match {
              case n if n > 0 =>
                model.masks.get.map { mask =>
                  mask -> MultiStore(
                    local = Some(store(local_dir / s"${baseString}.variant.groupfile.${mask.id}.tsv")),
                    google = projectConfig.hailCloud match { case true => Some(store(cloud_dir.get / s"${baseString}.variant.groupfile.${mask.id}.tsv")); case false => None }
                  )
                }.toMap
              case _ => Map[MaskFilter, MultiStore]()
            }
          case None => Map[MaskFilter, MultiStore]()
        }
      ))
    case _ => None
  }

  groupFile match {
    case Some(_) =>
      try {
        val gFile = checkPath(s"""${groupFile.get.base.local.get.toString.split("@")(1)}""")
        val l = fileToList(gFile).map(e => e.split("\t")(0))
        for {
          test <- model.tests
          group <- l
        } yield {
            dirTree.analysisPhenoMap(projectConfig.Phenos.filter(e => e.id == model.pheno).head).modelsMap(model).testsMap(test).groupsMap(group) = appendSubDir(dirTree.analysisPhenoMap(projectConfig.Phenos.filter(e => e.id == model.pheno).head).modelsMap(model).testsMap(test).groups, group)
        }
      }
      catch {
        case x: CfgException =>
          println(s"""skipping split assoc test by group due to missing group file: ${groupFile.get.base.local.get.toString.split("@")(1)}""")
      }
    case _ => ()
  }
                
  sm -> Model(
    sampleMap = store(local_dir / s"${baseString}.sample.map.tsv"),
    cohortMap = MultiStore(
      local = Some(store(local_dir / s"${baseString}.cohort.map.tsv")),
      google = projectConfig.hailCloud match { case true => Some(store(cloud_dir.get / s"${baseString}.cohort.map.tsv")); case false => None }
    ),
    phenoPrelim = store(local_dir / s"${baseString}.pheno.prelim.tsv"),
    samplesAvailable = store(local_dir / s"${baseString}.samples.available.txt"),
    samplesAvailableLog = store(local_dir / s"${baseString}.samples.available.log"),
    pcaBase = local_dir / s"${baseString}.pca",
    pcaScores = store(local_dir / s"${baseString}.pca.scores.tsv"),
    pcaEigenVecs = store(local_dir / s"${baseString}.pca.eigenvecs.tsv"),
    pcaLoadings = store(local_dir / s"${baseString}.pca.loadings.tsv"),
    pcaEigenVals = store(local_dir / s"${baseString}.pca.eigenvals.txt"),
    pcaPve = store(local_dir / s"${baseString}.pca.pve.txt"),
    pcaMeansd = store(local_dir / s"${baseString}.pca.meansd.tsv"),
    outliers = store(local_dir / s"${baseString}.pca.outliers.txt"),
    pcaLog = store(local_dir / s"${baseString}.pca.log"),
    pheno = MultiStore(
      local = Some(store(local_dir / s"${baseString}.pheno.tsv")),
      google = projectConfig.hailCloud match { case true => Some(store(cloud_dir.get / s"${baseString}.pheno.tsv")); case false => None }
    ),
    pedEpacts = model.assocPlatforms.contains("epacts") match { case true => Some(store(local_dir / s"${baseString}.epacts.ped")); case false => None },
    modelVarsEpacts = model.assocPlatforms.contains("epacts") match { case true => Some(store(local_dir / s"${baseString}.epacts.model.vars")); case false => None },
    pcsInclude = MultiStore(
      local = Some(store(local_dir / s"${baseString}.pcs.include.txt")),
      google = projectConfig.hailCloud match { case true => Some(store(cloud_dir.get / s"${baseString}.pcs.include.txt")); case false => None }
    ),
    filters = MultiStore(
      local = Some(store(local_dir / s"${baseString}.variant.filters.txt")),
      google = projectConfig.hailCloud match { case true => Some(store(cloud_dir.get / s"${baseString}.variant.filters.txt")); case false => None }
    ),
    cohortFilters = MultiStore(
      local = model.design match { case "full" => Some(store(local_dir / s"${baseString}.variant.cohortfilters.txt")); case _ => None },
      google = (projectConfig.hailCloud, model.design) match { case (true, "full") => Some(store(cloud_dir.get / s"${baseString}.variant.cohortfilters.txt")); case _ => None }
    ),
    knockoutFilters = MultiStore(
      local = model.design match { case "full" => Some(store(local_dir / s"${baseString}.variant.knockoutfilters.txt")); case _ => None },
      google = (projectConfig.hailCloud, model.design) match { case (true, "full") => Some(store(cloud_dir.get / s"${baseString}.variant.knockoutfilters.txt")); case _ => None }
    ),
    masks = MultiStore(
      local = Some(store(local_dir / s"${baseString}.variant.masks.txt")),
      google = projectConfig.hailCloud match { case true => Some(store(cloud_dir.get / s"${baseString}.variant.masks.txt")); case false => None }
    ),
    variantsStats = ModelBaseCohortStore(
      base = model.design match {
        case "full" => 
          MultiStore(
            local = Some(store(local_dir / s"${baseString}.variant.stats.tsv.bgz")),
            google = projectConfig.hailCloud match { case true => Some(store(cloud_dir.get / s"${baseString}.variant.stats.tsv.bgz")); case false => None }
          )
        case "strat" =>
          MultiStore(
            local = Some(store(local_dir / s"${nullString}.${cohorts.head.id}.variant.stats.tsv.bgz")),
            google = projectConfig.hailCloud match { case true => Some(store(cloud_dir.get / s"${nullString}.${cohorts.head.id}.variant.stats.tsv.bgz")); case false => None }
          )
      },
      cohorts = (model.design, model.filterCohorts.size) match {
        case ("full", n) if n > 0 =>
          cohorts.filter(e => model.filterCohorts.contains(e.id)).map { cohort =>
            cohort -> MultiStore(
              local = Some(store(local_dir / s"${nullString}.${cohort.id}.variant.stats.tsv.bgz")),
              google = projectConfig.hailCloud match { case true => Some(store(cloud_dir.get / s"${nullString}.${cohort.id}.variant.stats.tsv.bgz")); case false => None }
            )
          }.toMap
        case _ => Map[ConfigCohort, MultiStore]()
      }
    ),
    variantsStatsHt = ModelBaseCohortStore(
      base = model.design match {
        case "full" => 
          MultiStore(
            local = Some(store(local_dir / s"${baseString}.variant.stats.ht")),
            google = projectConfig.hailCloud match { case true => Some(store(cloud_dir.get / s"${baseString}.variant.stats.ht")); case false => None }
          )
        case "strat" => 
          MultiStore(
            local = Some(store(local_dir / s"${nullString}.${cohorts.head.id}.variant.stats.ht")),
            google = projectConfig.hailCloud match { case true => Some(store(cloud_dir.get / s"${nullString}.${cohorts.head.id}.variant.stats.ht")); case false => None }
          )
      },
      cohorts = (model.design, model.filterCohorts.size) match {
        case ("full", n) if n > 0 =>
          cohorts.filter(e => model.filterCohorts.contains(e.id)).map { cohort =>
            cohort -> MultiStore(
              local = Some(store(local_dir / s"${nullString}.${cohort.id}.variant.stats.ht")),
              google = projectConfig.hailCloud match { case true => Some(store(cloud_dir.get / s"${nullString}.${cohort.id}.variant.stats.ht")); case false => None }
            )
          }.toMap
        case _ => Map[ConfigCohort, MultiStore]()
      }
    ),
    variantsStatsHailLog = ModelBaseCohortStore(
      base = model.design match {
        case "full" => 
          MultiStore(
            local = Some(store(local_dir / s"${baseString}.variant.stats.hail.log")),
            google = projectConfig.hailCloud match { case true => Some(store(cloud_dir.get / s"${baseString}.variant.stats.hail.log")); case false => None }
          )
        case "strat" => 
          MultiStore(
            local = Some(store(local_dir / s"${baseString}.variant.stats.hail.log")),
            google = projectConfig.hailCloud match { case true => Some(store(cloud_dir.get / s"${nullString}.${cohorts.head.id}.variant.stats.hail.log")); case false => None }
          )
      },
      cohorts = (model.design, model.filterCohorts.size) match {
        case ("full", n) if n > 0 =>
          cohorts.filter(e => model.filterCohorts.contains(e.id)).map { cohort =>
            cohort -> MultiStore(
              local = Some(store(local_dir / s"${nullString}.${cohort.id}.variant.stats.hail.log")),
              google = projectConfig.hailCloud match { case true => Some(store(cloud_dir.get / s"${nullString}.${cohort.id}.variant.stats.hail.log")); case false => None }
            )
          }.toMap
        case _ => Map[ConfigCohort, MultiStore]()
      }
    ),
    variantFilterTable = MultiStore(
      local = Some(store(local_dir / s"${baseString}.variant.filters.tsv.bgz")),
      google = projectConfig.hailCloud match { case true => Some(store(cloud_dir.get / s"${baseString}.variant.filters.tsv.bgz")); case false => None }
    ),
    variantFilterHailTable = MultiStore(
      local = projectConfig.hailCloud match { case false => Some(store(local_dir / s"${baseString}.variant.filters.ht")); case true => None },
      google = projectConfig.hailCloud match { case true => Some(store(cloud_dir.get / s"${baseString}.variant.filters.ht")); case false => None }
    ),
    variantFilterHtCheckpoint = MultiStore(
      local = projectConfig.hailCloud match { case false => Some(store(local_dir / s"${baseString}.variant.filters.ht.checkpoint")); case true => None },
      google = projectConfig.hailCloud match { case true => Some(store(cloud_dir.get / s"${baseString}.variant.filters.ht.checkpoint")); case false => None }
    ),
    variantFilterHailLog = MultiStore(
      local = Some(store(local_dir / s"${baseString}.variant.filters.hail.log")),
      google = projectConfig.hailCloud match { case true => Some(store(cloud_dir.get / s"${baseString}.variant.filters.hail.log")); case false => None }
    ),
    groupFile = groupFile,
    groupFileHailLog = groupTests.intersect(model.tests).size match {
      case n if n > 0 =>
        Some(MultiStore(
          local = Some(store(local_dir / s"${baseString}.variant.groupfile.hail.log")),
          google = projectConfig.hailCloud match { case true => Some(store(cloud_dir.get / s"${baseString}.variant.groupfile.hail.log")); case false => None }
        ))
      case _ => None
    },
    vcf = nonHailTests.intersect(model.tests).size match {
      case n if n > 0 =>
        (model.knockoutFilters, array.exportCleanVcf) match {
          case (Some(_), _) | (_, false) =>
            Some(MultiPathVcf(
              base = MultiPath(
                local = Some(local_dir / baseString),
                google = projectConfig.hailCloud match { case true => Some(cloud_dir.get / baseString); case false => None }
              ),
              data = MultiStore(
                local = Some(store(local_dir / s"${baseString}.vcf.bgz")),
                google = projectConfig.hailCloud match { case true => Some(store(cloud_dir.get / s"${baseString}.vcf.bgz")); case false => None }
              ),
              tbi = MultiStore(local = Some(store(local_dir / s"${baseString}.vcf.bgz.tbi")), google = None)
            ))
          case _ => None
        }
      case _ => None
    },
    vcfHailLog = MultiStore(
      local = nonHailTests.intersect(model.tests).size match { case n if n > 0 => (model.knockoutFilters, array.exportCleanVcf, projectConfig.hailCloud) match { case (Some(_), _, false) | (_, false, false) =>  Some(store(local_dir / s"${baseString}.vcf.hail.log")); case _ => None }; case _ => None },
      google = nonHailTests.intersect(model.tests).size match { case n if n > 0 => (model.knockoutFilters, array.exportCleanVcf, projectConfig.hailCloud) match { case (Some(_), _, true) | (_, false, true) =>  Some(store(cloud_dir.get / s"${baseString}.vcf.hail.log")); case _ => None }; case _ => None }
    ),
    assoc = ModelTest(
      base = model.tests.map { test =>
        test -> ModelResult(
          results = MultiStore(
            local = Some(store(local_dir / s"${baseString}.${test}.results.tsv.bgz")),
            google = projectConfig.hailCloud match { case true => Some(store(cloud_dir.get / s"${baseString}.${test}.results.tsv.bgz")); case false => None }
          ),
          filteredResults = groupTests.contains(test) match {
            case false => Some(store(local_dir / s"${baseString}.${test}.results.filtered.tsv.bgz"))
            case true => None
          },
          mergeList = groupTests.contains(test) match {
            case true => Some(store(local_dir / s"${baseString}.${test}.results.mergelist.txt"))
            case false => None
          },
          groups = groupFile match {
            case Some(_) =>
              dirTree.analysisPhenoMap(projectConfig.Phenos.filter(e => e.id == model.pheno).head).modelsMap(model).testsMap(test).groupsMap.keys.map { group =>
                group -> ModelGroup(
                  results = store(dirTree.analysisPhenoMap(projectConfig.Phenos.filter(e => e.id == model.pheno).head).modelsMap(model).testsMap(test).groupsMap(group).local.get / s"${baseString}.${test}.${group}.results.tsv.bgz"),
                  groupFile = store(dirTree.analysisPhenoMap(projectConfig.Phenos.filter(e => e.id == model.pheno).head).modelsMap(model).testsMap(test).groupsMap(group).local.get / s"${baseString}.${test}.${group}.groupfile.tsv")
                )
              }.toMap
            case None => Map[String, ModelGroup]()
          }
        )
      }.toMap,
      masks = model.masks match {
        case Some(_) =>
          model.masks.get.size match {
            case n if n > 0 =>
              model.tests.map { test =>
                test ->
                  model.masks.get.map { mask =>
                    mask -> ModelResult(
                      results = MultiStore(
                        local = Some(store(local_dir / s"${baseString}.${test}.${mask.id}.results.tsv.bgz")),
                        google = projectConfig.hailCloud match { case true => Some(store(cloud_dir.get / s"${baseString}.${test}.${mask.id}.results.tsv.bgz")); case false => None }
                      ),
                      filteredResults = groupTests.contains(test) match {
                        case false => Some(store(local_dir / s"${baseString}.${test}.${mask.id}.results.filtered.tsv.bgz"))
                        case true => None
                      },
                      mergeList = groupTests.contains(test) match {
                        case true => Some(store(local_dir / s"${baseString}.${test}.${mask.id}.results.mergelist.txt"))
                        case false => None
                      },
                      groups = groupFile match {
                        case Some(_) =>
                          groupFile.get.masks.size match {
                            case n if n > 0 =>
                              try {
                                val gFile = checkPath(s"""${groupFile.get.masks(mask).local.get.toString.split("@")(1)}""")
                                val l = fileToList(gFile).map(e => e.split("\t")(0))
                                l.map { group =>
                                  group -> ModelGroup(
                                    results = store(dirTree.analysisPhenoMap(projectConfig.Phenos.filter(e => e.id == model.pheno).head).modelsMap(model).testsMap(test).groupsMap(group).local.get / s"${baseString}.${test}.${mask.id}.${group}.results.tsv.bgz"),
                                    groupFile = store(dirTree.analysisPhenoMap(projectConfig.Phenos.filter(e => e.id == model.pheno).head).modelsMap(model).testsMap(test).groupsMap(group).local.get / s"${baseString}.${test}.${mask.id}.${group}.groupfile.tsv")
                                  )
                                }.toMap
                              } 
                              catch {
                                case x: CfgException =>
                                  println(s"""skipping split assoc test by group due to missing group file: ${groupFile.get.masks(mask).local.get.toString.split("@")(1)}""")
                                  Map[String, ModelGroup]()
                              }
                            case _ => Map[String, ModelGroup]()
                          }
                        case None => Map[String, ModelGroup]()
                      }
                    )
                  }.toMap
              }.toMap
            case _ => Map[String, Map[MaskFilter, ModelResult]]()
          }
        case None => Map[String, Map[MaskFilter, ModelResult]]()
      }
    )
  )

}.toMap

//  //val groupResultsSplit = model.design match {
//  //  case "full" =>
//  //    model.groupFile match {
//  //      case Some(_) =>
//  //        val groups = fileToList(model.groupFile.get).map(e => e.split("\t")(0))
//  //        groups.map { group =>
//  //          group -> store(dirTree.analysisPhenoMap(projectConfig.Phenos.filter(e => e.id == model.pheno).head).models(model).base_tests(test).jobs(group).local.get / s"${group}.${model.test}.results.tsv")
//  //        }.toMap
//  //      case _ => Map[String, Store]()
//  //    }
//  //  case "strat" => Map[String, Store]()
//  //}
//  //
//  //val groupFilesSplit = model.design match {
//  //  case "full" =>
//  //    model.groupFile match {
//  //      case Some(_) =>
//  //        val groups = fileToList(model.groupFile.get).map(e => e.split("\t")(0))
//  //        groups.map { group =>
//  //          group -> store(dirTree.analysisPhenoMap(projectConfig.Phenos.filter(e => e.id == model.pheno).head).models(model).base_tests.get.jobs(group).local.get / s"${group}.${model.test}.groupfile.tsv")
//  //        }.toMap
//  //      case _ => Map[String, Store]()
//  //    }
//  //  case "strat" => Map[String, Store]()
//  //}
//
//  //val maskedGroupResultsSplit = model.design match {
//  //  case "full" =>
//  //    model.masks match {
//  //      case Some(_) =>
//  //        model.masks.get.map { mask =>
//  //          val x = mask.groupFile match {
//  //            case Some(_) =>
//  //              val groups = fileToList(mask.groupFile.get).map(e => e.split("\t")(0))
//  //              groups.map { group =>
//  //                group -> 
//  //                  println(s"${group}")
//  //                  //store(dirTree.analysisPhenoMap(projectConfig.Phenos.filter(e => e.id == model.pheno).head).models(model).base_tests.get.jobs(group).local.get / s"${group}.${model.test}.${mask.id}.results.tsv")
//  //              }.toMap
//  //            case None => Map[MaskFilter, Map[String, Store]]()
//  //          }
//  //          mask -> x
//  //        }
//  //      case None => Map[MaskFilter, Map[String, Store]]()
//  //    }
//  //  case "strat" => Map[MaskFilter, Map[String, Store]]()
//  //}
//
//  //val maskedGroupFilesSplit = model.design match {
//  //  case "full" =>
//  //    (model.groupFile, model.masks) match {
//  //      case (Some(_), Some(_)) =>
//  //        val groups = fileToList(model.groupFile.get).map(e => e.split("\t")(0))
//  //        groups.map { group =>
//  //          group -> model.masks.get.map { mask =>
//  //            mask -> store(dirTree.analysisPhenoMap(projectConfig.Phenos.filter(e => e.id == model.pheno).head).models(model).base_tests.get.jobs(group).local.get / s"${group}.${model.test}.${mask.id}.groupfile.tsv")
//  //          }.toMap
//  //        }.toMap
//  //      case _ => Map[String, Map[MaskFilter, Store]]()
//  //    }
//  //  case "strat" => Map[String, Map[MaskFilter, Store]]()
//  //}
//
//  //val maskedResults = model.masks match {
//  //  case Some(s) =>
//  //    model.masks.get.size match {
//  //      case n if n > 0 => model.masks.get.map { mask => mask -> store(local_dir / s"${baseString}.${model.test}.${mask.id}.results.tsv") }.toMap
//  //      case _ => Map[MaskFilter, Store]()
//  //    }
//  //  case None => Map[MaskFilter, Store]()
//  //}
//  //
//  //val maskedResultsMergeList = model.masks match {
//  //  case Some(s) =>
//  //    model.masks.get.size match {
//  //      case n if n > 0 => model.masks.get.map { mask => mask -> store(local_dir / s"${baseString}.${model.test}.${mask.id}.mergelist.txt") }.toMap
//  //      case _ => Map[MaskFilter, Store]()
//  //    }
//  //  case None => Map[MaskFilter, Store]()
//  //}
//  
//  //val cohortGroupResultsSplit = model.design match {
//  //  case "full" => Map[ConfigCohort, Map[String, Store]]()
//  //  case "strat" =>
//  //    model.cohortGroupFiles match {
//  //      case Some(_) =>
//  //          projectConfig.Cohorts.filter(e => model.cohorts.contains(e.id)).map { cohort =>
//  //            model.cohortGroupFiles.get.contains(cohort.id) match {
//  //              case true =>
//  //                val groups = fileToList(model.cohortGroupFiles.get.filter(e => e.cohort == cohort.id).head.groupFile).map(e => e.split("\t")(0))
//  //                cohort -> groups.map { group =>
//  //                  group -> store(dirTree.analysisPhenoMap(projectConfig.Phenos.filter(e => e.id == model.pheno).head).models(model).cohort_tests(cohort).jobs(group).local.get / s"${group}.${model.test}.gz")
//  //                }.toMap
//  //              case false => Map[String, Store]()
//  //            }
//  //         }.toMap
//  //      case _ => Map[ConfigCohort, Map[String, Store]]()
//  //    }
//  //}
//  //
//  //val cohortMaskedGroupResultsSplit = model.design match {
//  //  case "full" => Map[ConfigCohort, Map[String, Map[MaskFilter, Store]]]()
//  //  case "strat" =>
//  //    (model.cohortGroupFiles, model.masks) match {
//  //      case (Some(_), Some(_)) =>
//  //        projectConfig.Cohorts.filter(e => model.cohorts.contains(e.id)).map { cohort =>
//  //          model.cohortGroupFiles.get.contains(cohort.id) match {
//  //            case true =>
//  //              val groups = fileToList(model.cohortGroupFiles.get.filter(e => e.cohort == cohort.id).head.groupFile).map(e => e.split("\t")(0))
//  //              cohort -> groups.map { group =>
//  //                group -> model.masks.get.map { mask =>
//  //                  mask -> store(dirTree.analysisPhenoMap(projectConfig.Phenos.filter(e => e.id == model.pheno).head).models(model).cohort_tests(cohort).jobs(group).local.get / s"${group}.${model.test}.${mask.id}.gz")
//  //                }.toMap
//  //              }.toMap
//  //            case false => Map[String, Map[MaskFilter, Store]]()
//  //          }
//  //        }.toMap
//  //      case _ => Map[ConfigCohort, Map[String, Map[MaskFilter, Store]]]()
//  //    }
//  //}
