import ProjectConfig._
import StoreHelpers._
import Stores._
import Fxns._
import DirTree._
import Collections._

final case class Model(
  samplesMap: Store,
  samplesAvailable: Store,
  samplesAvailableLog: Store)

val modelStores = (
  (for {
    x <- modelCohorts
  } yield {
    (x.model, x.cohort, None)
  }) ++
  (for {
    x <- modelMetaCohorts
  } yield {
    (x.model, x.cohort, Some(x.meta))
  })).map { sm =>

  val model = sm._1
  val cohort = sm._2
  val meta: Option[ConfigMeta] = sm._3

  val baseString = meta match {
    case Some(s) => s"${projectConfig.projectId}.${model.id}.${meta.get.id}.${cohort.id}"
    case None => s"${projectConfig.projectId}.${model.id}.${cohort.id}"
  }

  sm -> Model(
    samplesMap = model.design match {
      case "strat" => store(dirTree.analysisPhenoMap(projectConfig.Phenos.filter(e => e.id == model.pheno).head).models(model).cohorts(cohort).local.get / s"${baseString}.samples.map.tsv")
      case _ => store(dirTree.analysisPhenoMap(projectConfig.Phenos.filter(e => e.id == model.pheno).head).models(model).base.local.get / s"${baseString}.samples.map.tsv")
    },
    samplesAvailable = model.design match {
      case "strat" => store(dirTree.analysisPhenoMap(projectConfig.Phenos.filter(e => e.id == model.pheno).head).models(model).cohorts(cohort).local.get / s"${baseString}.samples.available.txt")
      case _ => store(dirTree.analysisPhenoMap(projectConfig.Phenos.filter(e => e.id == model.pheno).head).models(model).base.local.get / s"${baseString}.samples.available.txt")
    },
    samplesAvailableLog = model.design match {
      case "strat" => store(dirTree.analysisPhenoMap(projectConfig.Phenos.filter(e => e.id == model.pheno).head).models(model).cohorts(cohort).local.get / s"${baseString}.samples.available.log")
      case _ => store(dirTree.analysisPhenoMap(projectConfig.Phenos.filter(e => e.id == model.pheno).head).models(model).base.local.get / s"${baseString}.samples.available.log")
    }
  )

}.toMap
