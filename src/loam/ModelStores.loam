import ProjectConfig._
import StoreHelpers._
import Stores._
import Fxns._
import DirTree._
import Collections._

final case class Model(
  samplesMap: Store,
  phenoPrelim: Store,
  samplesAvailable: Store,
  samplesAvailableLog: Store,
  pcaBase: Path,
  pcaScores: Store, 
  pcaEigenVecs: Store, 
  pcaLoadings: Store, 
  pcaEigenVals: Store, 
  pcaPve: Store, 
  pcaMeansd: Store, 
  outliers: Store, 
  pcaLog: Store,
  pheno: Store,
  phenoGoogle: Option[Store],
  pcsInclude: Store,
  pcsIncludeGoogle: Option[Store])

val modelStores = (
  (for {
    x <- modelCohorts
  } yield {
    (x.model, x.cohorts, None)
  }) ++
  (for {
    x <- modelMetaCohorts
  } yield {
    (x.model, x.cohorts, Some(x.meta))
  })).map { sm =>

  val model = sm._1
  val cohorts = sm._2
  val meta: Option[ConfigMeta] = sm._3

  val baseString = meta match {
    case Some(s) =>
      model.design match {
        case "full" => s"${projectConfig.projectId}.${model.id}.${meta.get.id}"
        case "strat" => s"${projectConfig.projectId}.${model.id}.${meta.get.id}.${cohorts.head.id}"
      }
    case None =>
      model.design match {
        case "full" => s"${projectConfig.projectId}.${model.id}"
        case "strat" => s"${projectConfig.projectId}.${model.id}.${cohorts.head.id}"
      }
  }

  val model_dir = model.design match {
      case "full" => dirTree.analysisPhenoMap(projectConfig.Phenos.filter(e => e.id == model.pheno).head).models(model).base.local.get
      case "strat" => dirTree.analysisPhenoMap(projectConfig.Phenos.filter(e => e.id == model.pheno).head).models(model).cohorts(cohorts.head).local.get
  }

  sm -> Model(
    samplesMap = store(model_dir / s"${baseString}.samples.map.tsv"),
    phenoPrelim = store(model_dir / s"${baseString}.pheno.prelim.tsv"),
    samplesAvailable = store(model_dir / s"${baseString}.samples.available.txt"),
    samplesAvailableLog = store(model_dir / s"${baseString}.samples.available.log"),
    pcaBase = model_dir / s"${baseString}.pca",
    pcaScores = store(model_dir / s"${baseString}.pca.scores.tsv"),
    pcaEigenVecs = store(model_dir / s"${baseString}.pca.eigenvecs.tsv"),
    pcaLoadings = store(model_dir / s"${baseString}.pca.loadings.tsv"),
    pcaEigenVals = store(model_dir / s"${baseString}.pca.eigenvals.txt"),
    pcaPve = store(model_dir / s"${baseString}.pca.pve.txt"),
    pcaMeansd = store(model_dir / s"${baseString}.pca.meansd.tsv"),
    outliers = store(model_dir / s"${baseString}.pca.outliers.txt"),
    pcaLog = store(model_dir / s"${baseString}.pca.log"),
    pheno = store(model_dir / s"${baseString}.pheno.tsv"),
    phenoGoogle = projectConfig.hailCloud match { case true => Some(store(model_dir / s"${baseString}.pheno.tsv")); case false => None },
    pcsInclude = store(model_dir / s"${baseString}.pcs.include.txt"),
    pcsIncludeGoogle = projectConfig.hailCloud match { case true => Some(store(model_dir / s"${baseString}.pcs.include.txt")); case false => None }
  )

}.toMap
