/**
 * Prepare Model Cohorts
 * 
 */
import ProjectConfig._
import ArrayStores._
import ProjectStores._
import SchemaStores._
import MetaStores._
import Fxns._
import Collections._

final case class CfgException(s: String) extends Exception(s)

def PrepareSchema(configSchema: ConfigSchema, configCohorts: Seq[ConfigCohort]): Unit = {

  val array = projectConfig.Arrays.filter(e => e.id == configCohorts.head.array).head
  
  val stratStrings = {
    for {
      cohort <- configCohorts
    } yield {
      var s = "--strat " + cohort.id + " " + cohort.ancestry.mkString(",")
      cohort.stratCol match {
        case Some(a) => s = s + " " + a
        case None => s = s + " " + """"N/A""""
      }
      cohort.stratCodes match {
        case Some(a) => s = s + " " + a.mkString(",")
        case None => s = s + " " + """"N/A""""
      }
      s
    }
  }
  
  drmWith(imageName = s"${utils.image.imgR}") {

    cmd"""${utils.binary.binRscript} --vanilla --verbose
      ${utils.r.rSchemaCohortSamplesAvailable}
      --pheno-in ${projectStores.phenoFile.local.get}
      --fam-in ${arrayStores(array).filteredData.plink.base.local.get}.fam
      --ancestry-in ${projectStores.ancestryInferred.local.get}
      ${stratStrings.mkString(" ")}
      --iid-col ${projectConfig.phenoFileId}
      --samples-exclude-qc ${arrayStores(array).filterQc.samplesExclude.local.get}
      --samples-exclude-postqc ${arrayStores(array).filterPostQc.samplesExclude.local.get}
      --out-id-map ${schemaStores((configSchema, configCohorts)).sampleMap}
      --out-cohorts-map ${schemaStores((configSchema, configCohorts)).cohortMap.local.get}
      --out ${schemaStores((configSchema, configCohorts)).samplesAvailable}
      > ${schemaStores((configSchema, configCohorts)).samplesAvailableLog}"""
      .in(arrayStores(array).filteredData.plink.data.local.get :+ projectStores.phenoFile.local.get :+ projectStores.ancestryInferred.local.get :+ arrayStores(array).filterQc.samplesExclude.local.get :+ arrayStores(array).filterPostQc.samplesExclude.local.get)
      .out(schemaStores((configSchema, configCohorts)).sampleMap, schemaStores((configSchema, configCohorts)).cohortMap.local.get, schemaStores((configSchema, configCohorts)).samplesAvailable, schemaStores((configSchema, configCohorts)).samplesAvailableLog)
      .tag(s"${schemaStores((configSchema, configCohorts)).samplesAvailable}".split("/").last)
  
  }

  val fetMissPhenos = schemaFilterFields.filter(e => e.schema.id == configSchema.id).head.fields.filter(e => e.startsWith("variant_qc.fet_miss")).size match {
    case n if n > 0 => projectConfig.Phenos.filter(e => e.binary && projectConfig.Models.filter(f => f.schema == configSchema.id).map(g => g.pheno).contains(e.id))
    case _ => Seq[ConfigPheno]()
  }
  
  projectConfig.hailCloud match {
  
    case true =>
  
      local {

        googleCopy(schemaStores((configSchema, configCohorts)).cohortMap.local.get, schemaStores((configSchema, configCohorts)).cohortMap.google.get)
      
      }
      
      googleWith(projectConfig.cloudResources.mtCluster) {
      
        hail"""${utils.python.pyHailSchemaVariantStats} --
          --hail-utils ${projectStores.hailUtils.google.get}
          --reference-genome ${projectConfig.referenceGenome}
          --mt-in ${arrayStores(array).refData.mt.google.get}
          --cohorts-map-in ${schemaStores((configSchema, configCohorts)).cohortMap.google.get}
          --variants-stats-out ${schemaStores((configSchema, configCohorts)).variantsStats.base.google.get}
          --variants-stats-ht-out ${schemaStores((configSchema, configCohorts)).variantsStatsHt.base.google.get}
          --cloud
          --log ${schemaStores((configSchema, configCohorts)).variantsStatsHailLog.base.google.get}"""
            .in(projectStores.hailUtils.google.get, arrayStores(array).refData.mt.google.get, schemaStores((configSchema, configCohorts)).cohortMap.google.get)
            .out(schemaStores((configSchema, configCohorts)).variantsStats.base.google.get, schemaStores((configSchema, configCohorts)).variantsStatsHt.base.google.get, schemaStores((configSchema, configCohorts)).variantsStatsHailLog.base.google.get)
            .tag(s"${schemaStores((configSchema, configCohorts)).variantsStats.base.local.get}.google".split("/").last)
      
      }
      
      local {
      
        googleCopy(schemaStores((configSchema, configCohorts)).variantsStats.base.google.get, schemaStores((configSchema, configCohorts)).variantsStats.base.local.get)
        googleCopy(schemaStores((configSchema, configCohorts)).variantsStatsHailLog.base.google.get, schemaStores((configSchema, configCohorts)).variantsStatsHailLog.base.local.get)
      
      }

      for {

        pheno <- fetMissPhenos

      } yield {

        googleWith(projectConfig.cloudResources.mtCluster) {

          hail"""${utils.python.pyHailSchemaPhenoFetMiss} --
            --hail-utils ${projectStores.hailUtils.google.get}
            --reference-genome ${projectConfig.referenceGenome}
            --mt-in ${arrayStores(array).refData.mt.google.get}
            --pheno-in ${projectStores.phenoFile.google.get}
	        --pheno-col ${pheno.id}
            --iid-col ${projectConfig.phenoFileId}
            --cohorts-map-in ${schemaStores((configSchema, configCohorts)).cohortMap.google.get}
            --variants-stats-out ${schemaStores((configSchema, configCohorts)).phenoVariantsStats(pheno).base.google.get}
            --variants-stats-ht-out ${schemaStores((configSchema, configCohorts)).phenoVariantsStatsHt(pheno).base.google.get}
            --cloud
            --log ${schemaStores((configSchema, configCohorts)).phenoVariantsStatsHailLog(pheno).base.google.get}"""
              .in(projectStores.hailUtils.google.get, arrayStores(array).refData.mt.google.get, projectStores.phenoFile.google.get, schemaStores((configSchema, configCohorts)).cohortMap.google.get)
              .out(schemaStores((configSchema, configCohorts)).phenoVariantsStats(pheno).base.google.get, schemaStores((configSchema, configCohorts)).phenoVariantsStatsHt(pheno).base.google.get, schemaStores((configSchema, configCohorts)).phenoVariantsStatsHailLog(pheno).base.google.get)
              .tag(s"${schemaStores((configSchema, configCohorts)).phenoVariantsStats(pheno).base.local.get}.google".split("/").last)
        
        }

        local {

          googleCopy(schemaStores((configSchema, configCohorts)).phenoVariantsStats(pheno).base.google.get, schemaStores((configSchema, configCohorts)).phenoVariantsStats(pheno).base.local.get)
          googleCopy(schemaStores((configSchema, configCohorts)).phenoVariantsStatsHailLog(pheno).base.google.get, schemaStores((configSchema, configCohorts)).phenoVariantsStatsHailLog(pheno).base.local.get)
        
        }

      }
  
    case false =>
  
      drmWith(imageName = s"${utils.image.imgHail}", cores = projectConfig.resources.matrixTableHail.cpus, mem = projectConfig.resources.matrixTableHail.mem, maxRunTime = projectConfig.resources.matrixTableHail.maxRunTime) {
      
        cmd"""${utils.binary.binPython} ${utils.python.pyHailSchemaVariantStats}
          --reference-genome ${projectConfig.referenceGenome}
          --mt-in ${arrayStores(array).refData.mt.local.get}
          --cohorts-map-in ${schemaStores((configSchema, configCohorts)).cohortMap.local.get}
          --variants-stats-out ${schemaStores((configSchema, configCohorts)).variantsStats.base.local.get}
          --variants-stats-ht-out ${schemaStores((configSchema, configCohorts)).variantsStatsHt.base.local.get}
          --log ${schemaStores((configSchema, configCohorts)).variantsStatsHailLog.base.local.get}"""
            .in(arrayStores(array).refData.mt.local.get, schemaStores((configSchema, configCohorts)).cohortMap.local.get)
            .out(schemaStores((configSchema, configCohorts)).variantsStats.base.local.get, schemaStores((configSchema, configCohorts)).variantsStatsHt.base.local.get, schemaStores((configSchema, configCohorts)).variantsStatsHailLog.base.local.get)
            .tag(s"${schemaStores((configSchema, configCohorts)).variantsStats.base.local.get}".split("/").last)
      
      }

      for {

        pheno <- fetMissPhenos

      } yield {

        drmWith(imageName = s"${utils.image.imgHail}", cores = projectConfig.resources.matrixTableHail.cpus, mem = projectConfig.resources.matrixTableHail.mem, maxRunTime = projectConfig.resources.matrixTableHail.maxRunTime) {

          cmd"""${utils.binary.binPython} ${utils.python.pyHailSchemaPhenoFetMiss}
            --reference-genome ${projectConfig.referenceGenome}
            --mt-in ${arrayStores(array).refData.mt.local.get}
            --pheno-in ${projectStores.phenoFile.local.get}
	        --pheno-col ${pheno.id}
            --iid-col ${projectConfig.phenoFileId}
            --cohorts-map-in ${schemaStores((configSchema, configCohorts)).cohortMap.local.get}
            --variants-stats-out ${schemaStores((configSchema, configCohorts)).phenoVariantsStats(pheno).base.local.get}
            --variants-stats-ht-out ${schemaStores((configSchema, configCohorts)).phenoVariantsStatsHt(pheno).base.local.get}
            --log ${schemaStores((configSchema, configCohorts)).phenoVariantsStatsHailLog(pheno).base.local.get}"""
              .in(arrayStores(array).refData.mt.local.get, projectStores.phenoFile.local.get, schemaStores((configSchema, configCohorts)).cohortMap.local.get)
              .out(schemaStores((configSchema, configCohorts)).phenoVariantsStats(pheno).base.local.get, schemaStores((configSchema, configCohorts)).phenoVariantsStatsHt(pheno).base.local.get, schemaStores((configSchema, configCohorts)).phenoVariantsStatsHailLog(pheno).base.local.get)
              .tag(s"${schemaStores((configSchema, configCohorts)).phenoVariantsStats(pheno).base.local.get}".split("/").last)
        
        }

      }
  
  }
  
  (configSchema.design, configSchema.filterCohorts.size) match {
  
    case ("full", n) if n > 0 =>
      
      for {
      
        cohort <- configCohorts if configSchema.filterCohorts.contains(cohort.id)
      
      } yield {
      
        projectConfig.hailCloud match {
        
          case true =>
        
            googleWith(projectConfig.cloudResources.mtCluster) {
          
              hail"""${utils.python.pyHailSchemaVariantStats} --
                --hail-utils ${projectStores.hailUtils.google.get}
                --reference-genome ${projectConfig.referenceGenome}
                --mt-in ${arrayStores(array).refData.mt.google.get}
                --cohorts-map-in ${schemaStores((configSchema, configCohorts)).cohortMap.google.get}
                --cohort ${cohort.id}
                --variants-stats-out ${schemaStores((configSchema, configCohorts)).variantsStats.cohorts(cohort).google.get}
                --variants-stats-ht-out ${schemaStores((configSchema, configCohorts)).variantsStatsHt.cohorts(cohort).google.get}
                --cloud
                --log ${schemaStores((configSchema, configCohorts)).variantsStatsHailLog.cohorts(cohort).google.get}"""
                  .in(projectStores.hailUtils.google.get, arrayStores(array).refData.mt.google.get, schemaStores((configSchema, configCohorts)).cohortMap.google.get)
                  .out(schemaStores((configSchema, configCohorts)).variantsStats.cohorts(cohort).google.get, schemaStores((configSchema, configCohorts)).variantsStatsHt.cohorts(cohort).google.get, schemaStores((configSchema, configCohorts)).variantsStatsHailLog.cohorts(cohort).google.get)
                  .tag(s"${schemaStores((configSchema, configCohorts)).variantsStats.cohorts(cohort).local.get}.google".split("/").last)
            
            }
            
            local {
            
              googleCopy(schemaStores((configSchema, configCohorts)).variantsStats.cohorts(cohort).google.get, schemaStores((configSchema, configCohorts)).variantsStats.cohorts(cohort).local.get)
              googleCopy(schemaStores((configSchema, configCohorts)).variantsStatsHailLog.cohorts(cohort).google.get, schemaStores((configSchema, configCohorts)).variantsStatsHailLog.cohorts(cohort).local.get)
            
            }

            for {

              pheno <- fetMissPhenos
            
            } yield {
            
              googleWith(projectConfig.cloudResources.mtCluster) {
            
                hail"""${utils.python.pyHailSchemaPhenoFetMiss} --
                  --hail-utils ${projectStores.hailUtils.google.get}
                  --reference-genome ${projectConfig.referenceGenome}
                  --mt-in ${arrayStores(array).refData.mt.google.get}
                  --pheno-in ${projectStores.phenoFile.google.get}
	              --pheno-col ${pheno.id}
                  --iid-col ${projectConfig.phenoFileId}
                  --cohorts-map-in ${schemaStores((configSchema, configCohorts)).cohortMap.google.get}
                  --variants-stats-out ${schemaStores((configSchema, configCohorts)).phenoVariantsStats(pheno).cohorts(cohort).google.get}
                  --variants-stats-ht-out ${schemaStores((configSchema, configCohorts)).phenoVariantsStatsHt(pheno).cohorts(cohort).google.get}
                  --cloud
                  --log ${schemaStores((configSchema, configCohorts)).phenoVariantsStatsHailLog(pheno).cohorts(cohort).google.get}"""
                    .in(projectStores.hailUtils.google.get, arrayStores(array).refData.mt.google.get, projectStores.phenoFile.google.get, schemaStores((configSchema, configCohorts)).cohortMap.google.get)
                    .out(schemaStores((configSchema, configCohorts)).phenoVariantsStats(pheno).cohorts(cohort).google.get, schemaStores((configSchema, configCohorts)).phenoVariantsStatsHt(pheno).cohorts(cohort).google.get, schemaStores((configSchema, configCohorts)).phenoVariantsStatsHailLog(pheno).cohorts(cohort).google.get)
                    .tag(s"${schemaStores((configSchema, configCohorts)).phenoVariantsStats(pheno).cohorts(cohort).local.get}.google".split("/").last)
              
              }
            
              local {
            
                googleCopy(schemaStores((configSchema, configCohorts)).phenoVariantsStats(pheno).cohorts(cohort).google.get, schemaStores((configSchema, configCohorts)).phenoVariantsStats(pheno).cohorts(cohort).local.get)
                googleCopy(schemaStores((configSchema, configCohorts)).phenoVariantsStatsHailLog(pheno).cohorts(cohort).google.get, schemaStores((configSchema, configCohorts)).phenoVariantsStatsHailLog(pheno).cohorts(cohort).local.get)
              
              }
            
            }
      
          case false =>
          
            drmWith(imageName = s"${utils.image.imgHail}", cores = projectConfig.resources.matrixTableHail.cpus, mem = projectConfig.resources.matrixTableHail.mem, maxRunTime = projectConfig.resources.matrixTableHail.maxRunTime) {
            
                cmd"""${utils.binary.binPython} ${utils.python.pyHailSchemaVariantStats}
                  --reference-genome ${projectConfig.referenceGenome}
                  --mt-in ${arrayStores(array).refData.mt.local.get}
                  --cohorts-map-in ${schemaStores((configSchema, configCohorts)).cohortMap.local.get}
                  --cohort ${cohort.id}
                  --variants-stats-out ${schemaStores((configSchema, configCohorts)).variantsStats.cohorts(cohort).local.get}
                  --variants-stats-ht-out ${schemaStores((configSchema, configCohorts)).variantsStatsHt.cohorts(cohort).local.get}
                  --log ${schemaStores((configSchema, configCohorts)).variantsStatsHailLog.cohorts(cohort).local.get}"""
                    .in(arrayStores(array).refData.mt.local.get, schemaStores((configSchema, configCohorts)).cohortMap.local.get)
                    .out(schemaStores((configSchema, configCohorts)).variantsStats.cohorts(cohort).local.get, schemaStores((configSchema, configCohorts)).variantsStatsHt.cohorts(cohort).local.get, schemaStores((configSchema, configCohorts)).variantsStatsHailLog.cohorts(cohort).local.get)
                    .tag(s"${schemaStores((configSchema, configCohorts)).variantsStats.cohorts(cohort).local.get}".split("/").last)
              
            }

            for {

              pheno <- fetMissPhenos
            
            } yield {
            
              drmWith(imageName = s"${utils.image.imgHail}", cores = projectConfig.resources.matrixTableHail.cpus, mem = projectConfig.resources.matrixTableHail.mem, maxRunTime = projectConfig.resources.matrixTableHail.maxRunTime) {
            
                cmd"""${utils.binary.binPython} ${utils.python.pyHailSchemaPhenoFetMiss}
                  --reference-genome ${projectConfig.referenceGenome}
                  --mt-in ${arrayStores(array).refData.mt.local.get}
                  --pheno-in ${projectStores.phenoFile.local.get}
	              --pheno-col ${pheno.id}
                  --iid-col ${projectConfig.phenoFileId}
                  --cohorts-map-in ${schemaStores((configSchema, configCohorts)).cohortMap.local.get}
                  --variants-stats-out ${schemaStores((configSchema, configCohorts)).phenoVariantsStats(pheno).cohorts(cohort).local.get}
                  --variants-stats-ht-out ${schemaStores((configSchema, configCohorts)).phenoVariantsStatsHt(pheno).cohorts(cohort).local.get}
                  --log ${schemaStores((configSchema, configCohorts)).phenoVariantsStatsHailLog(pheno).cohorts(cohort).local.get}"""
                    .in(arrayStores(array).refData.mt.local.get, projectStores.phenoFile.local.get, schemaStores((configSchema, configCohorts)).cohortMap.local.get)
                    .out(schemaStores((configSchema, configCohorts)).phenoVariantsStats(pheno).cohorts(cohort).local.get, schemaStores((configSchema, configCohorts)).phenoVariantsStatsHt(pheno).cohorts(cohort).local.get, schemaStores((configSchema, configCohorts)).phenoVariantsStatsHailLog(pheno).cohorts(cohort).local.get)
                    .tag(s"${schemaStores((configSchema, configCohorts)).phenoVariantsStats(pheno).cohorts(cohort).local.get}".split("/").last)
              
              }
            
            }
      
        }
      
      }
  
    case _ => ()
  
  }

  var filters = Seq[String]()
  var cohortFilters = Seq[String]()
  var knockoutFilters = Seq[String]()
  var masks = Seq[String]()
  configSchema.filters match {
    case Some(l) =>
      filters = filters ++ variantFiltersToPrintableList(cfg = projectConfig, filters = l)
    case None => ()
  }
  (configSchema.design, configSchema.cohortFilters) match {
    case ("full", Some(l)) =>
      for {
        cf <- l if configCohorts.map(e => e.id).contains(cf.cohort)
      } yield {
        cohortFilters = cohortFilters ++ variantFiltersToPrintableList(cfg = projectConfig, filters = cf.filters, id = Some(cf.cohort))
      }
    case ("strat", Some(l)) =>
      for {
        cf <- l if configCohorts.head.id == cf.cohort
      } yield {
        filters = filters ++ variantFiltersToPrintableList(cfg = projectConfig, filters = cf.filters)
      }
    case _ => ()
  }
  (configSchema.design, configSchema.knockoutFilters) match {
    case ("full", Some(l)) =>
      for {
        cf <- l if configCohorts.map(e => e.id).contains(cf.cohort)
      } yield {
        knockoutFilters = knockoutFilters ++ variantFiltersToPrintableList(cfg = projectConfig, filters = cf.filters, id = Some(cf.cohort))
      }
    case _ => ()
  }
  configSchema.masks match {
    case Some(l) =>
      for {
        mf <- l
      } yield {
        masks = masks ++ variantFiltersToPrintableList(cfg = projectConfig, filters = mf.filters, id = Some(mf.id))
      }
    case None => ()
  }

  val baseFilters = filters.filter(e => ! e.contains("variant_qc.fet_miss"))
  val baseCohortFilters = cohortFilters.filter(e => ! e.contains("variant_qc.fet_miss"))
  val baseKnockoutFilters = knockoutFilters.filter(e => ! e.contains("variant_qc.fet_miss"))
  val baseMasks = masks.filter(e => ! e.contains("variant_qc.fet_miss"))

  val fString = baseFilters.size match {
  
    case n if n > 0 => s"""echo "${baseFilters.mkString("\n")}" > """
    case _ => "touch "
  
  }
  
  drmWith(imageName = s"${utils.image.imgTools}") {
  
    cmd"""${fString} ${schemaStores((configSchema, configCohorts)).filters.base.local.get}"""
      .out(schemaStores((configSchema, configCohorts)).filters.base.local.get)
      .tag(s"${schemaStores((configSchema, configCohorts)).filters.base.local.get}".split("/").last)
  
  }
  
  val cfString = baseCohortFilters.size match {
  
    case n if n > 0 => s"""echo "${baseCohortFilters.mkString("\n")}" > """
    case _ => "touch "
  
  }
  
  drmWith(imageName = s"${utils.image.imgTools}") {
  
    cmd"""${cfString} ${schemaStores((configSchema, configCohorts)).cohortFilters.base.local.get}"""
      .out(schemaStores((configSchema, configCohorts)).cohortFilters.base.local.get)
      .tag(s"${schemaStores((configSchema, configCohorts)).cohortFilters.base.local.get}".split("/").last)
  
  }
  
  val kfString = baseKnockoutFilters.size match {
  
    case n if n > 0 => s"""echo "${baseKnockoutFilters.mkString("\n")}" > """
    case _ => "touch "
  
  }
  
  drmWith(imageName = s"${utils.image.imgTools}") {
  
    cmd"""${kfString} ${schemaStores((configSchema, configCohorts)).knockoutFilters.base.local.get}"""
      .out(schemaStores((configSchema, configCohorts)).knockoutFilters.base.local.get)
      .tag(s"${schemaStores((configSchema, configCohorts)).knockoutFilters.base.local.get}".split("/").last)
  
  }

  val mString = baseMasks.size match {
  
    case n if n > 0 => s"""echo "${baseMasks.mkString("\n")}" > """
    case _ => "touch "
  
  }
  
  drmWith(imageName = s"${utils.image.imgTools}") {
  
    cmd"""${mString} ${schemaStores((configSchema, configCohorts)).masks.base.local.get}"""
      .out(schemaStores((configSchema, configCohorts)).masks.base.local.get)
      .tag(s"${schemaStores((configSchema, configCohorts)).masks.base.local.get}".split("/").last)
  
  }

  projectConfig.hailCloud match {
  
    case true =>
  
      local {
  
        googleCopy(schemaStores((configSchema, configCohorts)).filters.base.local.get, schemaStores((configSchema, configCohorts)).filters.base.google.get)
        googleCopy(schemaStores((configSchema, configCohorts)).masks.base.local.get, schemaStores((configSchema, configCohorts)).masks.base.google.get)
        googleCopy(schemaStores((configSchema, configCohorts)).cohortFilters.base.local.get, schemaStores((configSchema, configCohorts)).cohortFilters.base.google.get)
        googleCopy(schemaStores((configSchema, configCohorts)).knockoutFilters.base.local.get, schemaStores((configSchema, configCohorts)).knockoutFilters.base.google.get)
      
      }
  
      val cohortStatsInString = {
        schemaStores((configSchema, configCohorts)).variantsStatsHt.cohorts.size match {
          case n if n > 0 =>
            val x = "--cohort-stats-in"
            val y = for {
              (k, v) <- schemaStores((configSchema, configCohorts)).variantsStatsHt.cohorts
            } yield {
              s"""${k.id},${v.google.get.toString.split("@")(1)}"""
            }
            x + " " + y.mkString(" ")
          case _ => ""
        }
      }
  
      var cohortStatsIn = Seq(projectStores.hailUtils.google.get, schemaStores((configSchema, configCohorts)).variantsStatsHt.base.google.get, arrayStores(array).refData.annotationsHt.google.get, schemaStores((configSchema, configCohorts)).filters.base.google.get, schemaStores((configSchema, configCohorts)).masks.base.google.get, arrayStores(array).filterPostQc.variantsExclude.google.get, schemaStores((configSchema, configCohorts)).cohortFilters.base.google.get, schemaStores((configSchema, configCohorts)).knockoutFilters.base.google.get)
      
      schemaStores((configSchema, configCohorts)).variantsStatsHt.cohorts.size match {
        case n if n > 0 =>
          cohortStatsIn = cohortStatsIn ++ {
            for {
              (k, v) <- schemaStores((configSchema, configCohorts)).variantsStatsHt.cohorts
            } yield {
              v.google.get
            }
          }
        case _ => ()
      }

      googleWith(projectConfig.cloudResources.mtCluster) {
      
        hail"""${utils.python.pyHailFilterSchemaVariants} --
          --cloud
          --hail-utils ${projectStores.hailUtils.google.get}
          --reference-genome ${projectConfig.referenceGenome}
          --full-stats-in ${schemaStores((configSchema, configCohorts)).variantsStatsHt.base.google.get}
          ${cohortStatsInString}
          --annotation ${arrayStores(array).refData.annotationsHt.google.get}
          --filters ${schemaStores((configSchema, configCohorts)).filters.base.google.get}
          --cohort-filters ${schemaStores((configSchema, configCohorts)).cohortFilters.base.google.get}
          --knockout-filters ${schemaStores((configSchema, configCohorts)).knockoutFilters.base.google.get}
          --masks ${schemaStores((configSchema, configCohorts)).masks.base.google.get}
          --variants-remove ${arrayStores(array).filterPostQc.variantsExclude.google.get}
          --variant-filters-out ${schemaStores((configSchema, configCohorts)).variantFilterTable.base.google.get}
          --ht-checkpoint ${schemaStores((configSchema, configCohorts)).variantFilterHtCheckpoint.base.google.get}
          --variant-filters-ht-out ${schemaStores((configSchema, configCohorts)).variantFilterHailTable.base.google.get}
          --log ${schemaStores((configSchema, configCohorts)).variantFilterHailLog.base.google.get}"""
            .in(cohortStatsIn)
            .out(schemaStores((configSchema, configCohorts)).variantFilterTable.base.google.get, schemaStores((configSchema, configCohorts)).variantFilterHtCheckpoint.base.google.get, schemaStores((configSchema, configCohorts)).variantFilterHailTable.base.google.get, schemaStores((configSchema, configCohorts)).variantFilterHailLog.base.google.get)
            .tag(s"${schemaStores((configSchema, configCohorts)).variantFilterTable.base.local.get}.google".split("/").last)
      
      }
      
      local {
      
        googleCopy(schemaStores((configSchema, configCohorts)).variantFilterTable.base.google.get, schemaStores((configSchema, configCohorts)).variantFilterTable.base.local.get)
        googleCopy(schemaStores((configSchema, configCohorts)).variantFilterHailLog.base.google.get, schemaStores((configSchema, configCohorts)).variantFilterHailLog.base.local.get)
      
      }
  
    case false =>
  
      val cohortStatsInString = {
        schemaStores((configSchema, configCohorts)).variantsStatsHt.cohorts.size match {
          case n if n > 0 =>
            val x = "--cohort-stats-in"
            val y = for {
              (k, v) <- schemaStores((configSchema, configCohorts)).variantsStatsHt.cohorts
            } yield {
              s"""${k.id},${v.local.get.toString.split("@")(1)}"""
            }
            x + " " + y.mkString(" ")
          case _ => ""
        }
      }
      
      var cohortStatsIn = Seq(schemaStores((configSchema, configCohorts)).variantsStatsHt.base.local.get, arrayStores(array).refData.annotationsHt.local.get, schemaStores((configSchema, configCohorts)).filters.base.local.get, schemaStores((configSchema, configCohorts)).masks.base.local.get, arrayStores(array).filterPostQc.variantsExclude.local.get, schemaStores((configSchema, configCohorts)).cohortFilters.base.local.get, schemaStores((configSchema, configCohorts)).knockoutFilters.base.local.get)
      
      schemaStores((configSchema, configCohorts)).variantsStatsHt.cohorts.size match {
        case n if n > 0 =>
          cohortStatsIn = cohortStatsIn ++ {
            for {
              (k, v) <- schemaStores((configSchema, configCohorts)).variantsStatsHt.cohorts
            } yield {
              v.local.get
            }
          }
        case _ => ()
      }

      drmWith(imageName = s"${utils.image.imgHail}", cores = projectConfig.resources.matrixTableHail.cpus, mem = projectConfig.resources.matrixTableHail.mem, maxRunTime = projectConfig.resources.matrixTableHail.maxRunTime) {
      
        cmd"""${utils.binary.binPython} ${utils.python.pyHailFilterSchemaVariants}
          --reference-genome ${projectConfig.referenceGenome}
          --full-stats-in ${schemaStores((configSchema, configCohorts)).variantsStatsHt.base.local.get}
          ${cohortStatsInString}
          --annotation ${arrayStores(array).refData.annotationsHt.local.get}
          --filters ${schemaStores((configSchema, configCohorts)).filters.base.local.get}
          --cohort-filters ${schemaStores((configSchema, configCohorts)).cohortFilters.base.local.get}
          --knockout-filters ${schemaStores((configSchema, configCohorts)).knockoutFilters.base.local.get}
          --masks ${schemaStores((configSchema, configCohorts)).masks.base.local.get}
          --variants-remove ${arrayStores(array).filterPostQc.variantsExclude.local.get}
          --variant-filters-out ${schemaStores((configSchema, configCohorts)).variantFilterTable.base.local.get}
          --ht-checkpoint ${schemaStores((configSchema, configCohorts)).variantFilterHtCheckpoint.base.local.get}
          --variant-filters-ht-out ${schemaStores((configSchema, configCohorts)).variantFilterHailTable.base.local.get}
          --log ${schemaStores((configSchema, configCohorts)).variantFilterHailLog.base.local.get}"""
            .in(cohortStatsIn)
            .out(schemaStores((configSchema, configCohorts)).variantFilterTable.base.local.get, schemaStores((configSchema, configCohorts)).variantFilterHtCheckpoint.base.local.get, schemaStores((configSchema, configCohorts)).variantFilterHailTable.base.local.get, schemaStores((configSchema, configCohorts)).variantFilterHailLog.base.local.get)
            .tag(s"${schemaStores((configSchema, configCohorts)).variantFilterTable.base.local.get}".split("/").last)
      
      }
  
  }

  val phenoFilters = filters.filter(e => e.contains("variant_qc.fet_miss"))
  val phenoCohortFilters = cohortFilters.filter(e => e.contains("variant_qc.fet_miss"))
  val phenoKnockoutFilters = knockoutFilters.filter(e => e.contains("variant_qc.fet_miss"))
  val phenoMasks = masks.filter(e => e.contains("variant_qc.fet_miss"))

  for {
  
    pheno <- fetMissPhenos
  
  } yield {

    val fString = phenoFilters.size match {
    
      case n if n > 0 => s"""echo "${phenoFilters.mkString("\n")}" > """
      case _ => "touch "
    
    }
    
    drmWith(imageName = s"${utils.image.imgTools}") {
    
      cmd"""${fString} ${schemaStores((configSchema, configCohorts)).filters.phenos(pheno).local.get}"""
        .out(schemaStores((configSchema, configCohorts)).filters.phenos(pheno).local.get)
        .tag(s"${schemaStores((configSchema, configCohorts)).filters.phenos(pheno).local.get}".split("/").last)
    
    }
    
    val cfString = phenoCohortFilters.size match {
    
      case n if n > 0 => s"""echo "${phenoCohortFilters.mkString("\n")}" > """
      case _ => "touch "
    
    }
    
    drmWith(imageName = s"${utils.image.imgTools}") {
    
      cmd"""${cfString} ${schemaStores((configSchema, configCohorts)).cohortFilters.phenos(pheno).local.get}"""
        .out(schemaStores((configSchema, configCohorts)).cohortFilters.phenos(pheno).local.get)
        .tag(s"${schemaStores((configSchema, configCohorts)).cohortFilters.phenos(pheno).local.get}".split("/").last)
    
    }
    
    val kfString = phenoKnockoutFilters.size match {
    
      case n if n > 0 => s"""echo "${phenoKnockoutFilters.mkString("\n")}" > """
      case _ => "touch "
    
    }
    
    drmWith(imageName = s"${utils.image.imgTools}") {
    
      cmd"""${kfString} ${schemaStores((configSchema, configCohorts)).knockoutFilters.phenos(pheno).local.get}"""
        .out(schemaStores((configSchema, configCohorts)).knockoutFilters.phenos(pheno).local.get)
        .tag(s"${schemaStores((configSchema, configCohorts)).knockoutFilters.phenos(pheno).local.get}".split("/").last)
    
    }

    val mString = phenoMasks.size match {
    
      case n if n > 0 => s"""echo "${phenoMasks.mkString("\n")}" > """
      case _ => "touch "
    
    }
    
    drmWith(imageName = s"${utils.image.imgTools}") {
    
      cmd"""${mString} ${schemaStores((configSchema, configCohorts)).masks.phenos(pheno).local.get}"""
        .out(schemaStores((configSchema, configCohorts)).masks.phenos(pheno).local.get)
        .tag(s"${schemaStores((configSchema, configCohorts)).masks.phenos(pheno).local.get}".split("/").last)
    
    }

    projectConfig.hailCloud match {
    
      case true =>
    
        local {
    
          googleCopy(schemaStores((configSchema, configCohorts)).filters.phenos(pheno).local.get, schemaStores((configSchema, configCohorts)).filters.phenos(pheno).google.get)
          googleCopy(schemaStores((configSchema, configCohorts)).masks.phenos(pheno).local.get, schemaStores((configSchema, configCohorts)).masks.phenos(pheno).google.get)
          googleCopy(schemaStores((configSchema, configCohorts)).cohortFilters.phenos(pheno).local.get, schemaStores((configSchema, configCohorts)).cohortFilters.phenos(pheno).google.get)
          googleCopy(schemaStores((configSchema, configCohorts)).knockoutFilters.phenos(pheno).local.get, schemaStores((configSchema, configCohorts)).knockoutFilters.phenos(pheno).google.get)

        }
    
        val cohortStatsInString = {
          schemaStores((configSchema, configCohorts)).variantsStatsHt.cohorts.size match {
            case n if n > 0 =>
              val x = "--cohort-stats-in"
              val y = for {
                (k, v) <- schemaStores((configSchema, configCohorts)).variantsStatsHt.cohorts
              } yield {
                s"""${k.id},${v.google.get.toString.split("@")(1)}"""
              }
              x + " " + y.mkString(" ")
            case _ => ""
          }
        }

        var cohortStatsIn = Seq(projectStores.hailUtils.google.get, schemaStores((configSchema, configCohorts)).variantsStatsHt.base.google.get, schemaStores((configSchema, configCohorts)).phenoVariantsStatsHt(pheno).base.google.get, schemaStores((configSchema, configCohorts)).variantFilterHailTable.base.google.get, arrayStores(array).refData.annotationsHt.google.get, schemaStores((configSchema, configCohorts)).filters.phenos(pheno).google.get, schemaStores((configSchema, configCohorts)).masks.phenos(pheno).google.get, arrayStores(array).filterPostQc.variantsExclude.google.get, schemaStores((configSchema, configCohorts)).cohortFilters.phenos(pheno).google.get, schemaStores((configSchema, configCohorts)).knockoutFilters.phenos(pheno).google.get)
        
        schemaStores((configSchema, configCohorts)).variantsStatsHt.cohorts.size match {
          case n if n > 0 =>
            cohortStatsIn = cohortStatsIn ++ {
              for {
                (k, v) <- schemaStores((configSchema, configCohorts)).variantsStatsHt.cohorts
              } yield {
                v.google.get
              }
            }
          case _ => ()
        }
    
        googleWith(projectConfig.cloudResources.mtCluster) {
        
          hail"""${utils.python.pyHailFilterSchemaPhenoVariants} --
            --cloud
            --hail-utils ${projectStores.hailUtils.google.get}
            --reference-genome ${projectConfig.referenceGenome}
            --full-stats-in ${schemaStores((configSchema, configCohorts)).variantsStatsHt.base.google.get}
            --pheno-stats-in ${schemaStores((configSchema, configCohorts)).phenoVariantsStatsHt(pheno).base.google.get}
            --schema-filters-in ${schemaStores((configSchema, configCohorts)).variantFilterHailTable.base.google.get}
            ${cohortStatsInString}
            --annotation ${arrayStores(array).refData.annotationsHt.google.get}
            --filters ${schemaStores((configSchema, configCohorts)).filters.phenos(pheno).google.get}
            --cohort-filters ${schemaStores((configSchema, configCohorts)).cohortFilters.phenos(pheno).google.get}
            --knockout-filters ${schemaStores((configSchema, configCohorts)).knockoutFilters.phenos(pheno).google.get}
            --masks ${schemaStores((configSchema, configCohorts)).masks.phenos(pheno).google.get}
            --variant-filters-out ${schemaStores((configSchema, configCohorts)).variantFilterTable.phenos(pheno).google.get}
            --ht-checkpoint ${schemaStores((configSchema, configCohorts)).variantFilterHtCheckpoint.phenos(pheno).google.get}
            --variant-filters-ht-out ${schemaStores((configSchema, configCohorts)).variantFilterHailTable.phenos(pheno).google.get}
            --log ${schemaStores((configSchema, configCohorts)).variantFilterHailLog.phenos(pheno).google.get}"""
              .in(cohortStatsIn)
              .out(schemaStores((configSchema, configCohorts)).variantFilterTable.phenos(pheno).google.get, schemaStores((configSchema, configCohorts)).variantFilterHtCheckpoint.phenos(pheno).google.get, schemaStores((configSchema, configCohorts)).variantFilterHailTable.phenos(pheno).google.get, schemaStores((configSchema, configCohorts)).variantFilterHailLog.phenos(pheno).google.get)
              .tag(s"${schemaStores((configSchema, configCohorts)).variantFilterTable.phenos(pheno).local.get}.google".split("/").last)
        
        }
        
        local {
        
          googleCopy(schemaStores((configSchema, configCohorts)).variantFilterTable.phenos(pheno).google.get, schemaStores((configSchema, configCohorts)).variantFilterTable.phenos(pheno).local.get)
          googleCopy(schemaStores((configSchema, configCohorts)).variantFilterHailLog.phenos(pheno).google.get, schemaStores((configSchema, configCohorts)).variantFilterHailLog.phenos(pheno).local.get)
        
        }
    
      case false =>
    
        val cohortStatsInString = {
          schemaStores((configSchema, configCohorts)).variantsStatsHt.cohorts.size match {
            case n if n > 0 =>
              val x = "--cohort-stats-in"
              val y = for {
                (k, v) <- schemaStores((configSchema, configCohorts)).variantsStatsHt.cohorts
              } yield {
                s"""${k.id},${v.local.get.toString.split("@")(1)}"""
              }
              x + " " + y.mkString(" ")
            case _ => ""
          }
        }
        
        var cohortStatsIn = Seq(schemaStores((configSchema, configCohorts)).variantsStatsHt.base.local.get, schemaStores((configSchema, configCohorts)).phenoVariantsStatsHt(pheno).base.local.get, schemaStores((configSchema, configCohorts)).variantFilterHailTable.base.local.get, arrayStores(array).refData.annotationsHt.local.get, schemaStores((configSchema, configCohorts)).filters.phenos(pheno).local.get, schemaStores((configSchema, configCohorts)).masks.phenos(pheno).local.get, arrayStores(array).filterPostQc.variantsExclude.local.get, schemaStores((configSchema, configCohorts)).cohortFilters.phenos(pheno).local.get, schemaStores((configSchema, configCohorts)).knockoutFilters.phenos(pheno).local.get)
        
        schemaStores((configSchema, configCohorts)).variantsStatsHt.cohorts.size match {
          case n if n > 0 =>
            cohortStatsIn = cohortStatsIn ++ {
              for {
                (k, v) <- schemaStores((configSchema, configCohorts)).variantsStatsHt.cohorts
              } yield {
                v.local.get
              }
            }
          case _ => ()
        }
        
        drmWith(imageName = s"${utils.image.imgHail}", cores = projectConfig.resources.matrixTableHail.cpus, mem = projectConfig.resources.matrixTableHail.mem, maxRunTime = projectConfig.resources.matrixTableHail.maxRunTime) {
        
          cmd"""${utils.binary.binPython} ${utils.python.pyHailFilterSchemaPhenoVariants}
            --reference-genome ${projectConfig.referenceGenome}
            --full-stats-in ${schemaStores((configSchema, configCohorts)).variantsStatsHt.base.local.get}
            --pheno-stats-in ${schemaStores((configSchema, configCohorts)).phenoVariantsStatsHt(pheno).base.local.get}
            --schema-filters-in ${schemaStores((configSchema, configCohorts)).variantFilterHailTable.base.local.get}
            ${cohortStatsInString}
            --annotation ${arrayStores(array).refData.annotationsHt.local.get}
            --filters ${schemaStores((configSchema, configCohorts)).filters.phenos(pheno).local.get}
            --cohort-filters ${schemaStores((configSchema, configCohorts)).cohortFilters.phenos(pheno).local.get}
            --knockout-filters ${schemaStores((configSchema, configCohorts)).knockoutFilters.phenos(pheno).local.get}
            --masks ${schemaStores((configSchema, configCohorts)).masks.phenos(pheno).local.get}
            --variant-filters-out ${schemaStores((configSchema, configCohorts)).variantFilterTable.phenos(pheno).local.get}
            --ht-checkpoint ${schemaStores((configSchema, configCohorts)).variantFilterHtCheckpoint.phenos(pheno).local.get}
            --variant-filters-ht-out ${schemaStores((configSchema, configCohorts)).variantFilterHailTable.phenos(pheno).local.get}
            --log ${schemaStores((configSchema, configCohorts)).variantFilterHailLog.phenos(pheno).local.get}"""
              .in(cohortStatsIn)
              .out(schemaStores((configSchema, configCohorts)).variantFilterTable.phenos(pheno).local.get, schemaStores((configSchema, configCohorts)).variantFilterHtCheckpoint.phenos(pheno).local.get, schemaStores((configSchema, configCohorts)).variantFilterHailTable.phenos(pheno).local.get, schemaStores((configSchema, configCohorts)).variantFilterHailLog.phenos(pheno).local.get)
              .tag(s"${schemaStores((configSchema, configCohorts)).variantFilterTable.phenos(pheno).local.get}".split("/").last)
        
        }
    
    }

  }

  // write pyHailFilterSchemaPhenoVariants
  //   read in schema level filters.tsv.bgz and pheno level filter files, generated above, to generate pheno specific filters.tsv.bgz file (ie *.PurpleHair.filters.tsv.bgz)
  // run pyGeneratePhenoGroupfile to generate main group file along with main masked group files
  // write pyGeneratePhenoGroupfile
  //   filter each group file from pyGeneratePhenoGroupfile directly for each phenotype (ie using python), extract any variants that dont pass in *.PurpleHair.filters.tsv.bgz, then create new group files that are pheno specific
  //   make sure that any genes in the group file that become empty after filtering are removed from the file
  
  projectConfig.hailCloud match {
  
    case true =>
  
      val maskedGroupFilesString = schemaStores((configSchema, configCohorts)).groupFile.base.masks.size match {
        case n if n > 0 =>
          val x = "--masked-groupfiles-out"
          val y = for {
            (k, v) <- schemaStores((configSchema, configCohorts)).groupFile.base.masks
          } yield {
            s"""${k.id},${v.google.get.toString.split("@")(1)}"""
          }
          x + " " + y.mkString(" ")
        case _ => ""
      }
  
      var generateGroupfileOut = Seq(schemaStores((configSchema, configCohorts)).groupFile.base.base.google.get, schemaStores((configSchema, configCohorts)).groupFileHailLog.base.google.get)
  
      schemaStores((configSchema, configCohorts)).groupFile.base.masks.size match {
          case n if n > 0 =>
            generateGroupfileOut = generateGroupfileOut ++ {
              for {
                (k, v) <- schemaStores((configSchema, configCohorts)).groupFile.base.masks
              } yield {
                v.google.get
              }
            }
          case _ => ()
      }

      googleWith(projectConfig.cloudResources.mtCluster) {
      
        hail"""${utils.python.pyHailGenerateGroupfile} --
          --cloud
          --hail-utils ${projectStores.hailUtils.google.get}
          ${maskedGroupFilesString}
          --filter-table-in ${schemaStores((configSchema, configCohorts)).variantFilterHailTable.base.google.get}
          --groupfile-out ${schemaStores((configSchema, configCohorts)).groupFile.base.base.google.get}
          --log ${schemaStores((configSchema, configCohorts)).groupFileHailLog.base.google.get}"""
          .in(projectStores.hailUtils.google.get, schemaStores((configSchema, configCohorts)).variantFilterHailTable.base.google.get)
          .out(generateGroupfileOut)
          .tag(s"${schemaStores((configSchema, configCohorts)).groupFile.base.base.local.get}.google".split("/").last)
  
      }
  
      local {
      
        googleCopy(schemaStores((configSchema, configCohorts)).groupFile.base.base.google.get, schemaStores((configSchema, configCohorts)).groupFile.base.base.local.get)
        googleCopy(schemaStores((configSchema, configCohorts)).groupFileHailLog.base.google.get, schemaStores((configSchema, configCohorts)).groupFileHailLog.base.local.get)
      
      }
      
      schemaStores((configSchema, configCohorts)).groupFile.base.masks.size match {
        case n if n > 0 =>
          for {
            (k, v) <- schemaStores((configSchema, configCohorts)).groupFile.base.masks
          } yield {
            local {
              googleCopy(v.google.get, v.local.get)
            }
          }
        case _ => ()
      }

    case false =>
  
      val maskedGroupFilesString = schemaStores((configSchema, configCohorts)).groupFile.base.masks.size match {
        case n if n > 0 =>
          val x = "--masked-groupfiles-out"
          val y = for {
            (k, v) <- schemaStores((configSchema, configCohorts)).groupFile.base.masks
          } yield {
            s"""${k.id},${v.local.get.toString.split("@")(1)}"""
          }
          x + " " + y.mkString(" ")
        case _ => ""
      }
      
      var generateGroupfileOut = Seq(schemaStores((configSchema, configCohorts)).groupFile.base.base.local.get, schemaStores((configSchema, configCohorts)).groupFileHailLog.base.local.get)
      
      schemaStores((configSchema, configCohorts)).groupFile.base.masks.size match {
        case n if n > 0 =>
          generateGroupfileOut = generateGroupfileOut ++ {
            for {
              (k, v) <- schemaStores((configSchema, configCohorts)).groupFile.base.masks
            } yield {
              v.local.get
            }
          }
        case _ => ()
      }

      drmWith(imageName = s"${utils.image.imgHail}", cores = projectConfig.resources.matrixTableHail.cpus, mem = projectConfig.resources.matrixTableHail.mem, maxRunTime = projectConfig.resources.matrixTableHail.maxRunTime) {
      
        cmd"""${utils.binary.binPython} ${utils.python.pyHailGenerateGroupfile}
          ${maskedGroupFilesString}
          --filter-table-in ${schemaStores((configSchema, configCohorts)).variantFilterHailTable.base.local.get}
          --groupfile-out ${schemaStores((configSchema, configCohorts)).groupFile.base.base.local.get}
          --log ${schemaStores((configSchema, configCohorts)).groupFileHailLog.base.local.get}"""
          .in(schemaStores((configSchema, configCohorts)).variantFilterHailTable.base.local.get)
          .out(generateGroupfileOut)
          .tag(s"${schemaStores((configSchema, configCohorts)).groupFile.base.base.local.get}".split("/").last)
      
      }
  
  }

  for {
  
    pheno <- fetMissPhenos
  
  } yield {

    projectConfig.hailCloud match {
  
      case true =>
    
        val maskedGroupFilesString = schemaStores((configSchema, configCohorts)).groupFile.phenos(pheno).masks.size match {
          case n if n > 0 =>
            val x = "--masked-groupfiles-out"
            val y = for {
              (k, v) <- schemaStores((configSchema, configCohorts)).groupFile.phenos(pheno).masks
            } yield {
              s"""${k.id},${v.google.get.toString.split("@")(1)}"""
            }
            x + " " + y.mkString(" ")
          case _ => ""
        }
    
        var generateGroupfileOut = Seq(schemaStores((configSchema, configCohorts)).groupFile.phenos(pheno).base.google.get, schemaStores((configSchema, configCohorts)).groupFileHailLog.phenos(pheno).google.get)
    
        schemaStores((configSchema, configCohorts)).groupFile.phenos(pheno).masks.size match {
            case n if n > 0 =>
              generateGroupfileOut = generateGroupfileOut ++ {
                for {
                  (k, v) <- schemaStores((configSchema, configCohorts)).groupFile.phenos(pheno).masks
                } yield {
                  v.google.get
                }
              }
            case _ => ()
        }
    
        googleWith(projectConfig.cloudResources.mtCluster) {
        
          hail"""${utils.python.pyHailGenerateGroupfile} --
            --cloud
            --hail-utils ${projectStores.hailUtils.google.get}
            ${maskedGroupFilesString}
            --filter-table-in ${schemaStores((configSchema, configCohorts)).variantFilterHailTable.phenos(pheno).google.get}
            --groupfile-out ${schemaStores((configSchema, configCohorts)).groupFile.phenos(pheno).base.google.get}
            --log ${schemaStores((configSchema, configCohorts)).groupFileHailLog.phenos(pheno).google.get}"""
            .in(projectStores.hailUtils.google.get, schemaStores((configSchema, configCohorts)).variantFilterHailTable.phenos(pheno).google.get)
            .out(generateGroupfileOut)
            .tag(s"${schemaStores((configSchema, configCohorts)).groupFile.phenos(pheno).base.local.get}.google".split("/").last)
    
        }
    
        local {
        
          googleCopy(schemaStores((configSchema, configCohorts)).groupFile.phenos(pheno).base.google.get, schemaStores((configSchema, configCohorts)).groupFile.phenos(pheno).base.local.get)
          googleCopy(schemaStores((configSchema, configCohorts)).groupFileHailLog.phenos(pheno).google.get, schemaStores((configSchema, configCohorts)).groupFileHailLog.phenos(pheno).local.get)
        
        }
        
        schemaStores((configSchema, configCohorts)).groupFile.phenos(pheno).masks.size match {
          case n if n > 0 =>
            for {
              (k, v) <- schemaStores((configSchema, configCohorts)).groupFile.phenos(pheno).masks
            } yield {
              local {
                googleCopy(v.google.get, v.local.get)
              }
            }
          case _ => ()
        }
    
      case false =>
    
        val maskedGroupFilesString = schemaStores((configSchema, configCohorts)).groupFile.phenos(pheno).masks.size match {
          case n if n > 0 =>
            val x = "--masked-groupfiles-out"
            val y = for {
              (k, v) <- schemaStores((configSchema, configCohorts)).groupFile.phenos(pheno).masks
            } yield {
              s"""${k.id},${v.local.get.toString.split("@")(1)}"""
            }
            x + " " + y.mkString(" ")
          case _ => ""
        }
        
        var generateGroupfileOut = Seq(schemaStores((configSchema, configCohorts)).groupFile.phenos(pheno).base.local.get, schemaStores((configSchema, configCohorts)).groupFileHailLog.phenos(pheno).local.get)
        
        schemaStores((configSchema, configCohorts)).groupFile.phenos(pheno).masks.size match {
          case n if n > 0 =>
            generateGroupfileOut = generateGroupfileOut ++ {
              for {
                (k, v) <- schemaStores((configSchema, configCohorts)).groupFile.phenos(pheno).masks
              } yield {
                v.local.get
              }
            }
          case _ => ()
        }
    
        drmWith(imageName = s"${utils.image.imgHail}", cores = projectConfig.resources.matrixTableHail.cpus, mem = projectConfig.resources.matrixTableHail.mem, maxRunTime = projectConfig.resources.matrixTableHail.maxRunTime) {
        
          cmd"""${utils.binary.binPython} ${utils.python.pyHailGenerateGroupfile}
            ${maskedGroupFilesString}
            --filter-table-in ${schemaStores((configSchema, configCohorts)).variantFilterHailTable.phenos(pheno).local.get}
            --groupfile-out ${schemaStores((configSchema, configCohorts)).groupFile.phenos(pheno).base.local.get}
            --log ${schemaStores((configSchema, configCohorts)).groupFileHailLog.phenos(pheno).local.get}"""
            .in(schemaStores((configSchema, configCohorts)).variantFilterHailTable.phenos(pheno).local.get)
            .out(generateGroupfileOut)
            .tag(s"${schemaStores((configSchema, configCohorts)).groupFile.phenos(pheno).base.local.get}".split("/").last)
        
        }
    
    }

  }

  schemaStores((configSchema, configCohorts)).vcf match {
  
    case Some(s) =>
  
      projectConfig.hailCloud match {
      
        case true =>
  
          googleWith(projectConfig.cloudResources.mtCluster) {
          
            hail"""${utils.python.pyHailGenerateModelVcf} --
              --cloud
              --hail-utils ${projectStores.hailUtils.google.get}
              --mt-in ${arrayStores(array).refData.mt.google.get}
              --cohorts-map-in ${schemaStores((configSchema, configCohorts)).cohortMap.google.get}
              --filter-table-in ${schemaStores((configSchema, configCohorts)).variantFilterHailTable.base.google.get}
              --vcf-out ${schemaStores((configSchema, configCohorts)).vcf.get.data.google.get}
              --log ${schemaStores((configSchema, configCohorts)).vcfHailLog.google.get}"""
              .in(projectStores.hailUtils.google.get, arrayStores(array).refData.mt.google.get, schemaStores((configSchema, configCohorts)).cohortMap.google.get, schemaStores((configSchema, configCohorts)).variantFilterHailTable.base.google.get)
              .out(schemaStores((configSchema, configCohorts)).vcf.get.data.google.get, schemaStores((configSchema, configCohorts)).vcfHailLog.google.get)
              .tag(s"${schemaStores((configSchema, configCohorts)).vcf.get.data.local.get}.google".split("/").last)
    
          }
  
          local {
  
            googleCopy(schemaStores((configSchema, configCohorts)).vcf.get.data.google.get, schemaStores((configSchema, configCohorts)).vcf.get.data.local.get)
            googleCopy(schemaStores((configSchema, configCohorts)).vcfHailLog.google.get, schemaStores((configSchema, configCohorts)).vcfHailLog.local.get)
  
          }
  
        case false =>
  
          drmWith(imageName = s"${utils.image.imgHail}", cores = projectConfig.resources.matrixTableHail.cpus, mem = projectConfig.resources.matrixTableHail.mem, maxRunTime = projectConfig.resources.matrixTableHail.maxRunTime) {
          
            cmd"""${utils.binary.binPython} ${utils.python.pyHailGenerateModelVcf}
              --mt-in ${arrayStores(array).refData.mt.local.get}
              --cohorts-map-in ${schemaStores((configSchema, configCohorts)).cohortMap.local.get}
              --filter-table-in ${schemaStores((configSchema, configCohorts)).variantFilterHailTable.base.local.get}
              --vcf-out ${schemaStores((configSchema, configCohorts)).vcf.get.data.local.get}
              --log ${schemaStores((configSchema, configCohorts)).vcfHailLog.local.get}"""
              .in(arrayStores(array).refData.mt.local.get, schemaStores((configSchema, configCohorts)).cohortMap.local.get, schemaStores((configSchema, configCohorts)).variantFilterHailTable.base.local.get)
              .out(schemaStores((configSchema, configCohorts)).vcf.get.data.local.get, schemaStores((configSchema, configCohorts)).vcfHailLog.local.get)
              .tag(s"${schemaStores((configSchema, configCohorts)).vcf.get.data.local.get}".split("/").last)
    
          }
  
      }
  
      drmWith(imageName = s"${utils.image.imgTools}", cores = projectConfig.resources.tabix.cpus, mem = projectConfig.resources.tabix.mem, maxRunTime = projectConfig.resources.tabix.maxRunTime) {
  
        cmd"""${utils.binary.binTabix} -p vcf ${schemaStores((configSchema, configCohorts)).vcf.get.data.local.get}"""
          .in(schemaStores((configSchema, configCohorts)).vcf.get.data.local.get)
          .out(schemaStores((configSchema, configCohorts)).vcf.get.tbi.local.get)
          .tag(s"${schemaStores((configSchema, configCohorts)).vcf.get.tbi.local.get}".split("/").last)
      
      }
  
    case None => ()
  
  }

}
