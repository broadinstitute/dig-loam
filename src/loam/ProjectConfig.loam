import Fxns._

val dataConfig = loadConfig("dataConfig", "")

val defaultSampleMetricsGwas = Seq("n_non_ref","n_het","n_called","call_rate","r_ti_tv","het","het_low","het_high","n_hom_var","r_het_hom_var")
val defaultSampleMetricsSeq = Seq("n_non_ref","n_het","n_called","call_rate","r_ti_tv","het","het_low","het_high","n_hom_var","r_het_hom_var","n_singleton","avg_ab","avg_ab50")

final case class ConfigMachine(
  cpus: Int,
  mem: Int,
  maxRunTime: Int)

final case class ConfigSampleFilters(
  n_non_ref: Option[String],
  n_het: Option[String],
  n_called: Option[String],
  call_rate: Option[String],
  n_singleton: Option[String],
  r_ti_tv: Option[String],
  het: Option[String],
  het_low: Option[String],
  het_high: Option[String],
  n_hom_var: Option[String],
  r_het_hom_var: Option[String],
  avg_ab: Option[String],
  avg_ab50: Option[String]
) {
  def tupelize_metrics: List[(String,Option[String])] = {
    List(
      ("n_non_ref",n_non_ref),
      ("n_het",n_het),
      ("n_called",n_called),
      ("call_rate",call_rate),
      ("n_singleton",n_singleton),
      ("r_ti_tv",r_ti_tv),
      ("het",het),
      ("het_low",het_low),
      ("het_high",het_high),
      ("n_hom_var",n_hom_var),
      ("r_het_hom_var",r_het_hom_var),
      ("avg_ab",avg_ab),
      ("avg_ab50",avg_ab50)
   )
  }
}

final case class ConfigVariantFilters(
  call_rate: Option[String],
  AC: Option[String],
  AF: Option[String],
  AN: Option[String],
  n_called: Option[String],
  n_not_called: Option[String],
  homozygote_count: Option[String],
  n_het: Option[String],
  het: Option[String],
  n_non_ref: Option[String],
  avg_ab: Option[String],
  avg_het_ab: Option[String],
  het_freq_hwe: Option[String],
  p_value_hwe: Option[String],
  sample_n: Option[Int],
  sample_seed: Option[Int]
) {
  def tupelize_metrics: List[(String,Option[String])] = {
    List(
      ("call_rate",call_rate),
      ("AC",AC),
      ("AF",AF),
      ("AN",AN),
      ("n_called",n_called),
      ("n_not_called",n_not_called),
      ("homozygote_count",homozygote_count),
      ("n_het",n_het),
      ("het",het),
      ("n_non_ref",n_non_ref),
      ("avg_ab",avg_ab),
      ("avg_het_ab",avg_het_ab),
      ("het_freq_hwe",het_freq_hwe),
      ("p_value_hwe",p_value_hwe)
   )
  }
}

final case class ConfigResources(
  preparePlink: ConfigMachine,
  prepareFindBestDuplicateVariants: ConfigMachine,
  prepareLiftOver: ConfigMachine,
  harmonizePlinkFull: ConfigMachine,
  harmonizeGenotypeHarmonizer: ConfigMachine,
  harmonizeAlignNon1kgVariants: ConfigMachine,
  harmonizePlinkChr: ConfigMachine,
  loadHail: ConfigMachine,
  filterHail: ConfigMachine,
  prunePlink: ConfigMachine,
  annotate: ConfigMachine,
  kinshipKing: ConfigMachine,
  ancestryPcaHail: ConfigMachine,
  ancestryPcaPlink: ConfigMachine,
  ancestryPcaPcair: ConfigMachine,
  ancestryClusterKlustakwik: ConfigMachine,
  pca: ConfigMachine,
  sampleQcHail: ConfigMachine,
  sampleQcKlustakwikPca: ConfigMachine,
  sampleQcKlustakwikMetric: ConfigMachine,
  filterFinalHail: ConfigMachine,
  filterFinalPlink: ConfigMachine,
  filterFinalPcair: ConfigMachine,
  filterImputePlink: ConfigMachine,
  variantAssocHailAssoc: ConfigMachine,
  variantAssocGeneratePheno: ConfigMachine,
  crossCohortPrepPlink: ConfigMachine,
  crossCohortKinshipPlink: ConfigMachine,
  crossCohortKinshipKing: ConfigMachine,
  metaAnalysisHail: ConfigMachine,
  mergeAssocHail: ConfigMachine)

final case class ConfigArray(
  id: String,
  filename: String,
  format: String,
  technology: String,
  description: String,
  minPartitions: Option[Int],
  liftOver: Option[String] = None,
  sampleQcMetrics: Seq[String],
  nSampleMetricPcs: Option[Int],
  sampleMetricCovars: Option[String],
  xChr: Boolean,
  yChr: Boolean,
  mtChr: Boolean,
  skipGh: Seq[String],
  gqThreshold: Option[Int],
  qcVariantFilters: Option[ConfigVariantFilters],
  ancestryOutliersKeep: Seq[String],
  duplicatesKeep: Seq[String],
  famsizeKeep: Seq[String],
  sampleqcKeep: Seq[String],
  sexcheckKeep: Seq[String],
  analysisSampleFilters: Option[ConfigSampleFilters],
  analysisVariantFilters: Option[ConfigVariantFilters])

final case class ConfigCohort(
  id: String,
  array: String,
  ancestry: Seq[String],
  minPartitions: Option[Int])

final case class ConfigMeta(
  id: String,
  cohorts: Seq[String],
  minPartitions: Option[Int])

final case class ConfigMerge(
  id: String,
  cohorts_metas: Seq[String],
  minPartitions: Option[Int])

final case class ConfigPheno(
  id: String,
  name: String)

final case class ConfigModel(
  id: String,
  pheno: String,
  trans: String,
  test: String,
  covars: String)

final case class ConfigKnown(
  id: String,
  data: String,
  hiLd: String,
  n: String,
  nCase: String,
  nCtrl: String,
  desc: String,
  citation: String)

final case class ConfigSection(
  id: String,
  title: String,
  models: Seq[String],
  cohorts: Option[Seq[String]],
  metas: Option[Seq[String]],
  merges: Option[Seq[String]],
  knowns: Option[Seq[String]])

final case class ConfigReport(
  id: String,
  name: String,
  sections: Seq[ConfigSection])

final case class ProjectConfig(
  loamstreamVersion: String,
  pipelineVersion: String,
  projectId: String,
  referenceGenome: String,
  regionsExclude: String,
  regionsExcludeGoogle: Option[String],
  genePositions: String,
  kgPurcellVcf: String,
  kgPurcellVcfGoogle: Option[String],
  kgSample: String,
  kgSampleGoogle: Option[String],
  kgSampleId: String,
  kgSamplePop: String,
  kgSampleGroup: String,
  kgVcf: String,
  kgIds: String,
  humanReferenceWild: String,
  fasta: String,
  vepCacheDir: String,
  vepPluginsDir: String,
  dbNSFP: String,
  sampleFile: String,
  sampleFileId: String,
  sampleFileSrSex: String,
  sampleFileMaleCode: String,
  sampleFileFemaleCode: String,
  sampleFileSrRace: String,
  sampleFileAFRCodes: Seq[String],
  sampleFileAMRCodes: Seq[String],
  sampleFileEURCodes: Seq[String],
  sampleFileEASCodes: Seq[String],
  sampleFileSASCodes: Seq[String],
  phenoFile: String,
  phenoFileId: String,
  authors: Seq[String],
  email: String,
  organization: String,
  acknowledgementsAnalysisReport: Seq[String],
  acknowledgementsQcReport: Seq[String],
  nAncestryInferenceFeatures: Int,
  ancestryInferenceFeatures: String,
  minPCs: Int,
  maxPCs: Int,
  nStddevs: Int,
  resources: ConfigResources,
  nArrays: Int,
  nCohorts: Int,
  nMetas: Int,
  maxSigRegions: Option[Int],
  Arrays: Seq[ConfigArray],
  Cohorts: Seq[ConfigCohort],
  Metas: Seq[ConfigMeta],
  Merges: Seq[ConfigMerge],
  Phenos: Seq[ConfigPheno],
  Models: Seq[ConfigModel],
  Knowns: Seq[ConfigKnown],
  Reports: Seq[ConfigReport])

val projectConfig = ProjectConfig(

  // required global values in conf file
  loamstreamVersion = dataConfig.getStr("loamstreamVersion"),
  pipelineVersion = dataConfig.getStr("pipelineVersion"),
  projectId = dataConfig.getStr("projectId"),
  referenceGenome = dataConfig.getStr("referenceGenome"),
  regionsExclude = dataConfig.getStr("regionsExclude"),
  regionsExcludeGoogle = if(dataConfig.isDefined("regionsExcludeGoogle")) { Some(dataConfig.getStr("regionsExcludeGoogle")) } else { None },
  genePositions = dataConfig.getStr("genePositions"),
  kgPurcellVcf = dataConfig.getStr("kgPurcellVcf"),
  kgPurcellVcfGoogle = if(dataConfig.isDefined("kgPurcellVcfGoogle")) { Some(dataConfig.getStr("kgPurcellVcfGoogle")) } else { None },
  kgSample = dataConfig.getStr("kgSample"),
  kgSampleGoogle = if(dataConfig.isDefined("kgSampleGoogle")) { Some(dataConfig.getStr("kgSampleGoogle")) } else { None },
  kgSampleId = dataConfig.getStr("kgSampleId"),
  kgSamplePop = dataConfig.getStr("kgSamplePop"),
  kgSampleGroup = dataConfig.getStr("kgSampleGroup"),
  kgVcf = dataConfig.getStr("kgVcf"),
  kgIds = dataConfig.getStr("kgIds"),
  humanReferenceWild = dataConfig.getStr("humanReferenceWild"),
  fasta = dataConfig.getStr("fasta"),
  vepCacheDir = dataConfig.getStr("vepCacheDir"),
  vepPluginsDir = dataConfig.getStr("vepPluginsDir"),
  dbNSFP = dataConfig.getStr("dbNSFP"),
  sampleFile = dataConfig.getStr("sampleFile"),
  sampleFileId = dataConfig.getStr("sampleFileId"),
  sampleFileSrSex = dataConfig.getStr("sampleFileSrSex"),
  sampleFileMaleCode = dataConfig.getStr("sampleFileMaleCode"),
  sampleFileFemaleCode = dataConfig.getStr("sampleFileFemaleCode"),
  sampleFileSrRace = dataConfig.getStr("sampleFileSrRace"),
  sampleFileAFRCodes = dataConfig.getStrList("sampleFileAFRCodes"),
  sampleFileAMRCodes = dataConfig.getStrList("sampleFileAMRCodes"),
  sampleFileEURCodes = dataConfig.getStrList("sampleFileEURCodes"),
  sampleFileEASCodes = dataConfig.getStrList("sampleFileEASCodes"),
  sampleFileSASCodes = dataConfig.getStrList("sampleFileSASCodes"),
  phenoFile = dataConfig.getStr("phenoFile"),
  phenoFileId = dataConfig.getStr("phenoFileId"),
  authors = dataConfig.getStrList("authors"),
  email = dataConfig.getStr("email"),
  organization = dataConfig.getStr("organization"),
  acknowledgementsAnalysisReport = dataConfig.getStrList("acknowledgementsAnalysisReport"),
  acknowledgementsQcReport = dataConfig.getStrList("acknowledgementsQcReport"),
  nAncestryInferenceFeatures = dataConfig.getInt("nAncestryInferenceFeatures"),
  minPCs = dataConfig.getInt("minPCs"),
  maxPCs = dataConfig.getInt("maxPCs"),
  nStddevs = dataConfig.getInt("nStddevs"),
  maxSigRegions = if (dataConfig.isDefined("maxSigRegions")) { Some(dataConfig.getInt("maxSigRegions")) } else { None },

  // inferred global values
  ancestryInferenceFeatures = if (dataConfig.isDefined("nAncestryInferenceFeatures")) { "1" * dataConfig.getInt("nAncestryInferenceFeatures") + "0" * (20 - dataConfig.getInt("nAncestryInferenceFeatures")) } else { "1" * 3 + "0" * (20 - 3) },
  nArrays = dataConfig.getObjList("arrays").size,
  nCohorts = dataConfig.getObjList("cohorts").size,
  nMetas = dataConfig.getObjList("metas").size,

  resources = ConfigResources(
    preparePlink = ConfigMachine( cpus = dataConfig.getObj("preparePlink").getInt("cpus"), mem = dataConfig.getObj("preparePlink").getInt("mem"), maxRunTime = dataConfig.getObj("preparePlink").getInt("maxRunTime") ),
    prepareFindBestDuplicateVariants = ConfigMachine( cpus = dataConfig.getObj("prepareFindBestDuplicateVariants").getInt("cpus"), mem = dataConfig.getObj("prepareFindBestDuplicateVariants").getInt("mem"), maxRunTime = dataConfig.getObj("prepareFindBestDuplicateVariants").getInt("maxRunTime") ),
    prepareLiftOver = ConfigMachine( cpus = dataConfig.getObj("prepareLiftOver").getInt("cpus"), mem = dataConfig.getObj("prepareLiftOver").getInt("mem"), maxRunTime = dataConfig.getObj("prepareLiftOver").getInt("maxRunTime") ),
    harmonizePlinkFull = ConfigMachine( cpus = dataConfig.getObj("harmonizePlinkFull").getInt("cpus"), mem = dataConfig.getObj("harmonizePlinkFull").getInt("mem"), maxRunTime = dataConfig.getObj("harmonizePlinkFull").getInt("maxRunTime") ),
    harmonizeGenotypeHarmonizer = ConfigMachine( cpus = dataConfig.getObj("harmonizeGenotypeHarmonizer").getInt("cpus"), mem = dataConfig.getObj("harmonizeGenotypeHarmonizer").getInt("mem"), maxRunTime = dataConfig.getObj("harmonizeGenotypeHarmonizer").getInt("maxRunTime") ),
    harmonizeAlignNon1kgVariants = ConfigMachine( cpus = dataConfig.getObj("harmonizeAlignNon1kgVariants").getInt("cpus"), mem = dataConfig.getObj("harmonizeAlignNon1kgVariants").getInt("mem"), maxRunTime = dataConfig.getObj("harmonizeAlignNon1kgVariants").getInt("maxRunTime") ),
    harmonizePlinkChr = ConfigMachine( cpus = dataConfig.getObj("harmonizePlinkChr").getInt("cpus"), mem = dataConfig.getObj("harmonizePlinkChr").getInt("mem"), maxRunTime = dataConfig.getObj("harmonizePlinkChr").getInt("maxRunTime") ),
    loadHail = ConfigMachine( cpus = dataConfig.getObj("loadHail").getInt("cpus"), mem = dataConfig.getObj("loadHail").getInt("mem"), maxRunTime = dataConfig.getObj("loadHail").getInt("maxRunTime") ),
    filterHail = ConfigMachine( cpus = dataConfig.getObj("filterHail").getInt("cpus"), mem = dataConfig.getObj("filterHail").getInt("mem"), maxRunTime = dataConfig.getObj("filterHail").getInt("maxRunTime") ),
    prunePlink = ConfigMachine( cpus = dataConfig.getObj("prunePlink").getInt("cpus"), mem = dataConfig.getObj("prunePlink").getInt("mem"), maxRunTime = dataConfig.getObj("prunePlink").getInt("maxRunTime") ),
    annotate = ConfigMachine( cpus = dataConfig.getObj("annotate").getInt("cpus"), mem = dataConfig.getObj("annotate").getInt("mem"), maxRunTime = dataConfig.getObj("annotate").getInt("maxRunTime") ),
    kinshipKing = ConfigMachine( cpus = dataConfig.getObj("kinshipKing").getInt("cpus"), mem = dataConfig.getObj("kinshipKing").getInt("mem"), maxRunTime = dataConfig.getObj("kinshipKing").getInt("maxRunTime") ),
    ancestryPcaHail = ConfigMachine( cpus = dataConfig.getObj("ancestryPcaHail").getInt("cpus"), mem = dataConfig.getObj("ancestryPcaHail").getInt("mem"), maxRunTime = dataConfig.getObj("ancestryPcaHail").getInt("maxRunTime") ),
    ancestryPcaPlink = ConfigMachine( cpus = dataConfig.getObj("ancestryPcaPlink").getInt("cpus"), mem = dataConfig.getObj("ancestryPcaPlink").getInt("mem"), maxRunTime = dataConfig.getObj("ancestryPcaPlink").getInt("maxRunTime") ),
    ancestryPcaPcair = ConfigMachine( cpus = dataConfig.getObj("ancestryPcaPcair").getInt("cpus"), mem = dataConfig.getObj("ancestryPcaPcair").getInt("mem"), maxRunTime = dataConfig.getObj("ancestryPcaPcair").getInt("maxRunTime") ),
    ancestryClusterKlustakwik = ConfigMachine( cpus = dataConfig.getObj("ancestryClusterKlustakwik").getInt("cpus"), mem = dataConfig.getObj("ancestryClusterKlustakwik").getInt("mem"), maxRunTime = dataConfig.getObj("ancestryClusterKlustakwik").getInt("maxRunTime") ),
    pca = ConfigMachine( cpus = dataConfig.getObj("pca").getInt("cpus"), mem = dataConfig.getObj("pca").getInt("mem"), maxRunTime = dataConfig.getObj("pca").getInt("maxRunTime") ),
    sampleQcHail = ConfigMachine( cpus = dataConfig.getObj("sampleQcHail").getInt("cpus"), mem = dataConfig.getObj("sampleQcHail").getInt("mem"), maxRunTime = dataConfig.getObj("sampleQcHail").getInt("maxRunTime") ),
    sampleQcKlustakwikPca = ConfigMachine( cpus = dataConfig.getObj("sampleQcKlustakwikPca").getInt("cpus"), mem = dataConfig.getObj("sampleQcKlustakwikPca").getInt("mem"), maxRunTime = dataConfig.getObj("sampleQcKlustakwikPca").getInt("maxRunTime") ),
    sampleQcKlustakwikMetric = ConfigMachine( cpus = dataConfig.getObj("sampleQcKlustakwikMetric").getInt("cpus"), mem = dataConfig.getObj("sampleQcKlustakwikMetric").getInt("mem"), maxRunTime = dataConfig.getObj("sampleQcKlustakwikMetric").getInt("maxRunTime") ),
    filterFinalHail = ConfigMachine( cpus = dataConfig.getObj("filterFinalHail").getInt("cpus"), mem = dataConfig.getObj("filterFinalHail").getInt("mem"), maxRunTime = dataConfig.getObj("filterFinalHail").getInt("maxRunTime") ),
    filterFinalPlink = ConfigMachine( cpus = dataConfig.getObj("filterFinalPlink").getInt("cpus"), mem = dataConfig.getObj("filterFinalPlink").getInt("mem"), maxRunTime = dataConfig.getObj("filterFinalPlink").getInt("maxRunTime") ),
    filterFinalPcair = ConfigMachine( cpus = dataConfig.getObj("filterFinalPcair").getInt("cpus"), mem = dataConfig.getObj("filterFinalPcair").getInt("mem"), maxRunTime = dataConfig.getObj("filterFinalPcair").getInt("maxRunTime") ),
    filterImputePlink = ConfigMachine( cpus = dataConfig.getObj("filterImputePlink").getInt("cpus"), mem = dataConfig.getObj("filterImputePlink").getInt("mem"), maxRunTime = dataConfig.getObj("filterImputePlink").getInt("maxRunTime") ),
    variantAssocHailAssoc = ConfigMachine( cpus = dataConfig.getObj("variantAssocHailAssoc").getInt("cpus"), mem = dataConfig.getObj("variantAssocHailAssoc").getInt("mem"), maxRunTime = dataConfig.getObj("variantAssocHailAssoc").getInt("maxRunTime") ),
    variantAssocGeneratePheno = ConfigMachine( cpus = dataConfig.getObj("variantAssocGeneratePheno").getInt("cpus"), mem = dataConfig.getObj("variantAssocGeneratePheno").getInt("mem"), maxRunTime = dataConfig.getObj("variantAssocGeneratePheno").getInt("maxRunTime") ),
    crossCohortPrepPlink = ConfigMachine( cpus = dataConfig.getObj("crossCohortPrepPlink").getInt("cpus"), mem = dataConfig.getObj("crossCohortPrepPlink").getInt("mem"), maxRunTime = dataConfig.getObj("crossCohortPrepPlink").getInt("maxRunTime") ),
    crossCohortKinshipPlink = ConfigMachine( cpus = dataConfig.getObj("crossCohortKinshipPlink").getInt("cpus"), mem = dataConfig.getObj("crossCohortKinshipPlink").getInt("mem"), maxRunTime = dataConfig.getObj("crossCohortKinshipPlink").getInt("maxRunTime") ),
    crossCohortKinshipKing = ConfigMachine( cpus = dataConfig.getObj("crossCohortKinshipKing").getInt("cpus"), mem = dataConfig.getObj("crossCohortKinshipKing").getInt("mem"), maxRunTime = dataConfig.getObj("crossCohortKinshipKing").getInt("maxRunTime") ),
    metaAnalysisHail = ConfigMachine( cpus = dataConfig.getObj("metaAnalysisHail").getInt("cpus"), mem = dataConfig.getObj("metaAnalysisHail").getInt("mem"), maxRunTime = dataConfig.getObj("metaAnalysisHail").getInt("maxRunTime") ),
    mergeAssocHail = ConfigMachine( cpus = dataConfig.getObj("mergeAssocHail").getInt("cpus"), mem = dataConfig.getObj("mergeAssocHail").getInt("mem"), maxRunTime = dataConfig.getObj("mergeAssocHail").getInt("maxRunTime") )
  ),

  // arrays
  Arrays = {

    for {
      array <- dataConfig.getObjList("arrays")
    } yield {

      ConfigArray(
        id = array.getStr("id"),
        filename = array.getStr("filename"),
        format = array.getStr("format"),
        technology = array.getStr("technology"),
        description = array.getStr("description"),
        minPartitions = if (array.isDefined("minPartitions")) { Some(array.getInt("minPartitions")) } else { None },
        liftOver = if (array.isDefined("liftOverChain")) { Some(array.getStr("liftOverChain")) } else { None },
        sampleQcMetrics = if (array.isDefined("sampleQcMetrics")) { dataConfig.getStrList("sampleQcMetrics") } else { array.getStr("technology") match { case "wes" | "wgs" => defaultSampleMetricsSeq; case _ => defaultSampleMetricsGwas } },
        nSampleMetricPcs = if (array.isDefined("nSampleMetricPcs")) { Some(array.getInt("nSampleMetricPcs")) } else { None },
        sampleMetricCovars = if (array.isDefined("sampleMetricCovars")) { Some(array.getStrList("sampleMetricCovars").mkString("+")) } else { None },
        xChr = array.getBool("xChr"),
        yChr = array.getBool("yChr"),
        mtChr = array.getBool("mtChr"),
        skipGh = array.getStrList("skipGh"),
        gqThreshold = if (array.isDefined("gqThreshold")) { Some(array.getInt("gqThreshold")) } else { None },
        qcVariantFilters = if(array.isDefined("qcVariantFilters")) {
          Some(ConfigVariantFilters(	
            call_rate = if (array.getObj("qcVariantFilters").isDefined("call_rate")) { Some(intervalToExpression("call_rate", array.getObj("qcVariantFilters").getStr("call_rate"))) } else { None },
            AC = if (array.getObj("qcVariantFilters").isDefined("AC")) { Some(intervalToExpression("AC", array.getObj("qcVariantFilters").getStr("AC"))) } else { None },
            AF = if (array.getObj("qcVariantFilters").isDefined("AF")) { Some(intervalToExpression("AF", array.getObj("qcVariantFilters").getStr("AF"))) } else { None },
            het = if (array.getObj("qcVariantFilters").isDefined("het")) { Some(intervalToExpression("het", array.getObj("qcVariantFilters").getStr("het"))) } else { None },
            avg_het_ab = if (array.getObj("qcVariantFilters").isDefined("avg_het_ab")) { Some(intervalToExpression("avg_het_ab", array.getObj("qcVariantFilters").getStr("avg_het_ab"))) } else { None },
            sample_n = if (array.getObj("qcVariantFilters").isDefined("sample_n")) { Some(array.getObj("qcVariantFilters").getInt("sample_n")) } else { None },
            sample_seed = if (array.getObj("qcVariantFilters").isDefined("sample_seed")) { Some(array.getObj("qcVariantFilters").getInt("sample_seed")) } else { None },
            AN = None,
            n_called = None,
            n_not_called = None,
            homozygote_count = None,
            n_het = None,
            n_non_ref = None,
            avg_ab = None,
            het_freq_hwe = None,
            p_value_hwe = None))
        } else {
          None
        },
        ancestryOutliersKeep = array.getStrList("ancestryOutliersKeep"),
        duplicatesKeep = array.getStrList("duplicatesKeep"),
        famsizeKeep = array.getStrList("famsizeKeep"),
        sampleqcKeep = array.getStrList("sampleqcKeep"),
        sexcheckKeep = array.getStrList("sexcheckKeep"),
        analysisSampleFilters = if(array.isDefined("analysisSampleFilters")) {
          Some(ConfigSampleFilters(
            n_non_ref = if (array.getObj("analysisSampleFilters").isDefined("n_non_ref")) { Some(intervalToExpression("n_non_ref", array.getObj("analysisSampleFilters").getStr("n_non_ref"))) } else { None },
            n_het = if (array.getObj("analysisSampleFilters").isDefined("n_het")) { Some(intervalToExpression("n_het", array.getObj("analysisSampleFilters").getStr("n_het"))) } else { None },
            n_called = if (array.getObj("analysisSampleFilters").isDefined("n_called")) { Some(intervalToExpression("n_called", array.getObj("analysisSampleFilters").getStr("n_called"))) } else { None },
            call_rate = if (array.getObj("analysisSampleFilters").isDefined("call_rate")) { Some(intervalToExpression("call_rate", array.getObj("analysisSampleFilters").getStr("call_rate"))) } else { None },
            n_singleton = if (array.getObj("analysisSampleFilters").isDefined("n_singleton")) { Some(intervalToExpression("n_singleton", array.getObj("analysisSampleFilters").getStr("n_singleton"))) } else { None },
            r_ti_tv = if (array.getObj("analysisSampleFilters").isDefined("r_ti_tv")) { Some(intervalToExpression("r_ti_tv", array.getObj("analysisSampleFilters").getStr("r_ti_tv"))) } else { None },
            het = if (array.getObj("analysisSampleFilters").isDefined("het")) { Some(intervalToExpression("het", array.getObj("analysisSampleFilters").getStr("het"))) } else { None },
            het_low = if (array.getObj("analysisSampleFilters").isDefined("het_low")) { Some(intervalToExpression("het_low", array.getObj("analysisSampleFilters").getStr("het_low"))) } else { None },
            het_high = if (array.getObj("analysisSampleFilters").isDefined("het_high")) { Some(intervalToExpression("het_high", array.getObj("analysisSampleFilters").getStr("het_high"))) } else { None },
            n_hom_var = if (array.getObj("analysisSampleFilters").isDefined("n_hom_var")) { Some(intervalToExpression("n_hom_var", array.getObj("analysisSampleFilters").getStr("n_hom_var"))) } else { None },
            r_het_hom_var = if (array.getObj("analysisSampleFilters").isDefined("r_het_hom_var")) { Some(intervalToExpression("r_het_hom_var", array.getObj("analysisSampleFilters").getStr("r_het_hom_var"))) } else { None },
            avg_ab = if (array.getObj("analysisSampleFilters").isDefined("avg_ab")) { Some(intervalToExpression("avg_ab", array.getObj("analysisSampleFilters").getStr("avg_ab"))) } else { None },
            avg_ab50 = if (array.getObj("analysisSampleFilters").isDefined("avg_ab50")) { Some(intervalToExpression("avg_ab50", array.getObj("analysisSampleFilters").getStr("avg_ab50"))) } else { None }))
        } else {
          None
        },
        analysisVariantFilters = if(array.isDefined("analysisVariantFilters")) {
          Some(ConfigVariantFilters(
            call_rate = if (array.getObj("analysisVariantFilters").isDefined("call_rate")) { Some(intervalToExpression("call_rate", array.getObj("analysisVariantFilters").getStr("call_rate"))) } else { None },
            AC = if (array.getObj("analysisVariantFilters").isDefined("AC")) { Some(intervalToExpression("AC", array.getObj("analysisVariantFilters").getStr("AC"))) } else { None },
            AF = if (array.getObj("analysisVariantFilters").isDefined("AF")) { Some(intervalToExpression("AF", array.getObj("analysisVariantFilters").getStr("AF"))) } else { None },
            AN = if (array.getObj("analysisVariantFilters").isDefined("AN")) { Some(intervalToExpression("AN", array.getObj("analysisVariantFilters").getStr("AN"))) } else { None },
            n_called = if (array.getObj("analysisVariantFilters").isDefined("n_called")) { Some(intervalToExpression("n_called", array.getObj("analysisVariantFilters").getStr("n_called"))) } else { None },
            n_not_called = if (array.getObj("analysisVariantFilters").isDefined("n_not_called")) { Some(intervalToExpression("n_not_called", array.getObj("analysisVariantFilters").getStr("n_not_called"))) } else { None },
            homozygote_count = if (array.getObj("analysisVariantFilters").isDefined("homozygote_count")) { Some(intervalToExpression("homozygote_count", array.getObj("analysisVariantFilters").getStr("homozygote_count"))) } else { None },
            n_het = if (array.getObj("analysisVariantFilters").isDefined("n_het")) { Some(intervalToExpression("n_het", array.getObj("analysisVariantFilters").getStr("n_het"))) } else { None },
            n_non_ref = if (array.getObj("analysisVariantFilters").isDefined("n_non_ref")) { Some(intervalToExpression("n_non_ref", array.getObj("analysisVariantFilters").getStr("n_non_ref"))) } else { None },
            avg_ab = if (array.getObj("analysisVariantFilters").isDefined("avg_ab")) { Some(intervalToExpression("avg_ab", array.getObj("analysisVariantFilters").getStr("avg_ab"))) } else { None },
            het_freq_hwe = if (array.getObj("analysisVariantFilters").isDefined("het_freq_hwe")) { Some(intervalToExpression("het_freq_hwe", array.getObj("analysisVariantFilters").getStr("het_freq_hwe"))) } else { None },
            p_value_hwe = if (array.getObj("analysisVariantFilters").isDefined("p_value_hwe")) { Some(intervalToExpression("p_value_hwe", array.getObj("analysisVariantFilters").getStr("p_value_hwe"))) } else { None },
            het = if (array.getObj("analysisVariantFilters").isDefined("het")) { Some(intervalToExpression("het", array.getObj("analysisVariantFilters").getStr("het"))) } else { None },
            avg_het_ab = if (array.getObj("analysisVariantFilters").isDefined("avg_het_ab")) { Some(intervalToExpression("avg_het_ab", array.getObj("analysisVariantFilters").getStr("avg_het_ab"))) } else { None },
            sample_n = if (array.getObj("analysisVariantFilters").isDefined("sample_n")) { Some(array.getObj("analysisVariantFilters").getInt("sample_n")) } else { None },
            sample_seed = if (array.getObj("analysisVariantFilters").isDefined("sample_seed")) { Some(array.getObj("analysisVariantFilters").getInt("sample_seed")) } else { None }))
        } else {
          None
        })

    }

  },

  Cohorts = {

    for {
      cohort <- dataConfig.getObjList("cohorts")
    } yield {

      ConfigCohort(
        id = cohort.getStr("id"),
        array = cohort.getStr("array"),
        ancestry = cohort.getStrList("ancestry"),
        minPartitions = if (cohort.isDefined("minPartitions")) { Some(cohort.getInt("minPartitions")) } else { None })

    }

  },

  Metas = {

    for {
      meta <- dataConfig.getObjList("metas")
    } yield {

      ConfigMeta(
        id = meta.getStr("id"),
        cohorts = meta.getStrList("cohorts"),
        minPartitions = if (meta.isDefined("minPartitions")) { Some(meta.getInt("minPartitions")) } else { None })

    }

  },

  Merges = {

    for {
      merge <- dataConfig.getObjList("merges")
    } yield {

      ConfigMerge(
        id = merge.getStr("id"),
        cohorts_metas = merge.getStrList("cohorts_metas"),
        minPartitions = if (merge.isDefined("minPartitions")) { Some(merge.getInt("minPartitions")) } else { None })

    }

  },

  Phenos = {

    for {
      pheno <- dataConfig.getObjList("phenos")
    } yield {

      ConfigPheno(
        id = pheno.getStr("id"),
        name = pheno.getStr("name"))

    }

  },

  Models = {

    for {
      model <- dataConfig.getObjList("models")
    } yield {

      ConfigModel(
        id = model.getStr("id"),
        pheno = model.getStr("pheno"),
        trans = model.getStr("trans"),
        test = model.getStr("test"),
        covars = model.getStrList("covars").mkString("+"))
    }

  },

  Knowns = {

    for {
      known <- dataConfig.getObjList("knowns")
    } yield {

      ConfigKnown(
        id = known.getStr("id"),
        data = known.getStr("data"),
        hiLd = known.getStr("hiLd"),
        n = if ( known.isDefined("n") ) { known.getStr("n") } else { "" },
        nCase = if ( known.isDefined("nCase") ) { known.getStr("nCase") } else { "" },
        nCtrl = if ( known.isDefined("nCtrl") ) { known.getStr("nCtrl") } else { "" },
        desc = known.getStr("desc"),
        citation = known.getStr("citation"))

    }

  },

  Reports = {

    for {
      report <- dataConfig.getObjList("reports")
    } yield {

      ConfigReport(
        id = report.getStr("id"),
        name = report.getStr("name"),
        sections = for {
          section <- report.getObjList("sections")
        } yield {

          ConfigSection(
            id = section.getStr("id"),
            title = section.getStr("title"),
            models = section.getStrList("models"),
            cohorts = if ( section.isDefined("cohorts") ) { Some(section.getStrList("cohorts")) } else { None },
            metas = if ( section.isDefined("metas") ) { Some(section.getStrList("metas")) } else { None },
            merges = if ( section.isDefined("merges") ) { Some(section.getStrList("merges")) } else { None },
            knowns = if ( section.isDefined("knowns") ) { Some(section.getStrList("knowns")) } else { None })
        
        })
    }

  }

)

final case class ArrayPheno(
    array: ConfigArray,
    pheno: ConfigPheno) {
  def canEqual(a: Any) = a.isInstanceOf[ArrayPheno]
  override def equals(that: Any): Boolean = that match {
    case that: ArrayPheno => that.canEqual(this) && this.hashCode == that.hashCode
    case _ => false
  }
  override def hashCode: Int = {
      val prime = 31
      var result = 1
      result = prime * result + array.id.hashCode
      result = prime * result + pheno.id.hashCode
      result
  }
}

final case class ModelCohort(
    model: ConfigModel,
    cohort: ConfigCohort) {
  def canEqual(a: Any) = a.isInstanceOf[ModelCohort]
  override def equals(that: Any): Boolean = that match {
    case that: ModelCohort => that.canEqual(this) && this.hashCode == that.hashCode
    case _ => false
  }
  override def hashCode: Int = {
      val prime = 31
      var result = 1
      result = prime * result + model.id.hashCode
      result = prime * result + cohort.id.hashCode
      result
  }
}

final case class PhenoCohort(
    pheno: ConfigPheno,
    cohort: ConfigCohort) {
  def canEqual(a: Any) = a.isInstanceOf[PhenoCohort]
  override def equals(that: Any): Boolean = that match {
    case that: PhenoCohort => that.canEqual(this) && this.hashCode == that.hashCode
    case _ => false
  }
  override def hashCode: Int = {
      val prime = 31
      var result = 1
      result = prime * result + pheno.id.hashCode
      result = prime * result + cohort.id.hashCode
      result
  }
}

final case class ModelCohortKnown(
    model: ConfigModel,
    cohort: ConfigCohort,
    known: ConfigKnown) {
  def canEqual(a: Any) = a.isInstanceOf[ModelCohortKnown]
  override def equals(that: Any): Boolean = that match {
    case that: ModelCohortKnown => that.canEqual(this) && this.hashCode == that.hashCode
    case _ => false
  }
  override def hashCode: Int = {
      val prime = 31
      var result = 1
      result = prime * result + model.id.hashCode
      result = prime * result + cohort.id.hashCode
      result = prime * result + known.id.hashCode
      result
  }
}

final case class ModelCohortMeta(
    model: ConfigModel,
    cohort: ConfigCohort,
    meta: ConfigMeta) {
  def canEqual(a: Any) = a.isInstanceOf[ModelCohortMeta]
  override def equals(that: Any): Boolean = that match {
    case that: ModelCohortMeta => that.canEqual(this) && this.hashCode == that.hashCode
    case _ => false
  }
  override def hashCode: Int = {
      val prime = 31
      var result = 1
      result = prime * result + model.id.hashCode
      result = prime * result + cohort.id.hashCode
      result = prime * result + meta.id.hashCode
      result
  }
}

final case class PhenoCohortMeta(
    pheno: ConfigPheno,
    cohort: ConfigCohort,
    meta: ConfigMeta) {
  def canEqual(a: Any) = a.isInstanceOf[PhenoCohortMeta]
  override def equals(that: Any): Boolean = that match {
    case that: PhenoCohortMeta => that.canEqual(this) && this.hashCode == that.hashCode
    case _ => false
  }
  override def hashCode: Int = {
      val prime = 31
      var result = 1
      result = prime * result + pheno.id.hashCode
      result = prime * result + cohort.id.hashCode
      result = prime * result + meta.id.hashCode
      result
  }
}

final case class ModelCohortMetaKnown(
    model: ConfigModel,
    cohort: ConfigCohort,
    meta: ConfigMeta,
    known: ConfigKnown) {
  def canEqual(a: Any) = a.isInstanceOf[ModelCohortMetaKnown]
  override def equals(that: Any): Boolean = that match {
    case that: ModelCohortMetaKnown => that.canEqual(this) && this.hashCode == that.hashCode
    case _ => false
  }
  override def hashCode: Int = {
      val prime = 31
      var result = 1
      result = prime * result + model.id.hashCode
      result = prime * result + cohort.id.hashCode
      result = prime * result + meta.id.hashCode
      result = prime * result + known.id.hashCode
      result
  }
}

final case class ModelMeta(
    model: ConfigModel,
    meta: ConfigMeta) {
  def canEqual(a: Any) = a.isInstanceOf[ModelMeta]
  override def equals(that: Any): Boolean = that match {
    case that: ModelMeta => that.canEqual(this) && this.hashCode == that.hashCode
    case _ => false
  }
  override def hashCode: Int = {
      val prime = 31
      var result = 1
      result = prime * result + model.id.hashCode
      result = prime * result + meta.id.hashCode
      result
  }
}

final case class ModelMerge(
    model: ConfigModel,
    merge: ConfigMerge) {
  def canEqual(a: Any) = a.isInstanceOf[ModelMerge]
  override def equals(that: Any): Boolean = that match {
    case that: ModelMerge => that.canEqual(this) && this.hashCode == that.hashCode
    case _ => false
  }
  override def hashCode: Int = {
      val prime = 31
      var result = 1
      result = prime * result + model.id.hashCode
      result = prime * result + merge.id.hashCode
      result
  }
}

final case class ModelMetaKnown(
    model: ConfigModel,
    meta: ConfigMeta,
    known: ConfigKnown) {
  def canEqual(a: Any) = a.isInstanceOf[ModelMetaKnown]
  override def equals(that: Any): Boolean = that match {
    case that: ModelMetaKnown => that.canEqual(this) && this.hashCode == that.hashCode
    case _ => false
  }
  override def hashCode: Int = {
      val prime = 31
      var result = 1
      result = prime * result + model.id.hashCode
      result = prime * result + meta.id.hashCode
      result = prime * result + known.id.hashCode
      result
  }
}

final case class ModelMergeKnown(
    model: ConfigModel,
    merge: ConfigMerge,
    known: ConfigKnown) {
  def canEqual(a: Any) = a.isInstanceOf[ModelMergeKnown]
  override def equals(that: Any): Boolean = that match {
    case that: ModelMergeKnown => that.canEqual(this) && this.hashCode == that.hashCode
    case _ => false
  }
  override def hashCode: Int = {
      val prime = 31
      var result = 1
      result = prime * result + model.id.hashCode
      result = prime * result + merge.id.hashCode
      result = prime * result + known.id.hashCode
      result
  }
}

val cohorts: Seq[ConfigCohort] = {

  val x = for {
    section <- projectConfig.Reports.flatMap(e => e.sections).filter(e => e.cohorts.isDefined)
  } yield {
   
    for {
      c <- section.cohorts.get
    } yield {
      projectConfig.Cohorts.filter(e => e.id == c).head
    }
  
  }

  val y = for {
    section <- projectConfig.Reports.flatMap(e => e.sections).filter(e => e.merges.isDefined)
  } yield {
   
    for {
      g <- section.merges.get
      c <- projectConfig.Merges.filter(e => e.id == g).head.cohorts_metas if projectConfig.Cohorts.filter(e => e.id == c).size > 0
    } yield {
      projectConfig.Cohorts.filter(e => e.id == c).head
    }
  
  }
  x ++ y

}.flatten.distinct

val modelCohorts: Seq[ModelCohort] = {

  val x = for {
    section <- projectConfig.Reports.flatMap(e => e.sections).filter(e => e.cohorts.isDefined)
  } yield {
   
    for {
      m <- section.models
      c <- section.cohorts.get
    } yield {
      ModelCohort(
        model = projectConfig.Models.filter(e => e.id == m).head,
        cohort = projectConfig.Cohorts.filter(e => e.id == c).head)
    }
  
  }

  val y = for {
    section <- projectConfig.Reports.flatMap(e => e.sections).filter(e => e.merges.isDefined)
  } yield {
   
    for {
      m <- section.models
      g <- section.merges.get
      c <- projectConfig.Merges.filter(e => e.id == g).head.cohorts_metas if projectConfig.Cohorts.filter(e => e.id == c).size > 0
    } yield {
      ModelCohort(
        model = projectConfig.Models.filter(e => e.id == m).head,
        cohort = projectConfig.Cohorts.filter(e => e.id == c).head)
    }
  
  }
  x ++ y

}.flatten.distinct

val phenoCohorts: Seq[PhenoCohort] = {

  val x = for {
    section <- projectConfig.Reports.flatMap(e => e.sections).filter(e => e.cohorts.isDefined)
  } yield {
   
    for {
      m <- section.models
      c <- section.cohorts.get
    } yield {
      PhenoCohort(
        pheno = projectConfig.Phenos.filter(e => e.id == projectConfig.Models.filter(e => e.id == m).head.pheno).head,
        cohort = projectConfig.Cohorts.filter(e => e.id == c).head)
    }
  
  }

  val y = for {
    section <- projectConfig.Reports.flatMap(e => e.sections).filter(e => e.merges.isDefined)
  } yield {
   
    for {
      m <- section.models
      g <- section.merges.get
      c <- projectConfig.Merges.filter(e => e.id == g).head.cohorts_metas if projectConfig.Cohorts.filter(e => e.id == c).size > 0
    } yield {
      PhenoCohort(
        pheno = projectConfig.Phenos.filter(e => e.id == projectConfig.Models.filter(e => e.id == m).head.pheno).head,
        cohort = projectConfig.Cohorts.filter(e => e.id == c).head)
    }
  
  }
  x ++ y

}.flatten.distinct

val modelCohortKnowns: Seq[ModelCohortKnown] = {

  val x = for {
    section <- projectConfig.Reports.flatMap(e => e.sections).filter(e => e.cohorts.isDefined && e.knowns.isDefined)
  } yield {
   
    for {
      m <- section.models
      c <- section.cohorts.get
      k <- section.knowns.get
    } yield {
      ModelCohortKnown(
        model = projectConfig.Models.filter(e => e.id == m).head,
        cohort = projectConfig.Cohorts.filter(e => e.id == c).head,
        known = projectConfig.Knowns.filter(e => e.id == k).head)
    }

  }

  val y = for {
    section <- projectConfig.Reports.flatMap(e => e.sections).filter(e => e.merges.isDefined && e.knowns.isDefined)
  } yield {
   
    for {
      m <- section.models
      g <- section.merges.get
      c <- projectConfig.Merges.filter(e => e.id == g).head.cohorts_metas if projectConfig.Cohorts.filter(e => e.id == c).size > 0
      k <- section.knowns.get
    } yield {
      ModelCohortKnown(
        model = projectConfig.Models.filter(e => e.id == m).head,
        cohort = projectConfig.Cohorts.filter(e => e.id == c).head,
        known = projectConfig.Knowns.filter(e => e.id == k).head)
    }
  
  }
  x ++ y

}.flatten.distinct

val modelCohortMetas: Seq[ModelCohortMeta] = {

  val x = for {
    section <- projectConfig.Reports.flatMap(e => e.sections).filter(e => e.metas.isDefined)
  } yield {
   
    for {
      m <- section.models
      t <- section.metas.get
      c <- projectConfig.Metas.filter(e => e.id == t).head.cohorts
    } yield {
      ModelCohortMeta(
        model = projectConfig.Models.filter(e => e.id == m).head,
        meta = projectConfig.Metas.filter(e => e.id == t).head,
        cohort = projectConfig.Cohorts.filter(e => e.id == c).head)
    }
  
  }

  val y = for {
    section <- projectConfig.Reports.flatMap(e => e.sections).filter(e => e.merges.isDefined)
  } yield {
   
    for {
      m <- section.models
      g <- section.merges.get
      t <- projectConfig.Merges.filter(e => e.id == g).head.cohorts_metas if projectConfig.Metas.filter(e => e.id == t).size > 0
      c <- projectConfig.Cohorts.filter(e => projectConfig.Metas.filter(e => e.id == t).head.cohorts contains e.id).map(e => e.id)
    } yield {
      ModelCohortMeta(
        model = projectConfig.Models.filter(e => e.id == m).head,
        meta = projectConfig.Metas.filter(e => e.id == t).head,
        cohort = projectConfig.Cohorts.filter(e => e.id == c).head)
    }
  
  }
  x ++ y

}.flatten.distinct

val phenoCohortMetas: Seq[PhenoCohortMeta] = {

  val x = for {
    section <- projectConfig.Reports.flatMap(e => e.sections).filter(e => e.metas.isDefined)
  } yield {
   
    for {
      m <- section.models
      t <- section.metas.get
      c <- projectConfig.Metas.filter(e => e.id == t).head.cohorts
    } yield {
      PhenoCohortMeta(
        pheno = projectConfig.Phenos.filter(e => e.id == projectConfig.Models.filter(e => e.id == m).head.pheno).head,
        meta = projectConfig.Metas.filter(e => e.id == t).head,
        cohort = projectConfig.Cohorts.filter(e => e.id == c).head)
    }
  
  }

  val y = for {
    section <- projectConfig.Reports.flatMap(e => e.sections).filter(e => e.merges.isDefined)
  } yield {
   
    for {
      m <- section.models
      g <- section.merges.get
      t <- projectConfig.Merges.filter(e => e.id == g).head.cohorts_metas if projectConfig.Metas.filter(e => e.id == t).size > 0
      c <- projectConfig.Cohorts.filter(e => projectConfig.Metas.filter(e => e.id == t).head.cohorts contains e.id).map(e => e.id)
    } yield {
      PhenoCohortMeta(
        pheno = projectConfig.Phenos.filter(e => e.id == projectConfig.Models.filter(e => e.id == m).head.pheno).head,
        meta = projectConfig.Metas.filter(e => e.id == t).head,
        cohort = projectConfig.Cohorts.filter(e => e.id == c).head)
    }
  
  }
  x ++ y

}.flatten.distinct

val modelCohortMetaKnowns: Seq[ModelCohortMetaKnown] = {

  val x = for {
    section <- projectConfig.Reports.flatMap(e => e.sections).filter(e => e.metas.isDefined && e.knowns.isDefined)
  } yield {
   
    for {
      m <- section.models
      t <- section.metas.get
      c <- projectConfig.Metas.filter(e => e.id == t).head.cohorts
      k <- section.knowns.get
    } yield {
      ModelCohortMetaKnown(
        model = projectConfig.Models.filter(e => e.id == m).head,
        meta = projectConfig.Metas.filter(e => e.id == t).head,
        cohort = projectConfig.Cohorts.filter(e => e.id == c).head,
        known = projectConfig.Knowns.filter(e => e.id == k).head)
    }

  }

  val y = for {
    section <- projectConfig.Reports.flatMap(e => e.sections).filter(e => e.merges.isDefined && e.knowns.isDefined)
  } yield {
   
    for {
      m <- section.models
      g <- section.merges.get
      t <- projectConfig.Merges.filter(e => e.id == g).head.cohorts_metas if projectConfig.Metas.filter(e => e.id == t).size > 0
      c <- projectConfig.Cohorts.filter(e => projectConfig.Metas.filter(e => e.id == t).head.cohorts contains e.id).map(e => e.id)
      k <- section.knowns.get
    } yield {
      ModelCohortMetaKnown(
        model = projectConfig.Models.filter(e => e.id == m).head,
        meta = projectConfig.Metas.filter(e => e.id == t).head,
        cohort = projectConfig.Cohorts.filter(e => e.id == c).head,
        known = projectConfig.Knowns.filter(e => e.id == k).head)
    }
  
  }
  x ++ y

}.flatten.distinct

val models: Seq[ConfigModel] = {

  for {
    section <- projectConfig.Reports.flatMap(e => e.sections)
  } yield {
    for {
      m <- section.models
    } yield {
      projectConfig.Models.filter(e => e.id == m).head
    }
  }

}.flatten.distinct

val phenos: Seq[ConfigPheno] = {

  for {
    m <- models
  } yield {
    projectConfig.Phenos.filter(e => e.id == m.pheno).head
  }

}.distinct

val metas: Seq[ConfigMeta] = {

  val x = for {
    section <- projectConfig.Reports.flatMap(e => e.sections).filter(e => e.metas.isDefined)
  } yield {
    for {
      t <- section.metas.get
    } yield {
      projectConfig.Metas.filter(e => e.id == t).head
    }
  }

  val y = for {
    section <- projectConfig.Reports.flatMap(e => e.sections).filter(e => e.merges.isDefined)
  } yield {
    for {
      g <- section.merges.get
      t <- projectConfig.Merges.filter(e => e.id == g).head.cohorts_metas if projectConfig.Metas.filter(e => e.id == t).size > 0
    } yield {
      projectConfig.Metas.filter(e => e.id == t).head
    }
  }
  x ++ y

}.flatten.distinct

val merges: Seq[ConfigMerge] = {

  for {
    section <- projectConfig.Reports.flatMap(e => e.sections).filter(e => e.merges.isDefined)
  } yield {
    for {
      m <- section.merges.get
    } yield {
      projectConfig.Merges.filter(e => e.id == m).head
    }
  }

}.flatten.distinct

val knowns: Seq[ConfigKnown] = {

  for {
    section <- projectConfig.Reports.flatMap(e => e.sections).filter(e => e.knowns.isDefined)
  } yield {
    for {
      k <- section.knowns.get
    } yield {
      projectConfig.Knowns.filter(e => e.id == k).head
    }
  }

}.flatten.distinct

val modelMetas: Seq[ModelMeta] = {

  val x = for {
    section <- projectConfig.Reports.flatMap(e => e.sections).filter(e => e.metas.isDefined)
  } yield {
    for {
      m <- section.models
      t <- section.metas.get
    } yield {
      ModelMeta(
        model = projectConfig.Models.filter(e => e.id == m).head,
        meta = projectConfig.Metas.filter(e => e.id == t).head)
    }
  }

  val y = for {
    section <- projectConfig.Reports.flatMap(e => e.sections).filter(e => e.merges.isDefined)
  } yield {
    for {
      m <- section.models
      g <- section.merges.get
      t <- projectConfig.Merges.filter(e => e.id == g).head.cohorts_metas if projectConfig.Metas.filter(e => e.id == t).size > 0
    } yield {
      ModelMeta(
        model = projectConfig.Models.filter(e => e.id == m).head,
        meta = projectConfig.Metas.filter(e => e.id == t).head)
    }
  }
  x ++ y

}.flatten.distinct

val modelMerges: Seq[ModelMerge] = {

  for {
    section <- projectConfig.Reports.flatMap(e => e.sections).filter(e => e.merges.isDefined)
  } yield {
    for {
      m <- section.models
      t <- section.merges.get
    } yield {
      ModelMerge(
        model = projectConfig.Models.filter(e => e.id == m).head,
        merge = projectConfig.Merges.filter(e => e.id == t).head)
    }
  }

}.flatten.distinct

val modelMetaKnowns: Seq[ModelMetaKnown] = {

  val x = for {
    section <- projectConfig.Reports.flatMap(e => e.sections).filter(e => e.metas.isDefined && e.knowns.isDefined)
  } yield {
    for {
      m <- section.models
      t <- section.metas.get
      k <- section.knowns.get
    } yield {
      ModelMetaKnown(
        model = projectConfig.Models.filter(e => e.id == m).head,
        meta = projectConfig.Metas.filter(e => e.id == t).head,
        known = projectConfig.Knowns.filter(e => e.id == k).head)
    }
  }

  val y = for {
    section <- projectConfig.Reports.flatMap(e => e.sections).filter(e => e.merges.isDefined && e.knowns.isDefined)
  } yield {
    for {
      m <- section.models
      g <- section.merges.get
      t <- projectConfig.Merges.filter(e => e.id == g).head.cohorts_metas if projectConfig.Metas.filter(e => e.id == t).size > 0
      k <- section.knowns.get
    } yield {
      ModelMetaKnown(
        model = projectConfig.Models.filter(e => e.id == m).head,
        meta = projectConfig.Metas.filter(e => e.id == t).head,
        known = projectConfig.Knowns.filter(e => e.id == k).head)
    }
  }
  x ++ y

}.flatten.distinct

val modelMergeKnowns: Seq[ModelMergeKnown] = {

  for {
    section <- projectConfig.Reports.flatMap(e => e.sections).filter(e => e.merges.isDefined && e.knowns.isDefined)
  } yield {
    for {
      m <- section.models
      t <- section.merges.get
      k <- section.knowns.get
    } yield {
      ModelMergeKnown(
        model = projectConfig.Models.filter(e => e.id == m).head,
        merge = projectConfig.Merges.filter(e => e.id == t).head,
        known = projectConfig.Knowns.filter(e => e.id == k).head)
    }
  }

}.flatten.distinct

val cohortsList: Seq[ConfigCohort] = {

  val w = for {
    section <- projectConfig.Reports.flatMap(e => e.sections).filter(e => e.cohorts.isDefined)
  } yield {
   
    for {
      c <- section.cohorts.get
    } yield {
      projectConfig.Cohorts.filter(e => e.id == c).head
    }
  
  }

  val x = for {
    section <- projectConfig.Reports.flatMap(e => e.sections).filter(e => e.metas.isDefined)
  } yield {
   
    for {
      t <- section.metas.get
      c <- projectConfig.Metas.filter(e => e.id == t).head.cohorts
    } yield {
      projectConfig.Cohorts.filter(e => e.id == c).head
    }
  
  }

  val y = for {
    section <- projectConfig.Reports.flatMap(e => e.sections).filter(e => e.merges.isDefined)
  } yield {
   
    for {
      g <- section.merges.get
      c <- projectConfig.Merges.filter(e => e.id == g).head.cohorts_metas if projectConfig.Cohorts.filter(e => e.id == c).size > 0
    } yield {
      projectConfig.Cohorts.filter(e => e.id == c).head
    }
  
  }

  val z = for {
    section <- projectConfig.Reports.flatMap(e => e.sections).filter(e => e.merges.isDefined)
  } yield {
   
    for {
      g <- section.merges.get
      t <- projectConfig.Merges.filter(e => e.id == g).head.cohorts_metas if projectConfig.Metas.filter(e => e.id == t).size > 0
      c <- projectConfig.Metas.filter(e => e.id == t).head.cohorts
    } yield {
      projectConfig.Cohorts.filter(e => e.id == c).head
    }
  
  }

  w ++ x ++ y ++ z

}.flatten.distinct

val cohortsReport: Seq[ConfigCohort] = {

  for {
    section <- projectConfig.Reports.flatMap(e => e.sections).filter(e => e.cohorts.isDefined)
  } yield {
    for {
      c <- section.cohorts.get
    } yield {
      projectConfig.Cohorts.filter(e => e.id == c).head
    }
  }

}.flatten.distinct

val metasReport: Seq[ConfigMeta] = {

  for {
    section <- projectConfig.Reports.flatMap(e => e.sections).filter(e => e.metas.isDefined)
  } yield {
    for {
      t <- section.metas.get
    } yield {
      projectConfig.Metas.filter(e => e.id == t).head
    }
  }

}.flatten.distinct

val modelCohortsReport: Seq[ModelCohort] = {

  for {
    section <- projectConfig.Reports.flatMap(e => e.sections).filter(e => e.cohorts.isDefined)
  } yield {
    for {
      m <- section.models
      c <- section.cohorts.get
    } yield {
      ModelCohort(
        model = projectConfig.Models.filter(e => e.id == m).head,
        cohort = projectConfig.Cohorts.filter(e => e.id == c).head)
    }
  }

}.flatten.distinct

val modelCohortKnownsReport: Seq[ModelCohortKnown] = {

  for {
    section <- projectConfig.Reports.flatMap(e => e.sections).filter(e => e.cohorts.isDefined && e.knowns.isDefined)
  } yield {
    for {
      m <- section.models
      c <- section.cohorts.get
      k <- section.knowns.get
    } yield {
      ModelCohortKnown(
        model = projectConfig.Models.filter(e => e.id == m).head,
        cohort = projectConfig.Cohorts.filter(e => e.id == c).head,
        known = projectConfig.Knowns.filter(e => e.id == k).head)
    }
  }

}.flatten.distinct

val modelMetasReport: Seq[ModelMeta] = {

  for {
    section <- projectConfig.Reports.flatMap(e => e.sections).filter(e => e.metas.isDefined)
  } yield {
    for {
      m <- section.models
      t <- section.metas.get
    } yield {
      ModelMeta(
        model = projectConfig.Models.filter(e => e.id == m).head,
        meta = projectConfig.Metas.filter(e => e.id == t).head)
    }
  }

}.flatten.distinct

val modelMetaKnownsReport: Seq[ModelMetaKnown] = {

  for {
    section <- projectConfig.Reports.flatMap(e => e.sections).filter(e => e.metas.isDefined && e.knowns.isDefined)
  } yield {
    for {
      m <- section.models
      t <- section.metas.get
      k <- section.knowns.get
    } yield {
      ModelMetaKnown(
        model = projectConfig.Models.filter(e => e.id == m).head,
        meta = projectConfig.Metas.filter(e => e.id == t).head,
        known = projectConfig.Knowns.filter(e => e.id == k).head)
    }
  }

}.flatten.distinct
