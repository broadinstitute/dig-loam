import Fxns._
import loamstream.googlecloud.ClusterConfig

val refGenomes = Seq("GRCh37","GRCh38")
val ancestryCodes = Seq("EUR","AFR","AMR","SAS","EAS")
val gwasTech = Seq("gwas")
val seqTech = Seq("wgs","wes")
val arrayFormats = Seq("plink","vcf")

val inputTypesPlink = {
  (for {
    x <- gwasTech
    y <- Seq("plink")
  } yield {
    (x, y)
  }) ++
  (for {
    x <- seqTech
    y <- Seq("plink")
  } yield {
    (x, y)
  })
}

val inputTypesGwasVcf = for {
  x <- gwasTech
  y <- Seq("vcf")
} yield {
  (x, y)
}

val inputTypesSeqPlink = for {
  x <- seqTech
  y <- Seq("plink")
} yield {
  (x, y)
}

val inputTypesSeqVcf = for {
  x <- seqTech
  y <- Seq("vcf")
} yield {
  (x, y)
}

val defaultSampleMetricsGwas = Seq(
  "n_non_ref",
  "n_het",
  "n_called",
  "call_rate",
  "r_ti_tv",
  "het",
  "het_low",
  "het_high",
  "n_hom_var",
  "r_het_hom_var"
)
val defaultSampleMetricsSeq = defaultSampleMetricsGwas ++ Seq(
  "n_singleton",
  "avg_ab",
  "avg_ab50"
)
val modelDesigns = Seq("full","strat")
val modelTrans = Seq("log","invn")
val assocTests = Seq(
  "hail.q.lm",
  "hail.b.wald",
  "hail.b.firth",
  "hail.b.lrt",
  "hail.b.score",
  "epacts.b.collapse",
  "epacts.b.madsen",
  "epacts.b.wcnt",
  "epacts.q.reverse",
  "epacts.q.wilcox",
  "epacts.b.skat",
  "epacts.b.VT",
  "epacts.b.emmaxCMC",
  "epacts.b.emmaxVT",
  "epacts.q.mmskat",
  "epacts.q.skat",
  "epacts.q.VT",
  "epacts.q.emmaxCMC",
  "epacts.q.emmaxVT"
)

val binaryAssocTests = assocTests.filter(e => e.split("\\.")(1) == "b")
val quantitativeAssocTests = assocTests.filter(e => e.split("\\.")(1) == "q")
val famTests = assocTests.filter(e => e.split("\\.")(2).startsWith("emmax"))
val groupTests = assocTests.filter(e => e.split("\\.")(0) == "epacts")
val nonHailTests = assocTests.filter(e => e.split("\\.")(0) != "hail")

final case class ConfigMachine(
  cpus: Int,
  mem: Int,
  maxRunTime: Int) extends Debug

final case class ConfigNumericFilters(
  id: String,
  field: String,
  range: String,
  expression: String) extends Debug

final case class ConfigBooleanFilters(
  id: String,
  field: String,
  value: Boolean,
  expression: String) extends Debug

final case class ConfigCategoricalFilters(
  id: String,
  field: String,
  values: Seq[String],
  expression: String) extends Debug

final case class ConfigCompoundFilters(
  id: String,
  filters: Seq[String],
  expression: String) extends Debug

final case class ConfigCloudResources(
  mtCluster: ClusterConfig,
  variantHtCluster: ClusterConfig) extends Debug

final case class ConfigResources(
  preparePlink: ConfigMachine,
  prepareFindBestDuplicateVariants: ConfigMachine,
  prepareLiftOver: ConfigMachine,
  harmonizePlinkFull: ConfigMachine,
  harmonizeGenotypeHarmonizer: ConfigMachine,
  harmonizeAlignNon1kgVariants: ConfigMachine,
  harmonizePlinkChr: ConfigMachine,
  loadHail: ConfigMachine,
  filterHail: ConfigMachine,
  prunePlink: ConfigMachine,
  annotate: ConfigMachine,
  annotateHailLoad: ConfigMachine,
  kinshipKing: ConfigMachine,
  ancestryPcaHail: ConfigMachine,
  ancestryPcaPlink: ConfigMachine,
  ancestryPcaFlashPca: ConfigMachine,
  ancestryClusterKlustakwik: ConfigMachine,
  pca: ConfigMachine,
  sampleQcHail: ConfigMachine,
  sampleQcKlustakwikPca: ConfigMachine,
  sampleQcKlustakwikMetric: ConfigMachine,
  filterFinalHail: ConfigMachine,
  exportCleanHail: ConfigMachine,
  tabixClean: ConfigMachine,
  filterImputePlink: ConfigMachine,
  filterModelVariantsHail: ConfigMachine,
  variantAssocHailAssoc: ConfigMachine,
  generatePheno: ConfigMachine,
  crossCohortPrepPlink: ConfigMachine,
  crossCohortKinshipPlink: ConfigMachine,
  crossCohortKinshipKing: ConfigMachine,
  metaAnalysisHail: ConfigMachine,
  mergeAssocHail: ConfigMachine) extends Debug

final case class ConfigArray(
  id: String,
  filename: String,
  format: String,
  technology: String,
  description: String,
  keepIndels: Boolean,
  minPartitions: Option[Int],
  liftOver: Option[String] = None,
  sampleQcMetrics: Seq[String],
  nSampleMetricPcs: Option[Int],
  sampleMetricCovars: Option[String],
  chrs: Seq[String],
  gqThreshold: Option[Int],
  ancestryOutliersKeep: Option[Seq[String]],
  duplicatesKeep: Option[Seq[String]],
  famsizeKeep: Option[Seq[String]],
  sampleqcKeep: Option[Seq[String]],
  sexcheckKeep: Option[Seq[String]],
  qcVariantFilters: Option[Seq[String]],
  qcVariantSampleN: Option[Int],
  qcVariantSampleSeed: Option[Int],
  postQcSampleFilters: Option[Seq[String]],
  postQcVariantFilters: Option[Seq[String]],
  exportCleanVcf: Boolean) extends Debug

final case class ConfigCohort(
  id: String,
  array: String,
  ancestry: Seq[String],
  stratCol: Option[String],
  stratCodes: Option[Seq[String]],
  minPartitions: Option[Int]) extends Debug

final case class ConfigMeta(
  id: String,
  cohorts: Seq[String],
  minPartitions: Option[Int]) extends Debug

final case class ConfigMerge(
  id: String,
  cohorts_metas: Seq[String],
  minPartitions: Option[Int]) extends Debug

final case class ConfigPheno(
  id: String,
  name: String,
  desc: String) extends Debug

final case class ConfigKnown(
  id: String,
  data: String,
  hiLd: String,
  n: String,
  nCase: String,
  nCtrl: String,
  desc: String,
  citation: String) extends Debug

final case class CohortFilter(
  cohort: String,
  filters: Seq[String])

final case class MaskFilter(
  id: String,
  filters: Seq[String])

final case class ConfigModel(
  id: String,
  pheno: String,
  unrelatedOnly: Boolean,
  trans: Option[String],
  test: String,
  covars: String,
  design: String,
  cohorts: Seq[String],
  metas: Option[Seq[String]],
  merges: Option[Seq[String]],
  filters: Option[Seq[String]],
  maxPcaOutlierIterations: Int,
  cohortFilters: Option[Seq[CohortFilter]],
  knockoutFilters: Option[Seq[CohortFilter]],
  masks: Option[Seq[MaskFilter]],
  knowns: Option[Seq[String]]) extends Debug

final case class ConfigSection(
  id: String,
  title: String,
  models: Seq[String]) extends Debug

final case class ConfigReport(
  id: String,
  name: String,
  sections: Seq[ConfigSection]) extends Debug

final case class ProjectConfig(
  loamstreamVersion: String,
  pipelineVersion: String,
  hailCloud: Boolean,
  cloudShare: Option[URI],
  cloudHome: Option[URI],
  projectId: String,
  referenceGenome: String,
  regionsExclude: String,
  genePositions: String,
  kgPurcellVcf: String,
  kgSample: String,
  kgSampleId: String,
  kgSamplePop: String,
  kgSampleGroup: String,
  kgVcf: String,
  kgIds: String,
  humanReferenceWild: String,
  fasta: String,
  vepCacheDir: String,
  vepPluginsDir: String,
  dbNSFP: String,
  sampleFile: String,
  sampleFileId: String,
  sampleFileSrSex: String,
  sampleFileMaleCode: String,
  sampleFileFemaleCode: String,
  sampleFileSrRace: String,
  sampleFileAFRCodes: Option[Seq[String]],
  sampleFileAMRCodes: Option[Seq[String]],
  sampleFileEURCodes: Option[Seq[String]],
  sampleFileEASCodes: Option[Seq[String]],
  sampleFileSASCodes: Option[Seq[String]],
  phenoFile: String,
  phenoFileId: String,
  authors: Seq[String],
  email: String,
  organization: String,
  acknowledgementsAnalysisReport: Option[Seq[String]],
  acknowledgementsQcReport: Option[Seq[String]],
  nAncestryInferenceFeatures: Int,
  ancestryInferenceFeatures: String,
  minPCs: Int,
  maxPCs: Int,
  nStddevs: Int,
  cloudResources: ConfigCloudResources,
  resources: ConfigResources,
  nArrays: Int,
  nCohorts: Int,
  nMetas: Int,
  maxSigRegions: Option[Int],
  numericVariantFilters: Seq[ConfigNumericFilters],
  booleanVariantFilters: Seq[ConfigBooleanFilters],
  categoricalVariantFilters: Seq[ConfigCategoricalFilters],
  compoundVariantFilters: Seq[ConfigCompoundFilters],
  numericSampleFilters: Seq[ConfigNumericFilters],
  booleanSampleFilters: Seq[ConfigBooleanFilters],
  categoricalSampleFilters: Seq[ConfigCategoricalFilters],
  compoundSampleFilters: Seq[ConfigCompoundFilters],
  Arrays: Seq[ConfigArray],
  Cohorts: Seq[ConfigCohort],
  Metas: Seq[ConfigMeta],
  Merges: Seq[ConfigMerge],
  Phenos: Seq[ConfigPheno],
  Models: Seq[ConfigModel],
  Knowns: Seq[ConfigKnown],
  Reports: Seq[ConfigReport]) extends Debug

final case class Image(
  imgHail: Path,
  imgLocuszoom: Path,
  imgPython2: Path,
  imgR: Path,
  imgTools: Path,
  imgTexLive: Path,
  imgEnsemblVep: Path,
  imgFlashPca: Path) extends Debug

final case class Binary(
  binLiftOver: Path,
  binGenotypeHarmonizer: Path,
  binKing: Path,
  binPlink: Path,
  binTabix: Path,
  binGhostscript: Path,
  binKlustakwik: Path,
  binPython: Path,
  binLocuszoom: Path,
  binPdflatex: Path,
  binRscript: Path,
  binFlashPca: Path) extends Debug

final case class Python(
  pyAlignNon1kgVariants: Path,
  pyHailLoad: Path,
  pyHailLoadAnnotations: Path,
  pyHailExportQcData: Path,
  pyHailFilter: Path,
  pyHailAncestryPcaMerge1kg: Path,
  pyHailPcaMerge1kg: Path,
  pyHailSampleqc: Path,
  pyMakeSamplesRestoreTable: Path,
  pyCompileExclusions: Path,
  pyMergeVariantLists: Path,
  pyBimToUid: Path,
  pyHailUtils: Path,
  pyHailFilterModelVariants: Path,
  pyHailAssoc: Path,
  pyHailExportCleanArrayData: Path
  //pyHailFilterResults: Path,
  //pyHailMerge: Path,
  //pyHailMetaAnalysis: Path,
  //pyQqPlot: Path,
  //pyMhtPlot: Path,
  //pyExtractTopRegions: Path,
  //pyGenerateReportHeader: Path,
  //pyGenerateQcReportIntro: Path,
  //pyGenerateQcReportData: Path,
  //pyGenerateQcReportAncestry: Path,
  //pyGenerateQcReportIbdSexcheck: Path,
  //pyGenerateQcReportSampleqc: Path,
  //pyGenerateQcReportVariantqc: Path,
  //pyGenerateQcReportBibliography: Path,
  //pyGenerateAnalysisReportIntro: Path,
  //pyGenerateAnalysisReportData: Path,
  //pyGenerateAnalysisReportStrategy: Path,
  //pyGenerateAnalysisReportPhenoSummary: Path,
  //pyGenerateAnalysisReportPhenoCalibration: Path,
  //pyGenerateAnalysisReportPhenoTopLoci: Path,
  //pyGenerateAnalysisReportPhenoKnownLoci: Path,
  //pyGenerateAnalysisReportBibliography: Path,
  //pyTop1000: Path,
  //pyAddGeneAnnot: Path,
  //pyPhenoDistPlot: Path
  ) extends Debug

final case class Bash(
  shFindPossibleDuplicateVariants: Path,
  shAnnotate: Path,
  shKing: Path,
  shPlinkPrepare: Path,
  shPlinkToVcfNoHalfCalls: Path,
  shKlustakwikPca: Path,
  shKlustakwikMetric: Path,
  shCrossCohortCommonVariants: Path,
  shFlashPca: Path
  //shRegPlot: Path,
  //shTop1000Genes: Path
  ) extends Debug

final case class R(
  rFindBestDuplicateVariants: Path,
  rAncestryClusterMerge: Path,
  rCalcKinshipFamSizes: Path,
  rPlotAncestryPca: Path,
  rPlotAncestryCluster: Path,
  rIstatsPcsGmmClusterPlot: Path,
  rIstatsAdjGmmPlotMetrics: Path,
  rCalcIstatsAdj: Path,
  rIstatsAdjPca: Path,
  rModelCohortSamplesAvailable: Path,
  rMetaCohortSamples: Path,
  rExcludeCrossArray: Path,
  rGeneratePheno: Path
  //rAncestryClusterTable: Path,
  //rPcair: Path,
  //rVariantsSummaryTable: Path,
  //rUpsetplotBimFam: Path,
  //rMakeOutlierTable: Path,
  //rMakeMetricDistPlot: Path,
  //rTop20: Path,
  //rTop50Known: Path,
  //rMetaExclusionsTable: Path
  ) extends Debug

final case class Utils(
  imagesDir: Path,
  scriptsDir: Path,
  image: Image,
  binary: Binary,
  python: Python,
  bash: Bash,
  r: R) extends Debug

object ProjectConfig {

  def parseConfig(config: loamstream.conf.DataConfig): ProjectConfig = {

    // required global values in conf file
    val loamstreamVersion = requiredStr(config = config, field = "loamstreamVersion")
    val pipelineVersion = requiredStr(config = config, field = "pipelineVersion")
    val projectId = requiredStr(config = config, field = "projectId")
    val hailCloud = requiredBool(config = config, field = "hailCloud")
    val cloudShare = optionalStr(config = config, field = "cloudShare") match { case Some(s) => Some(uri(s)); case None => None }
    val cloudHome = optionalStr(config = config, field = "cloudHome") match { case Some(s) => Some(uri(s)); case None => None }
    val referenceGenome = requiredStr(config = config, field = "referenceGenome", regex = refGenomes.mkString("|"))
    val regionsExclude = requiredStr(config = config, field = "regionsExclude")
    val genePositions = requiredStr(config = config, field = "genePositions")
    val kgPurcellVcf = requiredStr(config = config, field = "kgPurcellVcf")
    val kgSample = requiredStr(config = config, field = "kgSample")
    val kgSampleId = requiredStr(config = config, field = "kgSampleId")
    val kgSamplePop = requiredStr(config = config, field = "kgSamplePop")
    val kgSampleGroup = requiredStr(config = config, field = "kgSampleGroup")
    val kgVcf = requiredStr(config = config, field = "kgVcf")
    val kgIds = requiredStr(config = config, field = "kgIds")
    val humanReferenceWild = requiredStr(config = config, field = "humanReferenceWild")
    val fasta = requiredStr(config = config, field = "fasta")
    val vepCacheDir = requiredStr(config = config, field = "vepCacheDir")
    val vepPluginsDir = requiredStr(config = config, field = "vepPluginsDir")
    val dbNSFP = requiredStr(config = config, field = "dbNSFP")
    val sampleFile = requiredStr(config = config, field = "sampleFile")
    val sampleFileId = requiredStr(config = config, field = "sampleFileId")
    val sampleFileSrSex = requiredStr(config = config, field = "sampleFileSrSex")
    val sampleFileMaleCode = requiredStr(config = config, field = "sampleFileMaleCode")
    val sampleFileFemaleCode = requiredStr(config = config, field = "sampleFileFemaleCode")
    val sampleFileSrRace = requiredStr(config = config, field = "sampleFileSrRace")
    val sampleFileAFRCodes = optionalStrList(config = config, field = "sampleFileAFRCodes")
    val sampleFileAMRCodes = optionalStrList(config = config, field = "sampleFileAMRCodes")
    val sampleFileEURCodes = optionalStrList(config = config, field = "sampleFileEURCodes")
    val sampleFileEASCodes = optionalStrList(config = config, field = "sampleFileEASCodes")
    val sampleFileSASCodes = optionalStrList(config = config, field = "sampleFileSASCodes")
    val phenoFile = requiredStr(config = config, field = "phenoFile")
    val phenoFileId = requiredStr(config = config, field = "phenoFileId")
    val authors = requiredStrList(config = config, field = "authors")
    val email = requiredStr(config = config, field = "email")
    val organization = requiredStr(config = config, field = "organization")
    val acknowledgementsAnalysisReport = optionalStrList(config = config, field = "acknowledgementsAnalysisReport")
    val acknowledgementsQcReport = optionalStrList(config = config, field = "acknowledgementsQcReport")
    val maxSigRegions = optionalInt(config = config, field = "maxSigRegions", min = Some(0))
    val nAncestryInferenceFeatures = requiredInt(config = config, field = "nAncestryInferenceFeatures", default = Some(3), min = Some(1), max = Some(20))
    val minPCs = requiredInt(config = config, field = "minPCs", min = Some(0), max = Some(20))
    val maxPCs = requiredInt(config = config, field = "maxPCs", min = Some(0), max = Some(20))
    val nStddevs = requiredInt(config = config, field = "nStddevs", min = Some(1))

    val cloudResources = ConfigCloudResources(
      mtCluster = {
        val thisConfig = optionalObj(config = config, field = "mtCluster")
        thisConfig match {
          case Some(o) => 
            ClusterConfig(
              zone = requiredStr(config = o, field = "zone"),
              properties = requiredStr(config = o, field = "properties"),
              masterMachineType = requiredStr(config = o, field = "masterMachineType"),
              masterBootDiskSize = requiredInt(config = o, field = "masterBootDiskSize"),
              workerMachineType = requiredStr(config = o, field = "workerMachineType"),
              workerBootDiskSize = requiredInt(config = o, field = "workerBootDiskSize"),
              numWorkers = requiredInt(config = o, field = "numWorkers"),
              numPreemptibleWorkers = requiredInt(config = o, field = "numPreemptibleWorkers"),
              preemptibleWorkerBootDiskSize = requiredInt(config = o, field = "preemptibleWorkerBootDiskSize"),
              maxClusterIdleTime = requiredStr(config = o, field = "maxClusterIdleTime")
            )
          case None => ClusterConfig()
        }
      },
      variantHtCluster = {
        val thisConfig = optionalObj(config = config, field = "variantHtCluster")
        thisConfig match {
          case Some(o) => 
            ClusterConfig(
              zone = requiredStr(config = o, field = "zone"),
              properties = requiredStr(config = o, field = "properties"),
              masterMachineType = requiredStr(config = o, field = "masterMachineType"),
              masterBootDiskSize = requiredInt(config = o, field = "masterBootDiskSize"),
              workerMachineType = requiredStr(config = o, field = "workerMachineType"),
              workerBootDiskSize = requiredInt(config = o, field = "workerBootDiskSize"),
              numWorkers = requiredInt(config = o, field = "numWorkers"),
              numPreemptibleWorkers = requiredInt(config = o, field = "numPreemptibleWorkers"),
              preemptibleWorkerBootDiskSize = requiredInt(config = o, field = "preemptibleWorkerBootDiskSize"),
              maxClusterIdleTime = requiredStr(config = o, field = "maxClusterIdleTime")
            )
          case None => ClusterConfig()
        }
      }
    )

    val resources = ConfigResources(
      preparePlink = {
        val thisConfig = requiredObj(config = config, field = "preparePlink")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      prepareFindBestDuplicateVariants = {
        val thisConfig = requiredObj(config = config, field = "prepareFindBestDuplicateVariants")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      prepareLiftOver = {
        val thisConfig = requiredObj(config = config, field = "prepareLiftOver")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      harmonizePlinkFull = {
        val thisConfig = requiredObj(config = config, field = "harmonizePlinkFull")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      harmonizeGenotypeHarmonizer = {
        val thisConfig = requiredObj(config = config, field = "harmonizeGenotypeHarmonizer")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      harmonizeAlignNon1kgVariants = {
        val thisConfig = requiredObj(config = config, field = "harmonizeAlignNon1kgVariants")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      harmonizePlinkChr = {
        val thisConfig = requiredObj(config = config, field = "harmonizePlinkChr")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      loadHail = {
        val thisConfig = requiredObj(config = config, field = "loadHail")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      filterHail = {
        val thisConfig = requiredObj(config = config, field = "filterHail")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      prunePlink = {
        val thisConfig = requiredObj(config = config, field = "prunePlink")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      annotate = {
        val thisConfig = requiredObj(config = config, field = "annotate")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      annotateHailLoad = {
        val thisConfig = requiredObj(config = config, field = "annotateHailLoad")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      kinshipKing = {
        val thisConfig = requiredObj(config = config, field = "kinshipKing")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      ancestryPcaHail = {
        val thisConfig = requiredObj(config = config, field = "ancestryPcaHail")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      ancestryPcaPlink = {
        val thisConfig = requiredObj(config = config, field = "ancestryPcaPlink")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      ancestryPcaFlashPca = {
        val thisConfig = requiredObj(config = config, field = "ancestryPcaFlashPca")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      ancestryClusterKlustakwik = {
        val thisConfig = requiredObj(config = config, field = "ancestryClusterKlustakwik")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      pca = {
        val thisConfig = requiredObj(config = config, field = "pca")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      sampleQcHail = {
        val thisConfig = requiredObj(config = config, field = "sampleQcHail")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      sampleQcKlustakwikPca = {
        val thisConfig = requiredObj(config = config, field = "sampleQcKlustakwikPca")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      sampleQcKlustakwikMetric = {
        val thisConfig = requiredObj(config = config, field = "sampleQcKlustakwikMetric")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      filterFinalHail = {
        val thisConfig = requiredObj(config = config, field = "filterFinalHail")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      exportCleanHail = {
        val thisConfig = requiredObj(config = config, field = "exportCleanHail")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      tabixClean = {
        val thisConfig = requiredObj(config = config, field = "tabixClean")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      filterImputePlink = {
        val thisConfig = requiredObj(config = config, field = "filterImputePlink")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      filterModelVariantsHail = {
        val thisConfig = requiredObj(config = config, field = "filterModelVariantsHail")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      variantAssocHailAssoc = {
        val thisConfig = requiredObj(config = config, field = "variantAssocHailAssoc")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      generatePheno = {
        val thisConfig = requiredObj(config = config, field = "generatePheno")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      crossCohortPrepPlink = {
        val thisConfig = requiredObj(config = config, field = "crossCohortPrepPlink")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      crossCohortKinshipPlink = {
        val thisConfig = requiredObj(config = config, field = "crossCohortKinshipPlink")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      crossCohortKinshipKing = {
        val thisConfig = requiredObj(config = config, field = "crossCohortKinshipKing")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      metaAnalysisHail = {
        val thisConfig = requiredObj(config = config, field = "metaAnalysisHail")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      mergeAssocHail = {
        val thisConfig = requiredObj(config = config, field = "mergeAssocHail")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      }
    )

    // inferred global values
    val ancestryInferenceFeatures = "1" * nAncestryInferenceFeatures + "0" * (20 - nAncestryInferenceFeatures)

    val numericVariantFilters = {
      for {
        vfilter <- requiredObjList(config = config, field = "numericVariantFilters")
      } yield {
        ConfigNumericFilters(
          id = requiredStr(config = vfilter, field = "id", regex = "^[a-zA-Z0-9_]*$"),
          field = requiredStr(config = vfilter, field = "field"),
          range = requiredStr(config = vfilter, field = "range"),
          expression = intervalToExpression(requiredStr(config = vfilter, field = "field"), requiredStr(config = vfilter, field = "range"))
        )
      }
    }

    val booleanVariantFilters = {
      for {
        vfilter <- requiredObjList(config = config, field = "booleanVariantFilters")
      } yield {
        ConfigBooleanFilters(
          id = requiredStr(config = vfilter, field = "id", regex = "^[a-zA-Z0-9_]*$"),
          field = requiredStr(config = vfilter, field = "field"),
          value = requiredBool(config = vfilter, field = "value"),
          expression = booleanToExpression(requiredStr(config = vfilter, field = "field"), requiredStr(config = vfilter, field = "value"))
        )
      }
    }

    val categoricalVariantFilters = {
      for {
        vfilter <- requiredObjList(config = config, field = "categoricalVariantFilters")
      } yield {
        ConfigCategoricalFilters(
          id = requiredStr(config = vfilter, field = "id", regex = "^[a-zA-Z0-9_]*$"),
          field = requiredStr(config = vfilter, field = "field"),
          values = requiredStrList(config = vfilter, field = "values"),
          expression = categoricalToExpression(requiredStr(config = vfilter, field = "field"), requiredStrList(config = vfilter, field = "values"))
        )
      }
    }

    val compoundVariantFilters = {
      for {
        vfilter <- requiredObjList(config = config, field = "compoundVariantFilters")
      } yield {
        val expressions = for {
          f <- requiredStrList(config = vfilter, field = "filters")
        } yield {
          f match {
            case n if numericVariantFilters.map(e => e.id) contains n =>
              numericVariantFilters.filter(e => e.id == n).head.expression
            case b if booleanVariantFilters.map(e => e.id) contains b =>
              booleanVariantFilters.filter(e => e.id == b).head.expression
            case c if categoricalVariantFilters.map(e => e.id) contains c =>
              categoricalVariantFilters.filter(e => e.id == c).head.expression
            case _ => throw new CfgException("compoundVariantFilters: variant filter '" + f + "' not found")
          }
        }
        ConfigCompoundFilters(
          id = requiredStr(config = vfilter, field = "id", regex = "^[a-zA-Z0-9_]*$"),
          filters = requiredStrList(config = vfilter, field = "filters"),
          expression = "(" + expressions.mkString(") & (") + ")"
        )
      }
    }

    val numericSampleFilters = {
      for {
        sfilter <- requiredObjList(config = config, field = "numericSampleFilters")
      } yield {
        ConfigNumericFilters(
          id = requiredStr(config = sfilter, field = "id", regex = "^[a-zA-Z0-9_]*$"),
          field = requiredStr(config = sfilter, field = "field"),
          range = requiredStr(config = sfilter, field = "range"),
          expression = intervalToExpression(requiredStr(config = sfilter, field = "field"), requiredStr(config = sfilter, field = "range"))
        )
      }
    }

    val booleanSampleFilters = {
      for {
        sfilter <- requiredObjList(config = config, field = "booleanSampleFilters")
      } yield {
        ConfigBooleanFilters(
          id = requiredStr(config = sfilter, field = "id", regex = "^[a-zA-Z0-9_]*$"),
          field = requiredStr(config = sfilter, field = "field"),
          value = requiredBool(config = sfilter, field = "value"),
          expression = booleanToExpression(requiredStr(config = sfilter, field = "field"), requiredStr(config = sfilter, field = "value"))
        )
      }
    }

    val categoricalSampleFilters = {
      for {
        sfilter <- requiredObjList(config = config, field = "categoricalSampleFilters")
      } yield {
        ConfigCategoricalFilters(
          id = requiredStr(config = sfilter, field = "id", regex = "^[a-zA-Z0-9_]*$"),
          field = requiredStr(config = sfilter, field = "field"),
          values = requiredStrList(config = sfilter, field = "values"),
          expression = categoricalToExpression(requiredStr(config = sfilter, field = "field"), requiredStrList(config = sfilter, field = "values"))
        )
      }
    }

    val compoundSampleFilters = {
      for {
        sfilter <- requiredObjList(config = config, field = "compoundSampleFilters")
      } yield {
        val expressions = for {
          f <- requiredStrList(config = sfilter, field = "filters")
        } yield {
          f match {
            case n if numericSampleFilters.map(e => e.id) contains n =>
              numericSampleFilters.filter(e => e.id == n).head.expression
            case b if booleanSampleFilters.map(e => e.id) contains b =>
              booleanSampleFilters.filter(e => e.id == b).head.expression
            case c if categoricalSampleFilters.map(e => e.id) contains c =>
              categoricalSampleFilters.filter(e => e.id == c).head.expression
            case _ => throw new CfgException("compoundSampleFilters: sample filter '" + f + "' not found")
          }
        }
        ConfigCompoundFilters(
          id = requiredStr(config = sfilter, field = "id", regex = "^[a-zA-Z0-9_]*$"),
          filters = requiredStrList(config = sfilter, field = "filters"),
          expression = "(" + expressions.mkString(") & (") + ")"
        )
      }
    }

    // arrays
    val Arrays = {
    
      for {
        array <- requiredObjList(config = config, field = "arrays")
      } yield {

        val technology = requiredStr(config = array, field = "technology", regex = (gwasTech ++ seqTech).mkString("|"))

        val qcVariantFilters = optionalStrList(config = array, field = "qcVariantFilters") match {
          case Some(s) =>
            for {
              f <- s
            } yield {
              f match {
                case n if numericVariantFilters.map(e => e.id) contains n => ()
                case b if booleanVariantFilters.map(e => e.id) contains b => ()
                case c if categoricalVariantFilters.map(e => e.id) contains c => ()
                case d if compoundVariantFilters.map(e => e.id) contains d => ()
                case _ => throw new CfgException("arrays.qcVariantFilters: variant filter '" + f + "' not found")
              }
            }
            Some(s)
          case None => None
        }

        val postQcSampleFilters = optionalStrList(config = array, field = "postQcSampleFilters") match {
          case Some(s) =>
            for {
              f <- s
            } yield {
              f match {
                case n if numericSampleFilters.map(e => e.id) contains n => ()
                case b if booleanSampleFilters.map(e => e.id) contains b => ()
                case c if categoricalSampleFilters.map(e => e.id) contains c => ()
                case d if compoundSampleFilters.map(e => e.id) contains d => ()
                case _ => throw new CfgException("arrays.postQcSampleFilters: sample filter '" + f + "' not found")
              }
            }
            Some(s)
          case None => None
        }

        val postQcVariantFilters = optionalStrList(config = array, field = "postQcVariantFilters") match {
          case Some(s) =>
            for {
              f <- s
            } yield {
              f match {
                case n if numericVariantFilters.map(e => e.id) contains n => ()
                case b if booleanVariantFilters.map(e => e.id) contains b => ()
                case c if categoricalVariantFilters.map(e => e.id) contains c => ()
                case d if compoundVariantFilters.map(e => e.id) contains d => ()
                case _ => throw new CfgException("arrays.postQcVariantFilters: variant filter '" + f + "' not found")
              }
            }
            Some(s)
          case None => None
        }
    
        ConfigArray(
          id = requiredStr(config = array, field = "id", regex = "^[a-zA-Z0-9_]*$"),
          filename = requiredStr(config = array, field = "filename"),
          format = requiredStr(config = array, field = "format", regex = arrayFormats.mkString("|")),
          technology = technology,
          description = requiredStr(config = array, field = "description"),
          keepIndels = requiredBool(config = array, field = "keepIndels"),
          minPartitions = optionalInt(config = array, field = "minPartitions", min = Some(1)),
          liftOver = optionalStr(config = array, field = "liftOver"),
          sampleQcMetrics = optionalStrList(config = array, field = "sampleQcMetrics") match { 
            case None =>
              technology match {
                case m if seqTech.contains(m) => defaultSampleMetricsSeq
                case n if gwasTech.contains(n) => defaultSampleMetricsGwas
                case o => throw new CfgException("arrays.sampleQcMetrics: technology '" + o + "' not recognized")
              }
            case Some(s) => s
          },
          nSampleMetricPcs = optionalInt(config = array, field = "nSampleMetricPcs", min = Some(0)),
          sampleMetricCovars = optionalStrList(config = array, field = "sampleMetricCovars") match { case Some(s) => Some(s.mkString("+")); case None => None },
          chrs = requiredStrList(config = array, field = "chrs", regex = "(([1-9]|1[0-9]|2[0-1])-([2-9]|1[0-9]|2[0-2]))|[1-9]|1[0-9]|2[0-2]|X|Y|MT"),
          gqThreshold = optionalInt(config = array, field = "gqThreshold", min = Some(0)),
          ancestryOutliersKeep = optionalStrList(config = array, field = "ancestryOutliersKeep"),
          duplicatesKeep = optionalStrList(config = array, field = "duplicatesKeep"),
          famsizeKeep = optionalStrList(config = array, field = "famsizeKeep"),
          sampleqcKeep = optionalStrList(config = array, field = "sampleqcKeep"),
          sexcheckKeep = optionalStrList(config = array, field = "sexcheckKeep"),
          qcVariantFilters = qcVariantFilters,
          qcVariantSampleN = optionalInt(config = array, field = "qcVariantSampleN", min = Some(1000)),
          qcVariantSampleSeed = optionalInt(config = array, field = "qcVariantSampleSeed", min = Some(0)),
          postQcSampleFilters = postQcSampleFilters,
          postQcVariantFilters = postQcVariantFilters,
          exportCleanVcf = requiredBool(config = array, field = "exportCleanVcf")
        )
    
      }
    
    }

    val Cohorts = {
    
      for {
        cohort <- requiredObjList(config = config, field = "cohorts")
      } yield {

        val array = requiredStr(config = cohort, field = "array")
        Arrays.map(e => e.id) contains array match {
          case true => ()
          case false => throw new CfgException("cohorts.array: array '" + array + "' not found")
        }

        ConfigCohort(
          id = requiredStr(config = cohort, field = "id"),
          array = array,
          ancestry = requiredStrList(config = cohort, field = "ancestry", regex = ancestryCodes.mkString("|")),
          minPartitions = optionalInt(config = cohort, field = "minPartitions", min = Some(1)),
          stratCol = optionalStr(config = cohort, field = "stratCol"),
          stratCodes = optionalStrList(config = cohort, field = "stratCodes")
        )
    
      }
    
    }

    val Metas = {
    
      for {
        meta <- requiredObjList(config = config, field = "metas")
      } yield {

        val cohorts = for {
          c <- requiredStrList(config = meta, field = "cohorts")
        } yield {
          Cohorts.map(e => e.id) contains c match {
            case true => c
            case false => throw new CfgException("metas.cohorts: cohort '" + c + "' not found")
          }
        }

        ConfigMeta(
          id = requiredStr(config = meta, field = "id"),
          cohorts = cohorts,
          minPartitions = optionalInt(config = meta, field = "minPartitions", min = Some(1))
        )
    
      }
    
    }

    val Merges = {
    
      for {
        merge <- requiredObjList(config = config, field = "merges")
      } yield {

        val cohorts_metas = for {
          c <- requiredStrList(config = merge, field = "cohorts_metas")
        } yield {
          Cohorts.map(e => e.id) contains c match {
            case true => c
            case false =>
              Metas.map(e => e.id) contains c match {
                case true => c
                case false => throw new CfgException("merges.cohorts_metas: cohorts_metas '" + c + "' not found")
              }
          }
        }
    
        ConfigMerge(
          id = requiredStr(config = merge, field = "id"),
          cohorts_metas = cohorts_metas,
          minPartitions = optionalInt(config = merge, field = "minPartitions", min = Some(1))
        )
    
      }
    
    }

    val Phenos = {
    
      for {
        pheno <- requiredObjList(config = config, field = "phenos")
      } yield {
    
        ConfigPheno(
          id = requiredStr(config = pheno, field = "id"),
          name = requiredStr(config = pheno, field = "name"),
          desc = requiredStr(config = pheno, field = "desc")
        )
    
      }
    
    }

    val Knowns = {
    
      for {
        known <- requiredObjList(config = config, field = "knowns")
      } yield {
    
        ConfigKnown(
          id = requiredStr(config = known, field = "id"),
          data = requiredStr(config = known, field = "data"),
          hiLd = requiredStr(config = known, field = "hiLd"),
          n = getStrOrBlank(config = known, field = "n"),
          nCase = getStrOrBlank(config = known, field = "nCase"),
          nCtrl = getStrOrBlank(config = known, field = "nCtrl"),
          desc = requiredStr(config = known, field = "desc"),
          citation = requiredStr(config = known, field = "citation")
        )
    
      }
    
    }

    val Models = {
    
      for {
        model <- requiredObjList(config = config, field = "models")
      } yield {

        val id = requiredStr(config = model, field = "id")

        val pheno = requiredStr(config = model, field = "pheno")
        Phenos.map(e => e.id) contains pheno match {
          case true => ()
          case false => throw new CfgException("models.pheno: model " + id + " pheno '" + pheno + "' not found")
        }

        val test = requiredStr(config = model, field = "test", regex = assocTests.mkString("|"))

        val design = requiredStr(config = model, field = "design", regex = modelDesigns.mkString("|"))

        val cohorts = requiredStrList(config = model, field = "cohorts")

        val metas = optionalStrList(config = model, field = "metas") match {
          case Some(s) =>
            for {
              f <- s
            } yield {
              f match {
                case n if Metas.map(e => e.id) contains n =>
                  val x = Metas.filter(e => e.id == n).head.cohorts
                  cohorts.intersect(x) == x match {
                    case false => throw new CfgException("models.metas: model " + id + " meta cohorts must be subset of model cohorts")
                    case true => ()
                  }
                case _ => throw new CfgException("models.metas: model " + id + " meta '" + f + "' not found")
              }
            }
            Some(s)
          case None => None
        }
 
        val merges = optionalStrList(config = model, field = "merges") match {
          case Some(s) =>
            for {
              f <- s
            } yield {
              f match {
                case n if Merges.map(e => e.id) contains n =>
                  val x = Cohorts.filter(e => Merges.filter(f => f.id == n).head.cohorts_metas.contains(e.id)).map(e => e.id)
                  cohorts.intersect(x) == x match {
                    case false => throw new CfgException("models.merges: model " + id + " merge cohorts must be subset of model cohorts")
                    case true => ()
                  }
                  metas match {
                    case Some(t) =>
                      val y = Metas.filter(e => Merges.filter(f => f.id == n).head.cohorts_metas.contains(e.id)).map(e => e.id)
                      metas.get.intersect(y) == y match {
                        case false => throw new CfgException("models.merges: model " + id + " merge metas must be subset of model metas")
                        case true => ()
                      }
                    case None => ()
                  }
                case _ => throw new CfgException("models.merges: model " + id + " merge '" + f + "' not found")
              }
            }
            Some(s)
          case None => None
        }

        val filters = optionalStrList(config = model, field = "filters") match {
          case Some(s) =>
            for {
              f <- s
            } yield {
              f match {
                case n if numericVariantFilters.map(e => e.id) contains n => ()
                case o if booleanVariantFilters.map(e => e.id) contains o => ()
                case p if categoricalVariantFilters.map(e => e.id) contains p => ()
                case q if compoundVariantFilters.map(e => e.id) contains q => ()
                case _ => throw new CfgException("models.filters: model " + id + " variant filter '" + f + "' not found")
              }
            }
            Some(s)
          case None => None
        }

        val cohortFilters = optionalObjList(config = model, field = "cohortFilters") match {
          case Some(s) =>
            val x = for {
              cf <- s
            } yield {
              for {
                f <- requiredStrList(config = cf, field = "filters")
              } yield {
                f match {
                  case n if numericVariantFilters.map(e => e.id) contains n => ()
                  case o if booleanVariantFilters.map(e => e.id) contains o => ()
                  case p if categoricalVariantFilters.map(e => e.id) contains p => ()
                  case q if compoundVariantFilters.map(e => e.id) contains q => ()
                  case _ => throw new CfgException("models.cohortFilters: model " + id + " cohort filter '" + f + "' not found")
                }
              }
              CohortFilter(
                cohort = requiredStr(config = cf, field = "cohort"),
                filters = requiredStrList(config = cf, field = "filters")
              )
            }
            Some(x)
          case None => None
        }

        val knockoutFilters = optionalObjList(config = model, field = "knockoutFilters") match {
          case Some(s) =>
            val x = for {
              cf <- s
            } yield {
              for {
                f <- requiredStrList(config = cf, field = "filters")
              } yield {
                f match {
                  case n if numericVariantFilters.map(e => e.id) contains n => ()
                  case o if booleanVariantFilters.map(e => e.id) contains o => ()
                  case p if categoricalVariantFilters.map(e => e.id) contains p => ()
                  case q if compoundVariantFilters.map(e => e.id) contains q => ()
                  case _ => throw new CfgException("models.knockoutFilters: model " + id + " knockout filter '" + f + "' not found")
                }
              }
              CohortFilter(
                cohort = requiredStr(config = cf, field = "cohort"),
                filters = requiredStrList(config = cf, field = "filters")
              )
            }
            Some(x)
          case None => None
        }

        val masks = optionalObjList(config = model, field = "masks") match {
          case Some(s) =>
            val x = for {
              cf <- s
            } yield {
              for {
                f <- requiredStrList(config = cf, field = "filters")
              } yield {
                f match {
                  case n if numericVariantFilters.map(e => e.id) contains n => ()
                  case o if booleanVariantFilters.map(e => e.id) contains o => ()
                  case p if categoricalVariantFilters.map(e => e.id) contains p => ()
                  case q if compoundVariantFilters.map(e => e.id) contains q => ()
                  case _ => throw new CfgException("models.masks: model " + id + " mask filter '" + f + "' not found")
                }
              }
              MaskFilter(
                id = requiredStr(config = cf, field = "id"),
                filters = requiredStrList(config = cf, field = "filters")
              )
            }
            Some(x)
          case None => None
        }

        val knowns = optionalStrList(config = model, field = "knowns") match {
          case Some(s) =>
            for {
              f <- s
            } yield {
              f match {
                case n if Knowns.map(e => e.id) contains n => ()
                case _ => throw new CfgException("models.knowns: model " + id + " known '" + f + "' not found")
              }
            }
            Some(s)
          case None => None
        }

        ConfigModel(
          id = id,
          pheno = pheno,
          unrelatedOnly = requiredBool(config = model, field = "unrelatedOnly"),
          trans = optionalStr(config = model, field = "trans", regex = modelTrans.mkString("|")),
          test = test,
          covars = requiredStrList(config = model, field = "covars").mkString("+"),
          design = design,
          cohorts = (design, cohorts.size > 1, Cohorts.filter(e => cohorts.contains(e.id)).map(e => e.array).distinct.size > 1) match {
            case ("strat", false, _) => throw new CfgException("models.cohorts: model " + id + " 'strat' design requires more than 1 cohort")
            case ("full", true, true) => throw new CfgException("models.cohorts: model " + id + " 'full' design requires cohorts from same array")
            case _ => cohorts
          },
          metas = (design, metas) match {
            case ("full", Some(s)) => throw new CfgException("models.metas: model " + id + " 'full' design and metas are not allowed")
            case _ => metas
          },
          merges = (design, merges) match {
            case ("full", Some(s)) => throw new CfgException("models.merges: model " + id + " 'full' design and merges are not allowed")
            case _ => merges
          },
          filters = filters,
          maxPcaOutlierIterations = requiredInt(config = model, field = "maxPcaOutlierIterations"),
          cohortFilters = cohortFilters,
          knockoutFilters = (design, knockoutFilters) match {
            case ("strat", Some(s)) => throw new CfgException("models.knockoutFilters: model " + id + " 'strat' design and knockoutFilters are not allowed")
            case _ => knockoutFilters
          },
          masks = test match {
            case "logistic_burden" | "logistic_skat" | "linear_burden" | "linear_skat" => masks
            case _ => 
              masks match {
                case Some(s) => throw new CfgException("models.masks: model " + id + " masks are only allowed for collapsing variant tests (ie burden|skat)")
                case None => None
              }
          },
          knowns = knowns
        )

      }
    
    }

    val Reports = {
    
      for {
        report <- requiredObjList(config = config, field = "reports")
      } yield {
    
        ConfigReport(
          id = requiredStr(config = report, field = "id"),
          name = requiredStr(config = report, field = "name"),
          sections = for {
            section <- requiredObjList(config = report, field = "sections")
          } yield {

            val models = for {
              m <- requiredStrList(config = section, field = "models")
            } yield {
              Models.map(e => e.id) contains m match {
                case true => m
                case false => throw new CfgException("reports.sections.models: model '" + m + "' not found")
              }
            }
    
            ConfigSection(
              id = requiredStr(config = section, field = "id"),
              title = requiredStr(config = section, field = "title"),
              models = models
            )
          
          }

        )

      }
    
    }

    val nArrays = Arrays.size
    val nCohorts = Cohorts.size
    val nMetas = Metas.size

    new ProjectConfig(

      loamstreamVersion = loamstreamVersion,
      pipelineVersion = pipelineVersion,
      projectId = projectId,
      hailCloud = hailCloud,
      cloudHome = cloudHome,
      cloudShare = cloudShare,
      referenceGenome = referenceGenome,
      regionsExclude = regionsExclude,
      genePositions = genePositions,
      kgPurcellVcf = kgPurcellVcf,
      kgSample = kgSample,
      kgSampleId = kgSampleId,
      kgSamplePop = kgSamplePop,
      kgSampleGroup = kgSampleGroup,
      kgVcf = kgVcf,
      kgIds = kgIds,
      humanReferenceWild = humanReferenceWild,
      fasta = fasta,
      vepCacheDir = vepCacheDir,
      vepPluginsDir = vepPluginsDir,
      dbNSFP = dbNSFP,
      sampleFile = sampleFile,
      sampleFileId = sampleFileId,
      sampleFileSrSex = sampleFileSrSex,
      sampleFileMaleCode = sampleFileMaleCode,
      sampleFileFemaleCode = sampleFileFemaleCode,
      sampleFileSrRace = sampleFileSrRace,
      sampleFileAFRCodes = sampleFileAFRCodes,
      sampleFileAMRCodes = sampleFileAMRCodes,
      sampleFileEURCodes = sampleFileEURCodes,
      sampleFileEASCodes = sampleFileEASCodes,
      sampleFileSASCodes = sampleFileSASCodes,
      phenoFile = phenoFile,
      phenoFileId = phenoFileId,
      authors = authors,
      email = email,
      organization = organization,
      acknowledgementsAnalysisReport = acknowledgementsAnalysisReport,
      acknowledgementsQcReport = acknowledgementsQcReport,
      nAncestryInferenceFeatures = nAncestryInferenceFeatures,
      ancestryInferenceFeatures = ancestryInferenceFeatures,
      minPCs = minPCs,
      maxPCs = maxPCs,
      nStddevs = nStddevs,
      cloudResources = cloudResources,
      resources = resources,
      nArrays = nArrays,
      nCohorts = nCohorts,
      nMetas = nMetas,
      maxSigRegions = maxSigRegions,
      numericVariantFilters =  numericVariantFilters,
      booleanVariantFilters = booleanVariantFilters,
      categoricalVariantFilters = categoricalVariantFilters,
      compoundVariantFilters = compoundVariantFilters,
      numericSampleFilters =  numericSampleFilters,
      booleanSampleFilters = booleanSampleFilters,
      categoricalSampleFilters = categoricalSampleFilters,
      compoundSampleFilters = compoundSampleFilters,
      Arrays = Arrays,
      Cohorts = Cohorts,
      Metas = Metas,
      Merges = Merges,
      Phenos = Phenos,
      Knowns = Knowns,
      Models = Models,
      Reports = Reports

    )

  }

  def parseUtils(config: loamstream.conf.DataConfig): Utils = {

    val imagesDir = path(checkPath(requiredStr(config = config, field = "imagesDir")))
    val scriptsDir = path(checkPath(requiredStr(config = config, field = "scriptsDir")))

    val image = Image(
      imgHail = path(s"${imagesDir}/hail.simg"),
      imgLocuszoom = path(s"${imagesDir}/locuszoom.simg"),
      imgPython2 = path(s"${imagesDir}/python2.simg"),
      imgR = path(s"${imagesDir}/r.simg"),
      imgTools = path(s"${imagesDir}/tools.simg"),
      imgTexLive = path(s"${imagesDir}/texlive.simg"),
      imgEnsemblVep = path(s"${imagesDir}/ensemblvep.simg"),
      imgFlashPca = path(s"${imagesDir}/flashpca.simg")
    )

    val binary = Binary(
      binLiftOver = path("/usr/local/bin/liftOver"),
      binGenotypeHarmonizer = path("/usr/local/bin/GenotypeHarmonizer.jar"),
      binKing = path("/usr/local/bin/king"),
      binPlink = path("/usr/local/bin/plink"),
      binTabix = path("/usr/local/bin/tabix"),
      binGhostscript = path("/usr/local/bin/gs"),
      binKlustakwik = path("/usr/local/bin/KlustaKwik"),
      binPython = path("/usr/local/bin/python"),
      binLocuszoom = path("/usr/local/bin/locuszoom"),
      binPdflatex = path("/usr/local/bin/pdflatex"),
      binRscript = path("/usr/local/bin/Rscript"),
      binFlashPca = path("/usr/local/bin/flashpca")
    )

    val python = Python(
      pyAlignNon1kgVariants = path(s"${scriptsDir}/align_non1kg_variants.py"),
      pyHailLoad = path(s"${scriptsDir}/hail_load.py"),
      pyHailLoadAnnotations = path(s"${scriptsDir}/hail_load_annotations.py"),
      pyHailExportQcData = path(s"${scriptsDir}/hail_export_qc_data.py"),
      pyHailAncestryPcaMerge1kg = path(s"${scriptsDir}/hail_ancestry_pca_merge_1kg.py"),
      pyHailPcaMerge1kg = path(s"${scriptsDir}/hail_pca_merge_1kg.py"),
      pyHailSampleqc = path(s"${scriptsDir}/hail_sampleqc.py"),
      pyHailFilter = path(s"${scriptsDir}/hail_filter.py"),
      pyMakeSamplesRestoreTable = path(s"${scriptsDir}/make_samples_restore_table.py"),
      pyCompileExclusions = path(s"${scriptsDir}/compile_exclusions.py"),
      pyMergeVariantLists = path(s"${scriptsDir}/merge_variant_lists.py"),
      pyBimToUid = path(s"${scriptsDir}/bim_to_uid.py"),
      pyHailUtils = path(s"${scriptsDir}/hail_utils.py"),
      pyHailAssoc = path(s"${scriptsDir}/hail_assoc.py"),
      pyHailFilterModelVariants = path(s"${scriptsDir}/hail_filter_model_variants.py"),
      pyHailExportCleanArrayData = path(s"${scriptsDir}/hail_export_clean_array_data.py")
      //pyHailFilterResults = path(s"${scriptsDir}/hail_filter_results.py"),
      //pyHailMerge = path(s"${scriptsDir}/hail_merge.py"),
      //pyHailMetaAnalysis = path(s"${scriptsDir}/hail_meta_analysis.py"),
      //pyQqPlot = path(s"${scriptsDir}/qqplot.py"),
      //pyMhtPlot = path(s"${scriptsDir}/mhtplot.py"),
      //pyExtractTopRegions = path(s"${scriptsDir}/extract_top_regions.py"),
      //pyGenerateReportHeader = path(s"${scriptsDir}/generate_report_header.py"),
      //pyGenerateQcReportIntro = path(s"${scriptsDir}/generate_qc_report_intro.py"),
      //pyGenerateQcReportData = path(s"${scriptsDir}/generate_qc_report_data.py"),
      //pyGenerateQcReportAncestry = path(s"${scriptsDir}/generate_qc_report_ancestry.py"),
      //pyGenerateQcReportIbdSexcheck = path(s"${scriptsDir}/generate_qc_report_ibd_sexcheck.py"),
      //pyGenerateQcReportSampleqc = path(s"${scriptsDir}/generate_qc_report_sampleqc.py"),
      //pyGenerateQcReportVariantqc = path(s"${scriptsDir}/generate_qc_report_variantqc.py"),
      //pyGenerateQcReportBibliography = path(s"${scriptsDir}/generate_qc_report_bibliography.py"),
      //pyGenerateAnalysisReportIntro = path(s"${scriptsDir}/generate_analysis_report_intro.py"),
      //pyGenerateAnalysisReportData = path(s"${scriptsDir}/generate_analysis_report_data.py"),
      //pyGenerateAnalysisReportStrategy = path(s"${scriptsDir}/generate_analysis_report_strategy.py"),
      //pyGenerateAnalysisReportPhenoSummary = path(s"${scriptsDir}/generate_analysis_report_pheno_summary.py"),
      //pyGenerateAnalysisReportPhenoCalibration = path(s"${scriptsDir}/generate_analysis_report_pheno_calibration.py"),
      //pyGenerateAnalysisReportPhenoTopLoci = path(s"${scriptsDir}/generate_analysis_report_pheno_top_loci.py"),
      //pyGenerateAnalysisReportPhenoKnownLoci = path(s"${scriptsDir}/generate_analysis_report_pheno_known_loci.py"),
      //pyGenerateAnalysisReportBibliography = path(s"${scriptsDir}/generate_analysis_report_bibliography.py"),
      //pyTop1000 = path(s"${scriptsDir}/top1000.py"),
      //pyAddGeneAnnot = path(s"${scriptsDir}/add_gene_annot.py"),
      //pyPhenoDistPlot = path(s"${scriptsDir}/pheno_dist_plot.py")
    )

    val bash = Bash(
      shFindPossibleDuplicateVariants = path(s"${scriptsDir}/find_possible_duplicate_variants.sh"),
      shAnnotate = path(s"${scriptsDir}/annotate.sh"),
      shKing = path(s"${scriptsDir}/king.sh"),
      shPlinkPrepare = path(s"${scriptsDir}/plink_prepare.sh"),
      shPlinkToVcfNoHalfCalls = path(s"${scriptsDir}/plink_to_vcf_no_half_calls.sh"),
      shKlustakwikPca = path(s"${scriptsDir}/klustakwik_pca.sh"),
      shKlustakwikMetric = path(s"${scriptsDir}/klustakwik_metric.sh"),
      shCrossCohortCommonVariants = path(s"${scriptsDir}/cross_cohort_common_variants.sh"),
      shFlashPca = path(s"${scriptsDir}/flashpca.sh"),
      //shRegPlot = path(s"${scriptsDir}/regplot.sh"),
      //shTop1000Genes = path(s"${scriptsDir}/top1000_genes.sh")
    )

    val r = R(
      rFindBestDuplicateVariants = path(s"${scriptsDir}/find_best_duplicate_variants.r"),
      rAncestryClusterMerge = path(s"${scriptsDir}/ancestry_cluster_merge.r"),
      rCalcKinshipFamSizes = path(s"${scriptsDir}/calc_kinship_fam_sizes.r"),
      rPlotAncestryPca = path(s"${scriptsDir}/plot_ancestry_pca.r"),
      rPlotAncestryCluster = path(s"${scriptsDir}/plot_ancestry_cluster.r"),
      rIstatsPcsGmmClusterPlot = path(s"${scriptsDir}/istats_pcs_gmm_cluster_plot.r"),
      rIstatsAdjGmmPlotMetrics = path(s"${scriptsDir}/istats_adj_gmm_plot_metrics.r"),
      rCalcIstatsAdj = path(s"${scriptsDir}/calc_istats_adj.r"),
      rIstatsAdjPca = path(s"${scriptsDir}/istats_adj_pca.r"),
      rModelCohortSamplesAvailable = path(s"${scriptsDir}/model_cohort_samples_available.r"),
      rMetaCohortSamples = path(s"${scriptsDir}/meta_cohort_samples.r"),
      rExcludeCrossArray = path(s"${scriptsDir}/exclude_cross_array.r"),
      rGeneratePheno = path(s"${scriptsDir}/generate_pheno.r")
      //rAncestryClusterTable = path(s"${scriptsDir}/ancestry_cluster_table.r"),
      //rPcair = path(s"${scriptsDir}/pcair.r"),
      //rVariantsSummaryTable = path(s"${scriptsDir}/variants_summary_table.r"),
      //rUpsetplotBimFam = path(s"${scriptsDir}/upsetplot.bimfam.r"),
      //rMakeOutlierTable = path(s"${scriptsDir}/make_outlier_table.r"),
      //rMakeMetricDistPlot = path(s"${scriptsDir}/make_metric_dist_plot.r"),
      //rTop20 = path(s"${scriptsDir}/top20.r"),
      //rTop50Known = path(s"${scriptsDir}/top50_known.r"),
      //rMetaExclusionsTable = path(s"${scriptsDir}/meta_exclusions_table.r")
    )

    new Utils(
      imagesDir = imagesDir,
      scriptsDir = scriptsDir,
      image = image,
      binary = binary,
      python = python,
      bash = bash,
      r = r)

  }

}

// Initialize configuration and utilities, verify them, and write all objects to file
println("Loading Project Configuration File ...")
val dataConfig = loadConfig("dataConfig", "")

val projectConfig = ProjectConfig.parseConfig(dataConfig)
projectConfig.debugVars()
for ( d <- projectConfig.Arrays ) { d.debugVars() }
for ( d <- projectConfig.Cohorts ) { d.debugVars() }
for ( d <- projectConfig.Metas ) { d.debugVars() }
for ( d <- projectConfig.Merges ) { d.debugVars() }
for ( d <- projectConfig.Phenos ) { d.debugVars() }
for ( d <- projectConfig.Models ) { d.debugVars() }
for ( d <- projectConfig.Knowns ) { d.debugVars() }
for ( d <- projectConfig.Reports ) { d.debugVars() }
println("... Project Configuration Loaded Successfully!")

println("Loading Pipeline Utilities Configuration ...")
val utils = ProjectConfig.parseUtils(dataConfig)
utils.debugVars()
utils.image.debugVars()
utils.binary.debugVars()
utils.python.debugVars()
utils.bash.debugVars()
utils.r.debugVars()
println("... Pipeline Utilities Configuration Loaded Successfully!")