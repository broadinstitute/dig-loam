import java.io.{File, BufferedWriter, FileWriter}
import Fxns._

final case class MultiStrPath(
  local: Option[String],
  google: Option[String])

final case class ConfigArray(
  id: String,
  file: String,
  basename: String,
  format: String,
  tech: String,
  desc: String,
  liftOver: Option[String],
  partitions: Int,
  chrs: Seq[String],
  sampleQcMetrics: Seq[String],
  nMetrics: Int,
  nAncestryInferenceFeatures: Int,
  ancestryInferenceFeatures: String,
  ancestryOutliersKeep: Seq[String],
  duplicatesKeep: Seq[String],
  famsizeKeep: Seq[String],
  sampleqcKeep: Seq[String],
  sexcheckKeep: Seq[String]) extends Debug

final case class ConfigCohort(
  id: String,
  array: String,
  ancestry: Seq[String],
  partitions: Int) extends Debug

final case class ConfigMeta(
  id: String,
  cohorts: Seq[String],
  partitions: Int) extends Debug

final case class ConfigMerge(
  id: String,
  cohorts_metas: Seq[String],
  partitions: Int) extends Debug

final case class ConfigPheno(
  id: String,
  name: String) extends Debug

final case class ConfigModel(
  id: String,
  pheno: String,
  trans: String,
  test: String,
  covars: Seq[String]) extends Debug

final case class ConfigKnown(
  id: String,
  data: String,
  hiLd: String,
  n: String,
  nCase: String,
  nCtrl: String,
  desc: String,
  citation: String) extends Debug

final case class ConfigSection(
  id: String,
  title: String,
  models: Seq[String],
  cohorts: Option[Seq[String]],
  metas: Option[Seq[String]],
  merges: Option[Seq[String]],
  knowns: Option[Seq[String]]) extends Debug

final case class ConfigReport(
  id: String,
  name: String,
  sections: Seq[ConfigSection]) extends Debug

final case class ProjectConfig(
  loamstreamVersion: String,
  pipelineVersion: String,
  projectId: String,
  hailCloud: Boolean,
  cloudShare: Option[String],
  cloudHome: Option[String],
  dirTree: DirTree,
  referenceGenome: String,
  regionsExclude: String,
  genePositions: String,
  kgPurcellVcf: String,
  kgPurcellVcfGoogle: Option[String],
  kgSample: String,
  kgSampleGoogle: Option[String],
  kgSampleId: String,
  kgSamplePop: String,
  kgSampleGroup: String,
  kgVcf: String,
  kgIds: String,
  humanReferenceWild: String,
  phenoFile: String,
  phenoFileId: String,
  phenoFileSrSex: String,
  phenoFileMaleCode: String,
  phenoFileFemaleCode: String,
  phenoFileSrRace: String,
  phenoFileStatus: String,
  authors: Seq[String],
  contact: String,
  email: String,
  organization: String,
  acknowledgementsAnalysisReport: Seq[String],
  acknowledgementsQcReport: Seq[String],
  nCoresHail: Int,
  nMemHail: Int,
  nCoresPca: Int,
  nMemPca: Int,
  nMemKlustakwik: Int,
  nCoresKing: Int,
  nMemKing: Int,
  nArrays: Int,
  nCohorts: Int,
  nMetas: Int,
  maxSigRegions: Option[Int],
  Arrays: Seq[ConfigArray],
  Cohorts: Seq[ConfigCohort],
  Metas: Seq[ConfigMeta],
  Merges: Seq[ConfigMerge],
  Phenos: Seq[ConfigPheno],
  Models: Seq[ConfigModel],
  Knowns: Seq[ConfigKnown],
  Reports: Seq[ConfigReport]) extends Debug

final case class Image(
  imgHail: Path,
  imgLocuszoom: Path,
  imgPython27: Path,
  imgR34: Path,
  imgTools: Path,
  imgTex: Path) extends Debug

final case class Binary(
  binLiftOver: Path,
  binGenotypeHarmonizer: Path,
  binKing: Path,
  binPlink: Path,
  binTabix: Path,
  binGhostscript: Path,
  binKlustakwik: Path,
  binPython: Path,
  binLocuszoom: Path,
  binPdflatex: Path,
  binRscript: Path) extends Debug

final case class Python(
  pyAlignNon1kgVariants: Path,
  pyHailLoad: Path,
  pyHailFilter: Path,
  pyHailAncestryPcaMerge1kg: Path,
  pyHailPcaMerge1kg: Path,
  pyHailSampleqc: Path,
  pyHailSexcheck: Path,
  pyHailFilterFinal: Path,
  pyHailListSamples: Path,
  pyHailAssoc: Path,
  pyHailMerge: Path,
  pyHailMetaAnalysis: Path,
  pyQqPlot: Path,
  pyMhtPlot: Path,
  pyExtractTopRegions: Path,
  pyMakeSamplesRestoreTable: Path,
  pyCompileExclusions: Path,
  pyGenerateReportHeader: Path,
  pyGenerateQcReportIntro: Path,
  pyGenerateQcReportData: Path,
  pyGenerateQcReportAncestry: Path,
  pyGenerateQcReportIbdSexcheck: Path,
  pyGenerateQcReportSampleqc: Path,
  pyGenerateQcReportVariantqc: Path,
  pyGenerateQcReportBibliography: Path,
  pyGenerateAnalysisReportIntro: Path,
  pyGenerateAnalysisReportData: Path,
  pyGenerateAnalysisReportStrategy: Path,
  pyGenerateAnalysisReportPhenoSummary: Path,
  pyGenerateAnalysisReportPhenoCalibration: Path,
  pyGenerateAnalysisReportPhenoTopLoci: Path,
  pyGenerateAnalysisReportPhenoKnownLoci: Path,
  pyGenerateAnalysisReportBibliography: Path,
  pyMergeVariantLists: Path,
  pyTop1000: Path,
  pyAddGeneAnnot: Path,
  pyPhenoDistPlot: Path) extends Debug

final case class Bash(
  shRegPlot: Path,
  shKing: Path,
  shCrossCohortCommonVariants: Path,
  shMetaCohortSamples: Path,
  shKlustakwikPca: Path,
  shKlustakwikMetric: Path,
  shTop1000Genes: Path) extends Debug

final case class R(
  rFindBestDuplicateVariants: Path,
  rAncestryClusterMerge: Path,
  rAncestryClusterTable: Path,
  rCalcKinshipFamSizes: Path,
  rPcair: Path,
  rPlotAncestryPca: Path,
  rPlotAncestryCluster: Path,
  rIstatsPcsGmmClusterPlot: Path,
  rIstatsAdjGmmPlotMetrics: Path,
  rCalcIstatsAdj: Path,
  rIstatsAdjPca: Path,
  rExcludeCrossArray: Path,
  rGeneratePheno: Path,
  rVariantsSummaryTable: Path,
  rUpsetplotBimFam: Path,
  rMakeOutlierTable: Path,
  rMakeMetricDistPlot: Path,
  rTop20: Path,
  rTop50Known: Path,
  rMetaExclusionsTable: Path) extends Debug

final case class Utils(
  imagesDir: Path,
  scriptsDir: Path,
  image: Image,
  binary: Binary,
  python: Python,
  bash: Bash,
  r: R) extends Debug

object ProjectConfig {

  def parseConfig(config: loamstream.conf.DataConfig): ProjectConfig = {

    val loamstreamVersion = requiredStr(config = config, field = "loamstreamVersion")
    val pipelineVersion = requiredStr(config = config, field = "pipelineVersion")
    val projectId = requiredStr(config = config, field = "projectId")
    val hailCloud = requiredBool(config = config, field = "hailCloud")
    val cloudShare = optionalStr(config = config, field = "cloudShare")
    val cloudHome = optionalStr(config = config, field = "cloudHome")
    val referenceGenome = requiredStr(config = config, field = "referenceGenome", regex = "hg18|hg19|hg38")
    val regionsExclude = requiredStr(config = config, field = "regionsExclude")
    val regionsExcludeGoogle = optionalStr(config = config, field = "regionsExcludeGoogle")
    val genePositions = requiredStr(config = config, field = "genePositions")
    val kgPurcellVcf = requiredStr(config = config, field = "kgPurcellVcf")
    val kgPurcellVcfGoogle = optionalStr(config = config, field = "kgPurcellVcfGoogle")
    val kgSample = requiredStr(config = config, field = "kgSample")
    val kgSampleGoogle = optionalStr(config = config, field = "kgSampleGoogle")
    val kgSampleId = requiredStr(config = config, field = "kgSampleId")
    val kgSamplePop = requiredStr(config = config, field = "kgSamplePop")
    val kgSampleGroup = requiredStr(config = config, field = "kgSampleGroup")
    val kgVcf = requiredStr(config = config, field = "kgVcf")
    val kgIds = requiredStr(config = config, field = "kgIds")
    val humanReferenceWild = requiredStr(config = config, field = "humanReferenceWild")
    val phenoFile = requiredStr(config = config, field = "phenoFile")
    val phenoFileId = requiredStr(config = config, field = "phenoFileId")
    val phenoFileSrSex = requiredStr(config = config, field = "phenoFileSrSex")
    val phenoFileMaleCode = requiredStr(config = config, field = "phenoFileMaleCode")
    val phenoFileFemaleCode = requiredStr(config = config, field = "phenoFileFemaleCode")
    val phenoFileSrRace = requiredStr(config = config, field = "phenoFileSrRace")
    val phenoFileStatus = requiredStr(config = config, field = "phenoFileStatus")
    val authors = requiredStrList(config = config, field = "authors")
    val contact = requiredStr(config = config, field = "contact")
    val email = requiredStr(config = config, field = "email")
    val organization = requiredStr(config = config, field = "organization")
    val acknowledgementsAnalysisReport = requiredStrList(config = config, field = "acknowledgementsAnalysisReport")
    val acknowledgementsQcReport = requiredStrList(config = config, field = "acknowledgementsQcReport")
    val nCoresHail = requiredInt(config = config, field = "nCoresHail")
    val nMemHail = requiredInt(config = config, field = "nMemHail")
    val nCoresPca = requiredInt(config = config, field = "nCoresPca")
    val nMemPca = requiredInt(config = config, field = "nMemPca")
    val nMemKlustakwik = requiredInt(config = config, field = "nMemKlustakwik")
    val nCoresKing = requiredInt(config = config, field = "nCoresKing")
    val nMemKing = requiredInt(config = config, field = "nMemKing")
    val maxSigRegions = optionalInt(config = config, field = "maxSigRegions")
    
    val Arrays = {
    
      for {
        array <- requiredObjList(config = config, field = "arrays")
      } yield {

        val file = requiredStr(config = array, field = "file")
        val nAncestryInferenceFeatures = requiredInt(config = array, field = "nAncestryInferenceFeatures", default = Some(3))
        val sampleQcMetrics = requiredStrList(config = array, field = "sampleQcMetrics", default = Some(Seq("n_non_ref_res", "n_het_res", "n_called_res", "call_rate_res", "r_ti_tv_res", "het_res","het_low_res", "het_high_res", "n_hom_var_res", "r_het_hom_var_res")))

        ConfigArray(
          id = requiredStr(config = array, field = "id", regex = "^[a-zA-Z0-9_]*$"),
          file = file,
          basename = Paths.get(requiredStr(config = array, field = "file")).getFileName().toString(),
          format = requiredStr(config = array, field = "format", regex = "vcf|plink"),
          tech = requiredStr(config = array, field = "tech", regex = "ex_array|gwas_array|custom_array|wes|wgs"),
          desc = requiredStr(config = array, field = "desc"),
          partitions = requiredInt(config = array, field = "partitions"),
          liftOver = optionalStr(config = array, field = "liftOver"),
          chrs = requiredStrList(config = array, field = "chrs", regex = "(([1-9]|1[0-9]|2[0-1])-([2-9]|1[0-9]|2[0-2]))|[1-9]|1[0-9]|2[0-2]|X|Y|MT"),
          nAncestryInferenceFeatures = nAncestryInferenceFeatures,
          ancestryInferenceFeatures = "1" * nAncestryInferenceFeatures + "0" * (20 - nAncestryInferenceFeatures),
          sampleQcMetrics = sampleQcMetrics,
          nMetrics = sampleQcMetrics.size,
          ancestryOutliersKeep = requiredStrList(config = array, field = "ancestryOutliersKeep", default = Some(Seq())),
          duplicatesKeep = requiredStrList(config = array, field = "duplicatesKeep", default = Some(Seq())),
          famsizeKeep = requiredStrList(config = array, field = "famsizeKeep", default = Some(Seq())),
          sampleqcKeep = requiredStrList(config = array, field = "sampleqcKeep", default = Some(Seq())),
          sexcheckKeep = requiredStrList(config = array, field = "sexcheckKeep", default = Some(Seq()))
        )
    
      }
    
    }
    
    val Cohorts = {
    
      for {
        cohort <- requiredObjList(config = config, field = "cohorts")
      } yield {
    
        ConfigCohort(
          id = requiredStr(config = cohort, field = "id"),
          array = requiredStr(config = cohort, field = "array"),
          ancestry = requiredStrList(config = cohort, field = "ancestry"),
          partitions = requiredInt(config = cohort, field = "partitions")
        )
    
      }
    
    }
    
    val Metas = {
    
      for {
        meta <- requiredObjList(config = config, field = "metas")
      } yield {
    
        ConfigMeta(
          id = requiredStr(config = meta, field = "id"),
          cohorts = requiredStrList(config = meta, field = "cohorts"),
          partitions = requiredInt(config = meta, field = "partitions")
        )
    
      }
    
    }
    
    val Merges = {
    
      for {
        merge <- requiredObjList(config = config, field = "merges")
      } yield {
    
        ConfigMerge(
          id = requiredStr(config = merge, field = "id"),
          cohorts_metas = requiredStrList(config = merge, field = "cohorts_metas"),
          partitions = requiredInt(config = merge, field = "partitions")
        )
    
      }
    
    }
    
    val Phenos = {
    
      for {
        pheno <- requiredObjList(config = config, field = "phenos")
      } yield {
    
        ConfigPheno(
          id = requiredStr(config = pheno, field = "id"),
          name = requiredStr(config = pheno, field = "name")
        )
    
      }
    
    }
    
    val Models = {
    
      for {
        model <- requiredObjList(config = config, field = "models")
      } yield {
    
        ConfigModel(
          id = requiredStr(config = model, field = "id"),
          pheno = requiredStr(config = model, field = "pheno"),
          trans = requiredStr(config = model, field = "trans"),
          test = requiredStr(config = model, field = "test"),
          covars = requiredStrList(config = model, field = "covars")
        )
      }
    
    }
    
    val Knowns = {
    
      for {
        known <- requiredObjList(config = config, field = "knowns")
      } yield {
    
        ConfigKnown(
          id = requiredStr(config = known, field = "id"),
          data = requiredStr(config = known, field = "data"),
          hiLd = requiredStr(config = known, field = "hiLd"),
          n = getStrOrBlank(config = known, field = "n"),
          nCase = getStrOrBlank(config = known, field = "nCase"),
          nCtrl = getStrOrBlank(config = known, field = "nCtrl"),
          desc = requiredStr(config = known, field = "desc"),
          citation = requiredStr(config = known, field = "citation")
        )
    
      }
    
    }

    val Reports = {
    
      for {
        report <- requiredObjList(config = config, field = "reports")
      } yield {
    
        ConfigReport(
          id = requiredStr(config = report, field = "id"),
          name = requiredStr(config = report, field = "name"),
          sections = for {
            section <- requiredObjList(config = report, field = "sections")
          } yield {
    
            ConfigSection(
              id = requiredStr(config = section, field = "id"),
              title = requiredStr(config = section, field = "title"),
              models = requiredStrList(config = section, field = "models"),
              cohorts = optionalStrList(config = section, field = "cohorts"),
              metas = optionalStrList(config = section, field = "metas"),
              merges = optionalStrList(config = section, field = "merges"),
              knowns = optionalStrList(config = section, field = "knowns")
            )
          
          }

        )

      }
    
    }

    val nArrays = Arrays.size
    val nCohorts = Cohorts.size
    val nMetas = Metas.size

    new ProjectConfig(

      loamstreamVersion = loamstreamVersion,
      pipelineVersion = pipelineVersion,
      projectId = projectId,
      hailCloud = hailCloud,
      cloudHome = cloudHome,
      cloudShare = cloudShare,
      dirTree = dirTree,
      referenceGenome = referenceGenome,
      regionsExclude = regionsExclude,
      regionsExcludeGoogle = regionsExcludeGoogle,
      genePositions = genePositions,
      kgPurcellVcf = kgPurcellVcf,
      kgPurcellVcfGoogle = kgPurcellVcfGoogle,
      kgSample = kgSample,
      kgSampleGoogle = kgSampleGoogle,
      kgSampleId = kgSampleId,
      kgSamplePop = kgSamplePop,
      kgSampleGroup = kgSampleGroup,
      kgVcf = kgVcf,
      kgIds = kgIds,
      humanReferenceWild = humanReferenceWild,
      phenoFile = phenoFile,
      phenoFileId = phenoFileId,
      phenoFileSrSex = phenoFileSrSex,
      phenoFileMaleCode = phenoFileMaleCode,
      phenoFileFemaleCode = phenoFileFemaleCode,
      phenoFileSrRace = phenoFileSrRace,
      phenoFileStatus = phenoFileStatus,
      authors = authors,
      contact = contact,
      email = email,
      organization = organization,
      acknowledgementsAnalysisReport = acknowledgementsAnalysisReport,
      acknowledgementsQcReport = acknowledgementsQcReport,
      nCoresHail = nCoresHail,
      nMemHail = nMemHail,
      nCoresPca = nCoresPca,
      nMemPca = nMemPca,
      nMemKlustakwik = nMemKlustakwik,
      nCoresKing = nCoresKing,
      nMemKing = nMemKing,
      nArrays = nArrays,
      nCohorts = nCohorts,
      nMetas = nMetas,
      maxSigRegions = maxSigRegions,
      Arrays = Arrays,
      Cohorts = Cohorts,
      Metas = Metas,
      Merges = Merges,
      Phenos = Phenos,
      Models = Models,
      Knowns = Knowns,
      Reports = Reports

    )

  }

  def parseUtils(config: loamstream.conf.DataConfig): Utils = {

    val imagesDir = path(checkPath(requiredStr(config = config, field = "imagesDir")))
    val scriptsDir = path(checkPath(requiredStr(config = config, field = "scriptsDir")))

    val image = Image(
      imgHail = path(checkPath(s"${imagesDir}/data_processing_v2.2_hailv02.simg")),
      imgLocuszoom = path(checkPath(s"${imagesDir}/locuszoom.simg")),
      imgPython27 = path(checkPath(s"${imagesDir}/data_processing_v2.2_python27.simg")),
      imgR34 = path(checkPath(s"${imagesDir}/data_processing_v2.2_r34.simg")),
      imgTools = path(checkPath(s"${imagesDir}/data_processing_v2.2_tools.simg")),
      imgTex = path(checkPath(s"${imagesDir}/tex.simg"))
    )

    val binary = Binary(
      binLiftOver = path("/usr/local/bin/liftOver"),
      binGenotypeHarmonizer = path("GenotypeHarmonizer"),
      binKing = path("/usr/local/bin/king"),
      binPlink = path("/usr/local/bin/plink"),
      binTabix = path("/usr/local/bin/tabix"),
      binGhostscript = path("/usr/local/bin/gs"),
      binKlustakwik = path("/usr/local/bin/KlustaKwik"),
      binPython = path("/usr/local/bin/python"),
      binLocuszoom = path("/usr/local/bin/locuszoom"),
      binPdflatex = path("/usr/local/bin/pdflatex"),
      binRscript = path("/usr/local/bin/Rscript")
    )

    val python = Python(
      pyAlignNon1kgVariants = path(checkPath(s"${scriptsDir}/align_non1kg_variants.py")),
      pyHailLoad = path(checkPath(s"${scriptsDir}/hail_load.py")),
      pyHailFilter = path(checkPath(s"${scriptsDir}/hail_filter.py")),
      pyHailAncestryPcaMerge1kg = path(checkPath(s"${scriptsDir}/hail_ancestry_pca_merge_1kg.py")),
      pyHailPcaMerge1kg = path(checkPath(s"${scriptsDir}/hail_ancestry_pca_merge_1kg.py")),
      pyHailSampleqc = path(checkPath(s"${scriptsDir}/hail_sampleqc.py")),
      pyHailSexcheck = path(checkPath(s"${scriptsDir}/hail_sexcheck.py")),
      pyHailFilterFinal = path(checkPath(s"${scriptsDir}/hail_filter_final.py")),
      pyHailListSamples = path(checkPath(s"${scriptsDir}/hail_list_samples.py")),
      pyHailAssoc = path(checkPath(s"${scriptsDir}/hail_assoc.py")),
      pyHailMerge = path(checkPath(s"${scriptsDir}/hail_merge.py")),
      pyHailMetaAnalysis = path(checkPath(s"${scriptsDir}/hail_meta_analysis.py")),
      pyQqPlot = path(checkPath(s"${scriptsDir}/qqplot.py")),
      pyMhtPlot = path(checkPath(s"${scriptsDir}/mhtplot.py")),
      pyExtractTopRegions = path(checkPath(s"${scriptsDir}/extract_top_regions.py")),
      pyMakeSamplesRestoreTable = path(checkPath(s"${scriptsDir}/make_samples_restore_table.py")),
      pyCompileExclusions = path(checkPath(s"${scriptsDir}/compile_exclusions.py")),
      pyGenerateReportHeader = path(checkPath(s"${scriptsDir}/generate_report_header.py")),
      pyGenerateQcReportIntro = path(checkPath(s"${scriptsDir}/generate_qc_report_intro.py")),
      pyGenerateQcReportData = path(checkPath(s"${scriptsDir}/generate_qc_report_data.py")),
      pyGenerateQcReportAncestry = path(checkPath(s"${scriptsDir}/generate_qc_report_ancestry.py")),
      pyGenerateQcReportIbdSexcheck = path(checkPath(s"${scriptsDir}/generate_qc_report_ibd_sexcheck.py")),
      pyGenerateQcReportSampleqc = path(checkPath(s"${scriptsDir}/generate_qc_report_sampleqc.py")),
      pyGenerateQcReportVariantqc = path(checkPath(s"${scriptsDir}/generate_qc_report_variantqc.py")),
      pyGenerateQcReportBibliography = path(checkPath(s"${scriptsDir}/generate_qc_report_bibliography.py")),
      pyGenerateAnalysisReportIntro = path(checkPath(s"${scriptsDir}/generate_analysis_report_intro.py")),
      pyGenerateAnalysisReportData = path(checkPath(s"${scriptsDir}/generate_analysis_report_data.py")),
      pyGenerateAnalysisReportStrategy = path(checkPath(s"${scriptsDir}/generate_analysis_report_strategy.py")),
      pyGenerateAnalysisReportPhenoSummary = path(checkPath(s"${scriptsDir}/generate_analysis_report_pheno_summary.py")),
      pyGenerateAnalysisReportPhenoCalibration = path(checkPath(s"${scriptsDir}/generate_analysis_report_pheno_calibration.py")),
      pyGenerateAnalysisReportPhenoTopLoci = path(checkPath(s"${scriptsDir}/generate_analysis_report_pheno_top_loci.py")),
      pyGenerateAnalysisReportPhenoKnownLoci = path(checkPath(s"${scriptsDir}/generate_analysis_report_pheno_known_loci.py")),
      pyGenerateAnalysisReportBibliography = path(checkPath(s"${scriptsDir}/generate_analysis_report_bibliography.py")),
      pyMergeVariantLists = path(checkPath(s"${scriptsDir}/merge_variant_lists.py")),
      pyTop1000 = path(checkPath(s"${scriptsDir}/top1000.py")),
      pyAddGeneAnnot = path(checkPath(s"${scriptsDir}/add_gene_annot.py")),
      pyPhenoDistPlot = path(checkPath(s"${scriptsDir}/pheno_dist_plot.py"))
    )

    val bash = Bash(
      shRegPlot = path(checkPath(s"${scriptsDir}/regplot.sh")),
      shKing = path(checkPath(s"${scriptsDir}/king.sh")),
      shCrossCohortCommonVariants = path(checkPath(s"${scriptsDir}/cross_cohort_common_variants.sh")),
      shMetaCohortSamples = path(checkPath(s"${scriptsDir}/meta_cohort_samples.sh")),
      shKlustakwikPca = path(checkPath(s"${scriptsDir}/klustakwik.pca.sh")),
      shKlustakwikMetric = path(checkPath(s"${scriptsDir}/klustakwik.metric.sh")),
      shTop1000Genes = path(checkPath(s"${scriptsDir}/top1000_genes.sh"))
    )

    val r = R(
      rFindBestDuplicateVariants = path(checkPath(s"${scriptsDir}/find_best_duplicate_variants.r")),
      rAncestryClusterMerge = path(checkPath(s"${scriptsDir}/ancestry_cluster_merge.r")),
      rAncestryClusterTable = path(checkPath(s"${scriptsDir}/ancestry_cluster_table.r")),
      rCalcKinshipFamSizes = path(checkPath(s"${scriptsDir}/calc_kinship_fam_sizes.r")),
      rPcair = path(checkPath(s"${scriptsDir}/pcair.r")),
      rPlotAncestryPca = path(checkPath(s"${scriptsDir}/plot_ancestry_pca.r")),
      rPlotAncestryCluster = path(checkPath(s"${scriptsDir}/plot_ancestry_cluster.r")),
      rIstatsPcsGmmClusterPlot = path(checkPath(s"${scriptsDir}/istats_pcs_gmm_cluster_plot.r")),
      rIstatsAdjGmmPlotMetrics = path(checkPath(s"${scriptsDir}/istats_adj_gmm_plot_metrics.r")),
      rCalcIstatsAdj = path(checkPath(s"${scriptsDir}/calc_istats_adj.r")),
      rIstatsAdjPca = path(checkPath(s"${scriptsDir}/istats_adj_pca.r")),
      rExcludeCrossArray = path(checkPath(s"${scriptsDir}/exclude_cross_array.r")),
      rGeneratePheno = path(checkPath(s"${scriptsDir}/generate_pheno.r")),
      rVariantsSummaryTable = path(checkPath(s"${scriptsDir}/variants_summary_table.r")),
      rUpsetplotBimFam = path(checkPath(s"${scriptsDir}/upsetplot.bimfam.r")),
      rMakeOutlierTable = path(checkPath(s"${scriptsDir}/make_outlier_table.r")),
      rMakeMetricDistPlot = path(checkPath(s"${scriptsDir}/make_metric_dist_plot.r")),
      rTop20 = path(checkPath(s"${scriptsDir}/top20.r")),
      rTop50Known = path(checkPath(s"${scriptsDir}/top50_known.r")),
      rMetaExclusionsTable = path(checkPath(s"${scriptsDir}/meta_exclusions_table.r"))
    )

    new Utils(
      imagesDir = imagesDir,
      scriptsDir = scriptsDir,
      image = image,
      binary = binary,
      python = python,
      bash = bash,
      r = r)

  }

}

def writeConfig(cfg: ProjectConfig, utils: Utils): Any = {
  val f = new File(cfg.dirTree.base.local + "/cfg.objects")
  val bw = new BufferedWriter(new FileWriter(f))
  val objs = Seq(cfg.dirTree, cfg) ++ cfg.Arrays
  for ( o <- objs ) {
    val vars = o.getClass.getDeclaredFields
    val name = o.getClass.getName.split("\\$")(1)
    bw.write("Class: " + name + "\n")
    for ( v <- vars ) {
      v.setAccessible(true)
      bw.write("  " + v.getName() + " => " + v.get(o).toString + "\n")
    }
    bw.write("\n")
  }
  for ( o <- Seq(utils, utils.image, utils.binary, utils.python, utils.bash, utils.r, utils) ) {
    val vars = o.getClass.getDeclaredFields
    val name = o.getClass.getName.split("\\$")(1)
    bw.write("Class: " + name + "\n")
    for ( v <- vars ) {
      v.setAccessible(true)
      bw.write("  " + v.getName() + " => " + v.get(o).toString + "\n")
    }
    bw.write("\n")
  }
  bw.close()
}

// Initialize configuration and utilities, verify them, and write all objects to file
println("Loading Project Configuration File ...")
val cfg = ProjectConfig.parseConfig(loadConfig("dataConfig", ""))
cfg.dirTree.debugVars()
cfg.debugVars()
for ( d <- cfg.Arrays ) { d.debugVars() }
for ( d <- cfg.Cohorts ) { d.debugVars() }
for ( d <- cfg.Metas ) { d.debugVars() }
for ( d <- cfg.Merges ) { d.debugVars() }
for ( d <- cfg.Phenos ) { d.debugVars() }
for ( d <- cfg.Models ) { d.debugVars() }
for ( d <- cfg.Knowns ) { d.debugVars() }
for ( d <- cfg.Reports ) { d.debugVars() }
println("... Project Configuration Loaded Successfully!")

println("Loading Pipeline Utilities Configuration ...")
val utils = ProjectConfig.parseUtils(loadConfig("dataConfig", ""))
utils.debugVars()
utils.image.debugVars()
utils.binary.debugVars()
utils.python.debugVars()
utils.bash.debugVars()
utils.r.debugVars()
println("... Pipeline Utilities Configuration Loaded Successfully!")

writeConfig(cfg, utils)

final case class DirTreeDataArray:
  base: MultiStrPath,
  ancestry: MultiStrPath,
  filterfinal: MultiStrPath,
  filterforqc: MultiStrPath,
  harmonize: MultiStrPath,
  impute: MultiStrPath,
  kinship: MultiStrPath,
  pca: MultiStrPath,
  prepare: MultiStrPath,
  sampleqc: MultiStrPath) extends Debug

final case class DirTreeAnalysis:
  base: MultiStrPath,
  pheno: Map[ConfigPheno, MultiStrPath]) extends Debug

final case class DirTreeReportAnalysis:
  base MultiStrPath,
  phase: Map[ConfigReport, MultiStrPath]) extends Debug

final case class DirTree(
  base: MultiStrPath,
  data: MultiStrPath,
  data_array: MultiStrPath,
  data_array_map: Map[ConfigArray, DirTreeDataArray],
  data_global: MultiStrPath,
  data_global_ancestry: MultiStrPath,
  data_global_kinship: MultiStrPath,
  data_global_kinship_map: Map[ConfigMeta, MultiStrPath],
  analysis: MultiStrPath,
  analysis_merge_map: Map[ConfigMerge, DirTreeAnalysis],
  analysis_meta_map: Map[ConfigMeta, DirTreeAnalysis],
  report: MultiStrPath,
  report_qc: MultiStrPath,
  report_analysis: MultiStrPath,
  report_analysis_map: Map[ConfigReport, DirTreeReportAnalysis]) extends Debug

object DirTree = {

  def initDirTree(cfg: ProjectConfig): DirTree = {

    val base = MultiStrPath(
      local = Some(initDir("loam_out")),
      google = cfg.hailCloud match {
        case true => Some(cfg.cloudHome.get + "/" + cfg.projectId + "/loam_out")
        case false => None
      }
    )
    
    val data = MultiStrPath(
      local = Some(initDir(cfg.base.local + "/data")),
      google = cfg.hailCloud match {
        case true => Some(cfg.base.google.get + "/data")
        case false => None
      }
    )

    val data_array = MultiStrPath(
      local = Some(initDir(data.local + "/array")),
      google = cfg.hailCloud match {
        case true => Some(data.google.get + "/array")
        case false => None
      }
    )

    val data_global = MultiStrPath(
      local = Some(initDir(data.local + "/global")),
      google = cfg.hailCloud match {
        case true => Some(data.google.get + "/global")
        case false => None
      }
    )

    val data_global_ancestry = MultiStrPath(
      local = Some(initDir(data_global.local + "/ancestry")),
      google = cfg.hailCloud match {
        case true => Some(data_global.google.get + "/ancestry")
        case false => None
      }
    )

    val data_global_kinship = MultiStrPath(
      local = Some(initDir(data_global.local + "/kinship")),
      google = cfg.hailCloud match {
        case true => Some(data_global.google.get + "/kinship")
        case false => None
      }
    )

    val analysis = MultiStrPath(
      local = Some(initDir(base.local + "/analysis")),
      google = cfg.hailCloud match {
        case true => Some(base.google.get + "/analysis")
        case false => None
      }
    )

    val report = MultiStrPath(
      local = Some(initDir(base.local + "/report")),
      google = cfg.hailCloud match {
        case true => Some(base.google.get + "/report")
        case false => None
      }
    )

    val report_qc = MultiStrPath(
      local = Some(initDir(report.local + "/qc")),
      google = cfg.hailCloud match {
        case true => Some(report.google.get + "/qc")
        case false => None
      }
    )

    val report_analysis = MultiStrPath(
      local = Some(initDir(report.local + "/analysis")),
      google = cfg.hailCloud match {
        case true => Some(report.google.get + "/analysis")
        case false => None
      }
    )

    val data_array_map = cfg.Arrays.map { array =>
      val base = MultiStrPath(
        local = Some(initDir(data_array.local + "/" + array.id)),
        google = cfg.hailCloud match {
          case true => Some(data_array.google.get + "/" + array.id)
          case false => None
        }
      )
      array -> DirTreeDataArray(
        base = base,
        ancestry = MultiStrPath(
          local = Some(initDir(base.local + "/ancestry")),
          google = cfg.hailCloud match {
            case true => Some(base.google.get + "/ancestry")
            case false => None
          }
        ),
        filterfinal = MultiStrPath(
          local = Some(initDir(base.local + "/filterfinal")),
          google = cfg.hailCloud match {
            case true => Some(base.google.get + "/filterfinal")
            case false => None
          }
        ),
        filterforqc = MultiStrPath(
          local = Some(initDir(base.local + "/filterforqc")),
          google = cfg.hailCloud match {
            case true => Some(base.google.get + "/filterforqc")
            case false => None
          }
        ),
        harmonize = MultiStrPath(
          local = Some(initDir(base.local + "/harmonize")),
          google = cfg.hailCloud match {
            case true => Some(base.google.get + "/harmonize")
            case false => None
          }
        ),
        impute = MultiStrPath(
          local = Some(initDir(base.local + "/impute")),
          google = cfg.hailCloud match {
            case true => Some(base.google.get + "/impute")
            case false => None
          }
        ),
        kinship = MultiStrPath(
          local = Some(initDir(base.local + "/kinship")),
          google = cfg.hailCloud match {
            case true => Some(base.google.get + "/kinship")
            case false => None
          }
        ),
        pca = MultiStrPath(
          local = Some(initDir(base.local + "/pca")),
          google = cfg.hailCloud match {
            case true => Some(base.google.get + "/pca")
            case false => None
          }
        ),
        prepare = MultiStrPath(
          local = Some(initDir(base.local + "/prepare")),
          google = cfg.hailCloud match {
            case true => Some(base.google.get + "/prepare")
            case false => None
          }
        ),
        sampleqc = MultiStrPath(
          local = Some(initDir(base.local + "/sampleqc")),
          google = cfg.hailCloud match {
            case true => Some(base.google.get + "/sampleqc")
            case false => None
          }
        )
      )
    }.toMap
    
    val prepared = MultiStrPath(
      local = Some(initDir(data.local + "/prepared")),
      google = cfg.hailCloud match {
        case true => Some(data.google.get + "/prepared")
        case false => None
      }
    )

    val preparedArray = cfg.Arrays.map { array =>
      array -> MultiStrPath(
        local = Some(initDir(prepared.local + "/" + array.id)),
        google = cfg.hailCloud match {
          case true => Some(prepared.google.get + "/" + array.id)
          case false => None
        }
      )
    }.toMap

    val annotated = MultiStrPath(
      local = Some(initDir(data.local + "/annotated")),
      google = cfg.hailCloud match {
        case true => Some(data.google.get + "/annotated")
        case false => None
      }
    )

    val annotatedArray = cfg.Arrays.map { array =>
      array -> MultiStrPath(
        local = Some(initDir(annotated.local + "/" + array.id)),
        google = cfg.hailCloud match {
          case true => Some(annotated.google.get + "/" + array.id)
          case false => None
        }
      )
    }.toMap

    val harmonized = MultiStrPath(
      local = Some(initDir(data.local + "/harmonized")),
      google = cfg.hailCloud match {
        case true => Some(data.google.get + "/harmonized")
        case false => None
      }
    )

    val harmonizedArray = cfg.Arrays.map { array =>
      array -> MultiStrPath(
        local = Some(initDir(harmonized.local + "/" + array.id)),
        google = cfg.hailCloud match {
          case true => Some(harmonized.google.get + "/" + array.id)
          case false => None
        }
      )
    }.toMap

    val pruned = MultiStrPath(
      local = Some(initDir(data.local + "/pruned")),
      google = cfg.hailCloud match {
        case true => Some(data.google.get + "/pruned")
        case false => None
      }
    )

    val prunedArray = cfg.Arrays.map { array =>
      array -> MultiStrPath(
        local = Some(initDir(pruned.local + "/" + array.id)),
        google = cfg.hailCloud match {
          case true => Some(pruned.google.get + "/" + array.id)
          case false => None
        }
      )
    }.toMap

    val kinship = MultiStrPath(
      local = Some(initDir(data.local + "/kinship")),
      google = cfg.hailCloud match {
        case true => Some(data.google.get + "/kinship")
        case false => None
      }
    )

    val kinshipArray = cfg.Arrays.map { array =>
      array -> MultiStrPath(
        local = Some(initDir(kinship.local + "/" + array.id)),
        google = cfg.hailCloud match {
          case true => Some(kinship.google.get + "/" + array.id)
          case false => None
        }
      )
    }.toMap

    val ancestry = MultiStrPath(
      local = Some(initDir(data.local + "/ancestry")),
      google = cfg.hailCloud match {
        case true => Some(data.google.get + "/ancestry")
        case false => None
      }
    )

    val ancestryArray = cfg.Arrays.map { array =>
      array -> MultiStrPath(
        local = Some(initDir(ancestry.local + "/" + array.id)),
        google = cfg.hailCloud match {
          case true => Some(ancestry.google.get + "/" + array.id)
          case false => None
        }
      )
    }.toMap

    val sampleqc = MultiStrPath(
      local = Some(initDir(data.local + "/sampleqc")),
      google = cfg.hailCloud match {
        case true => Some(data.google.get + "/sampleqc")
        case false => None
      }
    )

    val sampleqcArray = cfg.Arrays.map { array =>
      array -> MultiStrPath(
        local = Some(initDir(sampleqc.local + "/" + array.id)),
        google = cfg.hailCloud match {
          case true => Some(sampleqc.google.get + "/" + array.id)
          case false => None
        }
      )
    }.toMap

    val variantqc = MultiStrPath(
      local = Some(initDir(data.local + "/variantqc")),
      google = cfg.hailCloud match {
        case true => Some(data.google.get + "/variantqc")
        case false => None
      }
    )

    val variantqcArray = cfg.Arrays.map { array =>
      array -> MultiStrPath(
        local = Some(initDir(variantqc.local + "/" + array.id)),
        google = cfg.hailCloud match {
          case true => Some(variantqc.google.get + "/" + array.id)
          case false => None
        }
      )
    }.toMap

    val clean = MultiStrPath(
      local = Some(initDir(data.local + "/clean")),
      google = cfg.hailCloud match {
        case true => Some(data.google.get + "/clean")
        case false => None
      }
    )

    val cleanArray = cfg.Arrays.map { array =>
      array -> MultiStrPath(
        local = Some(initDir(clean.local + "/" + array.id)),
        google = cfg.hailCloud match {
          case true => Some(clean.google.get + "/" + array.id)
          case false => None
        }
      )
    }.toMap
    
    new DirTree(
      base = base,
      data = data,
      raw = raw,
      rawArray = rawArray,
      prepared = prepared,
      preparedArray = preparedArray,
      annotated = annotated,
      annotatedArray = annotatedArray,
      harmonized = harmonized,
      harmonizedArray = harmonizedArray,
      pruned = pruned,
      prunedArray = prunedArray,
      kinship = kinship,
      kinshipArray = kinshipArray,
      ancestry = ancestry,
      ancestryArray = ancestryArray,
      sampleqc = sampleqc,
      sampleqcArray = sampleqcArray,
      variantqc = variantqc,
      variantqcArray = variantqcArray,
      clean = clean,
      cleanArray = cleanArray)

  }

}

println("Initializing Directory Tree ...")
val dirTree = DirTree.initDirTree(cfg)
println("... Finished Initializing Directory Tree")
