import Fxns._

val defaultSampleMetricsGwas = Seq("n_non_ref","n_het","n_called","call_rate","r_ti_tv","het","het_low","het_high","n_hom_var","r_het_hom_var")
val defaultSampleMetricsSeq = Seq("n_non_ref","n_het","n_called","call_rate","r_ti_tv","het","het_low","het_high","n_hom_var","r_het_hom_var","n_singleton","avg_ab","avg_ab50")

final case class ConfigMachine(
  cpus: Int,
  mem: Int,
  maxRunTime: Int) extends Debug

final case class ConfigSampleFilters(
  n_non_ref: Option[String],
  n_het: Option[String],
  n_called: Option[String],
  call_rate: Option[String],
  n_singleton: Option[String],
  r_ti_tv: Option[String],
  het: Option[String],
  het_low: Option[String],
  het_high: Option[String],
  n_hom_var: Option[String],
  r_het_hom_var: Option[String],
  avg_ab: Option[String],
  avg_ab50: Option[String]
) extends Debug {
  def tupelize_metrics: List[(String,Option[String])] = {
    List(
      ("n_non_ref",n_non_ref),
      ("n_het",n_het),
      ("n_called",n_called),
      ("call_rate",call_rate),
      ("n_singleton",n_singleton),
      ("r_ti_tv",r_ti_tv),
      ("het",het),
      ("het_low",het_low),
      ("het_high",het_high),
      ("n_hom_var",n_hom_var),
      ("r_het_hom_var",r_het_hom_var),
      ("avg_ab",avg_ab),
      ("avg_ab50",avg_ab50)
   )
  }
}

final case class ConfigVariantFilters(
  call_rate: Option[String],
  AC: Option[String],
  AF: Option[String],
  AN: Option[String],
  n_called: Option[String],
  n_not_called: Option[String],
  homozygote_count: Option[String],
  n_het: Option[String],
  het: Option[String],
  n_non_ref: Option[String],
  avg_ab: Option[String],
  avg_het_ab: Option[String],
  het_freq_hwe: Option[String],
  p_value_hwe: Option[String],
  sample_n: Option[Int],
  sample_seed: Option[Int]
) extends Debug {
  def tupelize_metrics: List[(String,Option[String])] = {
    List(
      ("call_rate",call_rate),
      ("AC",AC),
      ("AF",AF),
      ("AN",AN),
      ("n_called",n_called),
      ("n_not_called",n_not_called),
      ("homozygote_count",homozygote_count),
      ("n_het",n_het),
      ("het",het),
      ("n_non_ref",n_non_ref),
      ("avg_ab",avg_ab),
      ("avg_het_ab",avg_het_ab),
      ("het_freq_hwe",het_freq_hwe),
      ("p_value_hwe",p_value_hwe)
   )
  }
}

final case class ConfigResources(
  preparePlink: ConfigMachine,
  prepareFindBestDuplicateVariants: ConfigMachine,
  prepareLiftOver: ConfigMachine,
  harmonizePlinkFull: ConfigMachine,
  harmonizeGenotypeHarmonizer: ConfigMachine,
  harmonizeAlignNon1kgVariants: ConfigMachine,
  harmonizePlinkChr: ConfigMachine,
  loadHail: ConfigMachine,
  filterHail: ConfigMachine,
  prunePlink: ConfigMachine,
  annotate: ConfigMachine,
  kinshipKing: ConfigMachine,
  ancestryPcaHail: ConfigMachine,
  ancestryPcaPlink: ConfigMachine,
  ancestryPcaPcair: ConfigMachine,
  ancestryClusterKlustakwik: ConfigMachine,
  pca: ConfigMachine,
  sampleQcHail: ConfigMachine,
  sampleQcKlustakwikPca: ConfigMachine,
  sampleQcKlustakwikMetric: ConfigMachine,
  filterFinalHail: ConfigMachine,
  filterFinalPlink: ConfigMachine,
  filterFinalPcair: ConfigMachine,
  filterImputePlink: ConfigMachine,
  variantAssocHailAssoc: ConfigMachine,
  variantAssocGeneratePheno: ConfigMachine,
  crossCohortPrepPlink: ConfigMachine,
  crossCohortKinshipPlink: ConfigMachine,
  crossCohortKinshipKing: ConfigMachine,
  metaAnalysisHail: ConfigMachine,
  mergeAssocHail: ConfigMachine) extends Debug

final case class ConfigArray(
  id: String,
  filename: String,
  format: String,
  technology: String,
  description: String,
  minPartitions: Option[Int],
  liftOver: Option[String] = None,
  sampleQcMetrics: Seq[String],
  nSampleMetricPcs: Option[Int],
  sampleMetricCovars: Option[String],
  xChr: Boolean,
  yChr: Boolean,
  mtChr: Boolean,
  skipGh: Seq[String],
  gqThreshold: Option[Int],
  qcVariantFilters: Option[ConfigVariantFilters],
  ancestryOutliersKeep: Seq[String],
  duplicatesKeep: Seq[String],
  famsizeKeep: Seq[String],
  sampleqcKeep: Seq[String],
  sexcheckKeep: Seq[String],
  analysisSampleFilters: Option[ConfigSampleFilters],
  analysisVariantFilters: Option[ConfigVariantFilters]) extends Debug

final case class ConfigCohort(
  id: String,
  array: String,
  ancestry: Seq[String],
  minPartitions: Option[Int]) extends Debug

final case class ConfigMeta(
  id: String,
  cohorts: Seq[String],
  minPartitions: Option[Int]) extends Debug

final case class ConfigMerge(
  id: String,
  cohorts_metas: Seq[String],
  minPartitions: Option[Int]) extends Debug

final case class ConfigPheno(
  id: String,
  name: String) extends Debug

final case class ConfigModel(
  id: String,
  pheno: String,
  trans: String,
  test: String,
  covars: String) extends Debug

final case class ConfigKnown(
  id: String,
  data: String,
  hiLd: String,
  n: String,
  nCase: String,
  nCtrl: String,
  desc: String,
  citation: String) extends Debug

final case class ConfigSection(
  id: String,
  title: String,
  models: Seq[String],
  cohorts: Option[Seq[String]],
  metas: Option[Seq[String]],
  merges: Option[Seq[String]],
  knowns: Option[Seq[String]]) extends Debug

final case class ConfigReport(
  id: String,
  name: String,
  sections: Seq[ConfigSection]) extends Debug

final case class ProjectConfig(
  loamstreamVersion: String,
  pipelineVersion: String,
  home: Path,
  hailCloud: Boolean,
  cloudShare: Option[URI],
  cloudHome: Option[URI],
  projectId: String,
  referenceGenome: String,
  regionsExclude: String,
  genePositions: String,
  kgPurcellVcf: String,
  kgSample: String,
  kgSampleId: String,
  kgSamplePop: String,
  kgSampleGroup: String,
  kgVcf: String,
  kgIds: String,
  humanReferenceWild: String,
  fasta: String,
  vepCacheDir: String,
  vepPluginsDir: String,
  dbNSFP: String,
  sampleFile: String,
  sampleFileId: String,
  sampleFileSrSex: String,
  sampleFileMaleCode: String,
  sampleFileFemaleCode: String,
  sampleFileSrRace: String,
  sampleFileAFRCodes: Seq[String],
  sampleFileAMRCodes: Seq[String],
  sampleFileEURCodes: Seq[String],
  sampleFileEASCodes: Seq[String],
  sampleFileSASCodes: Seq[String],
  phenoFile: String,
  phenoFileId: String,
  authors: Seq[String],
  email: String,
  organization: String,
  acknowledgementsAnalysisReport: Seq[String],
  acknowledgementsQcReport: Seq[String],
  nAncestryInferenceFeatures: Int,
  ancestryInferenceFeatures: String,
  minPCs: Int,
  maxPCs: Int,
  nStddevs: Int,
  resources: ConfigResources,
  nArrays: Int,
  nCohorts: Int,
  nMetas: Int,
  maxSigRegions: Option[Int],
  Arrays: Seq[ConfigArray],
  Cohorts: Seq[ConfigCohort],
  Metas: Seq[ConfigMeta],
  Merges: Seq[ConfigMerge],
  Phenos: Seq[ConfigPheno],
  Models: Seq[ConfigModel],
  Knowns: Seq[ConfigKnown],
  Reports: Seq[ConfigReport]) extends Debug

final case class Image(
  imgHail: Path,
  imgLocuszoom: Path,
  imgPython27: Path,
  imgR34: Path,
  imgTools: Path,
  imgTex: Path,
  imgEnsemblVep: Path) extends Debug

final case class Binary(
  binLiftOver: Path,
  binGenotypeHarmonizer: Path,
  binKing: Path,
  binPlink: Path,
  binTabix: Path,
  binGhostscript: Path,
  binKlustakwik: Path,
  binPython: Path,
  binLocuszoom: Path,
  binPdflatex: Path,
  binRscript: Path) extends Debug

final case class Python(
  pyAlignNon1kgVariants: Path,
  pyHailLoad: Path,
  pyHailExportQcData: Path,
  pyHailFilter: Path,
  pyHailAncestryPcaMerge1kg: Path,
  pyHailPcaMerge1kg: Path,
  pyHailSampleqc: Path,
  pyHailAssoc: Path,
  pyHailMerge: Path,
  pyHailMetaAnalysis: Path,
  pyQqPlot: Path,
  pyMhtPlot: Path,
  pyExtractTopRegions: Path,
  pyMakeSamplesRestoreTable: Path,
  pyCompileExclusions: Path,
  pyGenerateReportHeader: Path,
  pyGenerateQcReportIntro: Path,
  pyGenerateQcReportData: Path,
  pyGenerateQcReportAncestry: Path,
  pyGenerateQcReportIbdSexcheck: Path,
  pyGenerateQcReportSampleqc: Path,
  pyGenerateQcReportVariantqc: Path,
  pyGenerateQcReportBibliography: Path,
  pyGenerateAnalysisReportIntro: Path,
  pyGenerateAnalysisReportData: Path,
  pyGenerateAnalysisReportStrategy: Path,
  pyGenerateAnalysisReportPhenoSummary: Path,
  pyGenerateAnalysisReportPhenoCalibration: Path,
  pyGenerateAnalysisReportPhenoTopLoci: Path,
  pyGenerateAnalysisReportPhenoKnownLoci: Path,
  pyGenerateAnalysisReportBibliography: Path,
  pyMergeVariantLists: Path,
  pyTop1000: Path,
  pyAddGeneAnnot: Path,
  pyPhenoDistPlot: Path) extends Debug

final case class Bash(
  shRegPlot: Path,
  shAnnotate: Path,
  shKing: Path,
  shPlinkPrepare: Path,
  shPlinkToVcfNoHalfCalls: Path,
  shCrossCohortCommonVariants: Path,
  shMetaCohortSamples: Path,
  shKlustakwikPca: Path,
  shKlustakwikMetric: Path,
  shTop1000Genes: Path) extends Debug

final case class R(
  rFindBestDuplicateVariants: Path,
  rAncestryClusterMerge: Path,
  rAncestryClusterTable: Path,
  rCalcKinshipFamSizes: Path,
  rPcair: Path,
  rPlotAncestryPca: Path,
  rPlotAncestryCluster: Path,
  rIstatsPcsGmmClusterPlot: Path,
  rIstatsAdjGmmPlotMetrics: Path,
  rCalcIstatsAdj: Path,
  rIstatsAdjPca: Path,
  rExcludeCrossArray: Path,
  rGeneratePheno: Path,
  rVariantsSummaryTable: Path,
  rUpsetplotBimFam: Path,
  rMakeOutlierTable: Path,
  rMakeMetricDistPlot: Path,
  rTop20: Path,
  rTop50Known: Path,
  rMetaExclusionsTable: Path) extends Debug

final case class Utils(
  imagesDir: Path,
  scriptsDir: Path,
  image: Image,
  binary: Binary,
  python: Python,
  bash: Bash,
  r: R) extends Debug

object ProjectConfig {

  def parseConfig(config: loamstream.conf.DataConfig): ProjectConfig = {

    // required global values in conf file
    val loamstreamVersion = requiredStr(config = config, field = "loamstreamVersion")
    val pipelineVersion = requiredStr(config = config, field = "pipelineVersion")
    val projectId = requiredStr(config = config, field = "projectId")
    val home = path(checkPath(requiredStr(config = config, field = "home", default = Some("./loam_out"))))
    val hailCloud = requiredBool(config = config, field = "hailCloud")
    val cloudShare = optionalStr(config = config, field = "cloudShare") match { case Some(s) => Some(uri(s)); case None => None }
    val cloudHome = optionalStr(config = config, field = "cloudHome") match { case Some(s) => Some(uri(s)); case None => None }
    val referenceGenome = requiredStr(config = config, field = "referenceGenome", regex = "GRCh37|GRCh38")
    val regionsExclude = requiredStr(config = config, field = "regionsExclude")
    val genePositions = requiredStr(config = config, field = "genePositions")
    val kgPurcellVcf = requiredStr(config = config, field = "kgPurcellVcf")
    val kgSample = requiredStr(config = config, field = "kgSample")
    val kgSampleId = requiredStr(config = config, field = "kgSampleId")
    val kgSamplePop = requiredStr(config = config, field = "kgSamplePop")
    val kgSampleGroup = requiredStr(config = config, field = "kgSampleGroup")
    val kgVcf = requiredStr(config = config, field = "kgVcf")
    val kgIds = requiredStr(config = config, field = "kgIds")
    val humanReferenceWild = requiredStr(config = config, field = "humanReferenceWild")
    val fasta = requiredStr(config = config, field = "fasta")
    val vepCacheDir = requiredStr(config = config, field = "vepCacheDir")
    val vepPluginsDir = requiredStr(config = config, field = "vepPluginsDir")
    val dbNSFP = requiredStr(config = config, field = "dbNSFP")
    val sampleFile = requiredStr(config = config, field = "sampleFile")
    val sampleFileId = requiredStr(config = config, field = "sampleFileId")
    val sampleFileSrSex = requiredStr(config = config, field = "sampleFileSrSex")
    val sampleFileMaleCode = requiredStr(config = config, field = "sampleFileMaleCode")
    val sampleFileFemaleCode = requiredStr(config = config, field = "sampleFileFemaleCode")
    val sampleFileSrRace = requiredStr(config = config, field = "sampleFileSrRace")
    val sampleFileAFRCodes = requiredStrList(config = config, field = "sampleFileAFRCodes")
    val sampleFileAMRCodes = requiredStrList(config = config, field = "sampleFileAMRCodes")
    val sampleFileEURCodes = requiredStrList(config = config, field = "sampleFileEURCodes")
    val sampleFileEASCodes = requiredStrList(config = config, field = "sampleFileEASCodes")
    val sampleFileSASCodes = requiredStrList(config = config, field = "sampleFileSASCodes")
    val phenoFile = requiredStr(config = config, field = "phenoFile")
    val phenoFileId = requiredStr(config = config, field = "phenoFileId")
    val authors = requiredStrList(config = config, field = "authors")
    val email = requiredStr(config = config, field = "email")
    val organization = requiredStr(config = config, field = "organization")
    val acknowledgementsAnalysisReport = requiredStrList(config = config, field = "acknowledgementsAnalysisReport")
    val acknowledgementsQcReport = requiredStrList(config = config, field = "acknowledgementsQcReport")
    val maxSigRegions = optionalInt(config = config, field = "maxSigRegions")
    val nAncestryInferenceFeatures = requiredInt(config = config, field = "nAncestryInferenceFeatures", default=Some(3))
    val minPCs = requiredInt(config = config, field = "minPCs")
    val maxPCs = requiredInt(config = config, field = "maxPCs")
    val nStddevs = requiredInt(config = config, field = "nStddevs")

    val resources = ConfigResources(
      preparePlink = {
        val thisConfig = requiredObj(config = config, field = "preparePlink")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      prepareFindBestDuplicateVariants = {
        val thisConfig = requiredObj(config = config, field = "prepareFindBestDuplicateVariants")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      prepareLiftOver = {
        val thisConfig = requiredObj(config = config, field = "prepareLiftOver")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      harmonizePlinkFull = {
        val thisConfig = requiredObj(config = config, field = "harmonizePlinkFull")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      harmonizeGenotypeHarmonizer = {
        val thisConfig = requiredObj(config = config, field = "harmonizeGenotypeHarmonizer")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      harmonizeAlignNon1kgVariants = {
        val thisConfig = requiredObj(config = config, field = "harmonizeAlignNon1kgVariants")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      harmonizePlinkChr = {
        val thisConfig = requiredObj(config = config, field = "harmonizePlinkChr")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      loadHail = {
        val thisConfig = requiredObj(config = config, field = "loadHail")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      filterHail = {
        val thisConfig = requiredObj(config = config, field = "filterHail")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      prunePlink = {
        val thisConfig = requiredObj(config = config, field = "prunePlink")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      annotate = {
        val thisConfig = requiredObj(config = config, field = "annotate")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      kinshipKing = {
        val thisConfig = requiredObj(config = config, field = "kinshipKing")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      ancestryPcaHail = {
        val thisConfig = requiredObj(config = config, field = "ancestryPcaHail")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      ancestryPcaPlink = {
        val thisConfig = requiredObj(config = config, field = "ancestryPcaPlink")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      ancestryPcaPcair = {
        val thisConfig = requiredObj(config = config, field = "ancestryPcaPcair")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      ancestryClusterKlustakwik = {
        val thisConfig = requiredObj(config = config, field = "ancestryClusterKlustakwik")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      pca = {
        val thisConfig = requiredObj(config = config, field = "pca")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      sampleQcHail = {
        val thisConfig = requiredObj(config = config, field = "sampleQcHail")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      sampleQcKlustakwikPca = {
        val thisConfig = requiredObj(config = config, field = "sampleQcKlustakwikPca")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      sampleQcKlustakwikMetric = {
        val thisConfig = requiredObj(config = config, field = "sampleQcKlustakwikMetric")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      filterFinalHail = {
        val thisConfig = requiredObj(config = config, field = "filterFinalHail")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      filterFinalPlink = {
        val thisConfig = requiredObj(config = config, field = "filterFinalPlink")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      filterFinalPcair = {
        val thisConfig = requiredObj(config = config, field = "filterFinalPcair")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      filterImputePlink = {
        val thisConfig = requiredObj(config = config, field = "filterImputePlink")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      variantAssocHailAssoc = {
        val thisConfig = requiredObj(config = config, field = "variantAssocHailAssoc")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      variantAssocGeneratePheno = {
        val thisConfig = requiredObj(config = config, field = "variantAssocGeneratePheno")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      crossCohortPrepPlink = {
        val thisConfig = requiredObj(config = config, field = "crossCohortPrepPlink")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      crossCohortKinshipPlink = {
        val thisConfig = requiredObj(config = config, field = "crossCohortKinshipPlink")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      crossCohortKinshipKing = {
        val thisConfig = requiredObj(config = config, field = "crossCohortKinshipKing")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      metaAnalysisHail = {
        val thisConfig = requiredObj(config = config, field = "metaAnalysisHail")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      mergeAssocHail = {
        val thisConfig = requiredObj(config = config, field = "mergeAssocHail")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      }
    )

    // inferred global values
    val ancestryInferenceFeatures = "1" * nAncestryInferenceFeatures + "0" * (20 - nAncestryInferenceFeatures)

    // arrays
    val Arrays = {
    
      for {
        array <- requiredObjList(config = config, field = "arrays")
      } yield {

        val technology = requiredStr(config = array, field = "technology")
    
        ConfigArray(
          id = requiredStr(config = array, field = "id", regex = "^[a-zA-Z0-9_]*$"),
          filename = requiredStr(config = array, field = "filename"),
          format = requiredStr(config = array, field = "format"),
          technology = technology,
          description = requiredStr(config = array, field = "description"),
          minPartitions = optionalInt(config = array, field = "minPartitions"),
          liftOver = optionalStr(config = array, field = "liftOver"),
          sampleQcMetrics = optionalStrList(config = array, field = "sampleQcMetrics") match { 
            case None =>
              technology match {
                case "wes" | "wgs" => defaultSampleMetricsSeq
                case _ => defaultSampleMetricsGwas
              }
            case Some(s) => s
          },
          nSampleMetricPcs = optionalInt(config = array, field = "nSampleMetricPcs"),
          sampleMetricCovars = optionalStrList(config = array, field = "sampleMetricCovars") match { case Some(s) => Some(s.mkString("+")); case None => None },
          xChr = requiredBool(config = array, field = "xChr"),
          yChr = requiredBool(config = array, field = "yChr"),
          mtChr = requiredBool(config = array, field = "mtChr"),
          skipGh = requiredStrList(config = array, field = "skipGh"),
          gqThreshold = optionalInt(config = array, field = "gqThreshold"),
          qcVariantFilters = optionalObj(config = array, field = "qcVariantFilters") match {
            case Some(o) =>
              Some(ConfigVariantFilters(
                call_rate = optionalStr(config = o, field = "call_rate") match { case Some(s) => Some(intervalToExpression("call_rate", s)); case None => None },
                AC = optionalStr(config = o, field = "AC") match { case Some(s) => Some(intervalToExpression("AC", s)); case None => None },
                AF = optionalStr(config = o, field = "AF") match { case Some(s) => Some(intervalToExpression("AF", s)); case None => None },
                het = optionalStr(config = o, field = "het") match { case Some(s) => Some(intervalToExpression("het", s)); case None => None },
                avg_het_ab = optionalStr(config = o, field = "avg_het_ab") match { case Some(s) => Some(intervalToExpression("avg_het_ab", s)); case None => None },
                sample_n = optionalInt(config = o, field = "sample_n"),
                sample_seed = optionalInt(config = o, field = "sample_seed"),
                AN = None,
                n_called = None,
                n_not_called = None,
                homozygote_count = None,
                n_het = None,
                n_non_ref = None,
                avg_ab = None,
                het_freq_hwe = None,
                p_value_hwe = None))
            case None => None
          },
          ancestryOutliersKeep = requiredStrList(config = array, field = "ancestryOutliersKeep"),
          duplicatesKeep = requiredStrList(config = array, field = "duplicatesKeep"),
          famsizeKeep = requiredStrList(config = array, field = "famsizeKeep"),
          sampleqcKeep = requiredStrList(config = array, field = "sampleqcKeep"),
          sexcheckKeep = requiredStrList(config = array, field = "sexcheckKeep"),
          analysisSampleFilters = optionalObj(config = array, field = "analysisSampleFilters") match {
            case Some(o) =>
              Some(ConfigSampleFilters(
                n_non_ref = optionalStr(config = o, field = "n_non_ref") match { case Some(s) => Some(intervalToExpression("n_non_ref", s)); case None => None },
                n_het = optionalStr(config = o, field = "n_het") match { case Some(s) => Some(intervalToExpression("n_het", s)); case None => None },
                n_called = optionalStr(config = o, field = "n_called") match { case Some(s) => Some(intervalToExpression("n_called", s)); case None => None },
                call_rate = optionalStr(config = o, field = "call_rate") match { case Some(s) => Some(intervalToExpression("call_rate", s)); case None => None },
                n_singleton = optionalStr(config = o, field = "n_singleton") match { case Some(s) => Some(intervalToExpression("n_singleton", s)); case None => None },
                r_ti_tv = optionalStr(config = o, field = "r_ti_tv") match { case Some(s) => Some(intervalToExpression("r_ti_tv", s)); case None => None },
                het = optionalStr(config = o, field = "het") match { case Some(s) => Some(intervalToExpression("het", s)); case None => None },
                het_low = optionalStr(config = o, field = "het_low") match { case Some(s) => Some(intervalToExpression("het_low", s)); case None => None },
                het_high = optionalStr(config = o, field = "het_high") match { case Some(s) => Some(intervalToExpression("het_high", s)); case None => None },
                n_hom_var = optionalStr(config = o, field = "n_hom_var") match { case Some(s) => Some(intervalToExpression("n_hom_var", s)); case None => None },
                r_het_hom_var = optionalStr(config = o, field = "r_het_hom_var") match { case Some(s) => Some(intervalToExpression("r_het_hom_var", s)); case None => None },
                avg_ab = optionalStr(config = o, field = "avg_ab") match { case Some(s) => Some(intervalToExpression("avg_ab", s)); case None => None },
                avg_ab50 = optionalStr(config = o, field = "avg_ab50") match { case Some(s) => Some(intervalToExpression("avg_ab50", s)); case None => None }))
            case None => None
          },
          analysisVariantFilters = optionalObj(config = array, field = "analysisVariantFilters") match {
            case Some(o) =>
              Some(ConfigVariantFilters(
                call_rate = optionalStr(config = o, field = "call_rate") match { case Some(s) => Some(intervalToExpression("call_rate", s)); case None => None },
                AC = optionalStr(config = o, field = "AC") match { case Some(s) => Some(intervalToExpression("AC", s)); case None => None },
                AF = optionalStr(config = o, field = "AF") match { case Some(s) => Some(intervalToExpression("AF", s)); case None => None },
                AN = optionalStr(config = o, field = "AN") match { case Some(s) => Some(intervalToExpression("AN", s)); case None => None },
                n_called = optionalStr(config = o, field = "n_called") match { case Some(s) => Some(intervalToExpression("n_called", s)); case None => None },
                n_not_called = optionalStr(config = o, field = "n_not_called") match { case Some(s) => Some(intervalToExpression("n_not_called", s)); case None => None },
                homozygote_count = optionalStr(config = o, field = "homozygote_count") match { case Some(s) => Some(intervalToExpression("homozygote_count", s)); case None => None },
                n_het = optionalStr(config = o, field = "n_het") match { case Some(s) => Some(intervalToExpression("n_het", s)); case None => None },
                n_non_ref = optionalStr(config = o, field = "n_non_ref") match { case Some(s) => Some(intervalToExpression("n_non_ref", s)); case None => None },
                avg_ab = optionalStr(config = o, field = "avg_ab") match { case Some(s) => Some(intervalToExpression("avg_ab", s)); case None => None },
                het_freq_hwe = optionalStr(config = o, field = "het_freq_hwe") match { case Some(s) => Some(intervalToExpression("het_freq_hwe", s)); case None => None },
                p_value_hwe = optionalStr(config = o, field = "p_value_hwe") match { case Some(s) => Some(intervalToExpression("p_value_hwe", s)); case None => None },
                het = optionalStr(config = o, field = "het") match { case Some(s) => Some(intervalToExpression("het", s)); case None => None },
                avg_het_ab = optionalStr(config = o, field = "avg_het_ab") match { case Some(s) => Some(intervalToExpression("avg_het_ab", s)); case None => None },
                sample_n = optionalInt(config = o, field = "sample_n"),
                sample_seed = optionalInt(config = o, field = "sample_n")))
            case None => None
          })
    
      }
    
    }

    val Cohorts = {
    
      for {
        cohort <- requiredObjList(config = config, field = "cohorts")
      } yield {
    
        ConfigCohort(
          id = requiredStr(config = cohort, field = "id"),
          array = requiredStr(config = cohort, field = "array"),
          ancestry = requiredStrList(config = cohort, field = "ancestry"),
          minPartitions = optionalInt(config = cohort, field = "minPartitions")
        )
    
      }
    
    }

    val Metas = {
    
      for {
        meta <- requiredObjList(config = config, field = "metas")
      } yield {
    
        ConfigMeta(
          id = requiredStr(config = meta, field = "id"),
          cohorts = requiredStrList(config = meta, field = "cohorts"),
          minPartitions = optionalInt(config = meta, field = "minPartitions")
        )
    
      }
    
    }

    val Merges = {
    
      for {
        merge <- requiredObjList(config = config, field = "merges")
      } yield {
    
        ConfigMerge(
          id = requiredStr(config = merge, field = "id"),
          cohorts_metas = requiredStrList(config = merge, field = "cohorts_metas"),
          minPartitions = optionalInt(config = merge, field = "minPartitions")
        )
    
      }
    
    }

    val Phenos = {
    
      for {
        pheno <- requiredObjList(config = config, field = "phenos")
      } yield {
    
        ConfigPheno(
          id = requiredStr(config = pheno, field = "id"),
          name = requiredStr(config = pheno, field = "name")
        )
    
      }
    
    }

    val Models = {
    
      for {
        model <- requiredObjList(config = config, field = "models")
      } yield {
    
        ConfigModel(
          id = requiredStr(config = model, field = "id"),
          pheno = requiredStr(config = model, field = "pheno"),
          trans = requiredStr(config = model, field = "trans"),
          test = requiredStr(config = model, field = "test"),
          covars = requiredStrList(config = model, field = "covars").mkString("+")
        )
      }
    
    }

    val Knowns = {
    
      for {
        known <- requiredObjList(config = config, field = "knowns")
      } yield {
    
        ConfigKnown(
          id = requiredStr(config = known, field = "id"),
          data = requiredStr(config = known, field = "data"),
          hiLd = requiredStr(config = known, field = "hiLd"),
          n = getStrOrBlank(config = known, field = "n"),
          nCase = getStrOrBlank(config = known, field = "nCase"),
          nCtrl = getStrOrBlank(config = known, field = "nCtrl"),
          desc = requiredStr(config = known, field = "desc"),
          citation = requiredStr(config = known, field = "citation")
        )
    
      }
    
    }

    val Reports = {
    
      for {
        report <- requiredObjList(config = config, field = "reports")
      } yield {
    
        ConfigReport(
          id = requiredStr(config = report, field = "id"),
          name = requiredStr(config = report, field = "name"),
          sections = for {
            section <- requiredObjList(config = report, field = "sections")
          } yield {
    
            ConfigSection(
              id = requiredStr(config = section, field = "id"),
              title = requiredStr(config = section, field = "title"),
              models = requiredStrList(config = section, field = "models"),
              cohorts = optionalStrList(config = section, field = "cohorts"),
              metas = optionalStrList(config = section, field = "metas"),
              merges = optionalStrList(config = section, field = "merges"),
              knowns = optionalStrList(config = section, field = "knowns")
            )
          
          }

        )

      }
    
    }

    val nArrays = Arrays.size
    val nCohorts = Cohorts.size
    val nMetas = Metas.size

    new ProjectConfig(

      loamstreamVersion = loamstreamVersion,
      pipelineVersion = pipelineVersion,
      projectId = projectId,
      home = home,
      hailCloud = hailCloud,
      cloudHome = cloudHome,
      cloudShare = cloudShare,
      referenceGenome = referenceGenome,
      regionsExclude = regionsExclude,
      genePositions = genePositions,
      kgPurcellVcf = kgPurcellVcf,
      kgSample = kgSample,
      kgSampleId = kgSampleId,
      kgSamplePop = kgSamplePop,
      kgSampleGroup = kgSampleGroup,
      kgVcf = kgVcf,
      kgIds = kgIds,
      humanReferenceWild = humanReferenceWild,
      fasta = fasta,
      vepCacheDir = vepCacheDir,
      vepPluginsDir = vepPluginsDir,
      dbNSFP = dbNSFP,
      sampleFile = sampleFile,
      sampleFileId = sampleFileId,
      sampleFileSrSex = sampleFileSrSex,
      sampleFileMaleCode = sampleFileMaleCode,
      sampleFileFemaleCode = sampleFileFemaleCode,
      sampleFileSrRace = sampleFileSrRace,
      sampleFileAFRCodes = sampleFileAFRCodes,
      sampleFileAMRCodes = sampleFileAMRCodes,
      sampleFileEURCodes = sampleFileEURCodes,
      sampleFileEASCodes = sampleFileEASCodes,
      sampleFileSASCodes = sampleFileSASCodes,
      phenoFile = phenoFile,
      phenoFileId = phenoFileId,
      authors = authors,
      email = email,
      organization = organization,
      acknowledgementsAnalysisReport = acknowledgementsAnalysisReport,
      acknowledgementsQcReport = acknowledgementsQcReport,
      nAncestryInferenceFeatures = nAncestryInferenceFeatures,
      ancestryInferenceFeatures = ancestryInferenceFeatures,
      minPCs = minPCs,
      maxPCs = maxPCs,
      nStddevs = nStddevs,
      resources = resources,
      nArrays = nArrays,
      nCohorts = nCohorts,
      nMetas = nMetas,
      maxSigRegions = maxSigRegions,
      Arrays = Arrays,
      Cohorts = Cohorts,
      Metas = Metas,
      Merges = Merges,
      Phenos = Phenos,
      Models = Models,
      Knowns = Knowns,
      Reports = Reports

    )

  }

  def parseUtils(config: loamstream.conf.DataConfig): Utils = {

    val imagesDir = path(checkPath(requiredStr(config = config, field = "imagesDir")))
    val scriptsDir = path(checkPath(requiredStr(config = config, field = "scriptsDir")))

    val image = Image(
      imgHail = path(s"${imagesDir}/data_processing_v2.2_hailv02.simg"),
      imgLocuszoom = path(s"${imagesDir}/locuszoom.simg"),
      imgPython27 = path(s"${imagesDir}/data_processing_v2.2_python27.simg"),
      imgR34 = path(s"${imagesDir}/data_processing_v2.2_r34.simg"),
      imgTools = path(s"${imagesDir}/data_processing_v2.2_tools.simg"),
      imgTex = path(s"${imagesDir}/tex.simg"),
      imgEnsemblVep = path(s"${imagesDir}/ensembl_vep.simg")
    )

    val binary = Binary(
      binLiftOver = path("/usr/local/bin/liftOver"),
      binGenotypeHarmonizer = path("GenotypeHarmonizer"),
      binKing = path("/usr/local/bin/king"),
      binPlink = path("/usr/local/bin/plink"),
      binTabix = path("/usr/local/bin/tabix"),
      binGhostscript = path("/usr/local/bin/gs"),
      binKlustakwik = path("/usr/local/bin/KlustaKwik"),
      binPython = path("/usr/local/bin/python"),
      binLocuszoom = path("/usr/local/bin/locuszoom"),
      binPdflatex = path("/usr/local/bin/pdflatex"),
      binRscript = path("/usr/local/bin/Rscript")
    )

    val python = Python(
      pyAlignNon1kgVariants = path(s"${scriptsDir}/align_non1kg_variants.py"),
      pyHailLoad = path(s"${scriptsDir}/hail_load.py"),
      pyHailExportQcData = path(s"${scriptsDir}/hail_export_qc_data.py"),
      pyHailAncestryPcaMerge1kg = path(s"${scriptsDir}/hail_ancestry_pca_merge_1kg.py"),
      pyHailPcaMerge1kg = path(s"${scriptsDir}/hail_pca_merge_1kg.py"),
      pyHailSampleqc = path(s"${scriptsDir}/hail_sampleqc.py"),
      pyHailFilter = path(s"${scriptsDir}/hail_filter.py"),
      pyHailAssoc = path(s"${scriptsDir}/hail_assoc.py"),
      pyHailMerge = path(s"${scriptsDir}/hail_merge.py"),
      pyHailMetaAnalysis = path(s"${scriptsDir}/hail_meta_analysis.py"),
      pyQqPlot = path(s"${scriptsDir}/qqplot.py"),
      pyMhtPlot = path(s"${scriptsDir}/mhtplot.py"),
      pyExtractTopRegions = path(s"${scriptsDir}/extract_top_regions.py"),
      pyMakeSamplesRestoreTable = path(s"${scriptsDir}/make_samples_restore_table.py"),
      pyCompileExclusions = path(s"${scriptsDir}/compile_exclusions.py"),
      pyGenerateReportHeader = path(s"${scriptsDir}/generate_report_header.py"),
      pyGenerateQcReportIntro = path(s"${scriptsDir}/generate_qc_report_intro.py"),
      pyGenerateQcReportData = path(s"${scriptsDir}/generate_qc_report_data.py"),
      pyGenerateQcReportAncestry = path(s"${scriptsDir}/generate_qc_report_ancestry.py"),
      pyGenerateQcReportIbdSexcheck = path(s"${scriptsDir}/generate_qc_report_ibd_sexcheck.py"),
      pyGenerateQcReportSampleqc = path(s"${scriptsDir}/generate_qc_report_sampleqc.py"),
      pyGenerateQcReportVariantqc = path(s"${scriptsDir}/generate_qc_report_variantqc.py"),
      pyGenerateQcReportBibliography = path(s"${scriptsDir}/generate_qc_report_bibliography.py"),
      pyGenerateAnalysisReportIntro = path(s"${scriptsDir}/generate_analysis_report_intro.py"),
      pyGenerateAnalysisReportData = path(s"${scriptsDir}/generate_analysis_report_data.py"),
      pyGenerateAnalysisReportStrategy = path(s"${scriptsDir}/generate_analysis_report_strategy.py"),
      pyGenerateAnalysisReportPhenoSummary = path(s"${scriptsDir}/generate_analysis_report_pheno_summary.py"),
      pyGenerateAnalysisReportPhenoCalibration = path(s"${scriptsDir}/generate_analysis_report_pheno_calibration.py"),
      pyGenerateAnalysisReportPhenoTopLoci = path(s"${scriptsDir}/generate_analysis_report_pheno_top_loci.py"),
      pyGenerateAnalysisReportPhenoKnownLoci = path(s"${scriptsDir}/generate_analysis_report_pheno_known_loci.py"),
      pyGenerateAnalysisReportBibliography = path(s"${scriptsDir}/generate_analysis_report_bibliography.py"),
      pyMergeVariantLists = path(s"${scriptsDir}/merge_variant_lists.py"),
      pyTop1000 = path(s"${scriptsDir}/top1000.py"),
      pyAddGeneAnnot = path(s"${scriptsDir}/add_gene_annot.py"),
      pyPhenoDistPlot = path(s"${scriptsDir}/pheno_dist_plot.py")
    )

    val bash = Bash(
      shRegPlot = path(s"${scriptsDir}/regplot.sh"),
      shAnnotate = path(s"${scriptsDir}/annotate.sh"),
      shKing = path(s"${scriptsDir}/king.sh"),
      shPlinkPrepare = path(s"${scriptsDir}/plink_prepare.sh"),
      shPlinkToVcfNoHalfCalls = path(s"${scriptsDir}/plink_to_vcf_no_half_calls.sh"),
      shCrossCohortCommonVariants = path(s"${scriptsDir}/cross_cohort_common_variants.sh"),
      shMetaCohortSamples = path(s"${scriptsDir}/meta_cohort_samples.sh"),
      shKlustakwikPca = path(s"${scriptsDir}/klustakwik.pca.sh"),
      shKlustakwikMetric = path(s"${scriptsDir}/klustakwik.metric.sh"),
      shTop1000Genes = path(s"${scriptsDir}/top1000_genes.sh")
    )

    val r = R(
      rFindBestDuplicateVariants = path(s"${scriptsDir}/find_best_duplicate_variants.r"),
      rAncestryClusterMerge = path(s"${scriptsDir}/ancestry_cluster_merge.r"),
      rAncestryClusterTable = path(s"${scriptsDir}/ancestry_cluster_table.r"),
      rCalcKinshipFamSizes = path(s"${scriptsDir}/calc_kinship_fam_sizes.r"),
      rPcair = path(s"${scriptsDir}/pcair.r"),
      rPlotAncestryPca = path(s"${scriptsDir}/plot_ancestry_pca.r"),
      rPlotAncestryCluster = path(s"${scriptsDir}/plot_ancestry_cluster.r"),
      rIstatsPcsGmmClusterPlot = path(s"${scriptsDir}/istats_pcs_gmm_cluster_plot.r"),
      rIstatsAdjGmmPlotMetrics = path(s"${scriptsDir}/istats_adj_gmm_plot_metrics.r"),
      rCalcIstatsAdj = path(s"${scriptsDir}/calc_istats_adj.r"),
      rIstatsAdjPca = path(s"${scriptsDir}/istats_adj_pca.r"),
      rExcludeCrossArray = path(s"${scriptsDir}/exclude_cross_array.r"),
      rGeneratePheno = path(s"${scriptsDir}/generate_pheno.r"),
      rVariantsSummaryTable = path(s"${scriptsDir}/variants_summary_table.r"),
      rUpsetplotBimFam = path(s"${scriptsDir}/upsetplot.bimfam.r"),
      rMakeOutlierTable = path(s"${scriptsDir}/make_outlier_table.r"),
      rMakeMetricDistPlot = path(s"${scriptsDir}/make_metric_dist_plot.r"),
      rTop20 = path(s"${scriptsDir}/top20.r"),
      rTop50Known = path(s"${scriptsDir}/top50_known.r"),
      rMetaExclusionsTable = path(s"${scriptsDir}/meta_exclusions_table.r")
    )

    new Utils(
      imagesDir = imagesDir,
      scriptsDir = scriptsDir,
      image = image,
      binary = binary,
      python = python,
      bash = bash,
      r = r)

  }

}

// Initialize configuration and utilities, verify them, and write all objects to file
println("Loading Project Configuration File ...")
val dataConfig = loadConfig("dataConfig", "")

val projectConfig = ProjectConfig.parseConfig(dataConfig)
projectConfig.debugVars()
for ( d <- projectConfig.Arrays ) { d.debugVars() }
for ( d <- projectConfig.Cohorts ) { d.debugVars() }
for ( d <- projectConfig.Metas ) { d.debugVars() }
for ( d <- projectConfig.Merges ) { d.debugVars() }
for ( d <- projectConfig.Phenos ) { d.debugVars() }
for ( d <- projectConfig.Models ) { d.debugVars() }
for ( d <- projectConfig.Knowns ) { d.debugVars() }
for ( d <- projectConfig.Reports ) { d.debugVars() }
println("... Project Configuration Loaded Successfully!")

println("Loading Pipeline Utilities Configuration ...")
val utils = ProjectConfig.parseUtils(dataConfig)
utils.debugVars()
utils.image.debugVars()
utils.binary.debugVars()
utils.python.debugVars()
utils.bash.debugVars()
utils.r.debugVars()
println("... Pipeline Utilities Configuration Loaded Successfully!")