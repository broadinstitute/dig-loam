import Fxns._
import loamstream.googlecloud.ClusterConfig

val defaultSampleMetricsGwas = Seq("n_non_ref","n_het","n_called","call_rate","r_ti_tv","het","het_low","het_high","n_hom_var","r_het_hom_var")
val defaultSampleMetricsSeq = Seq("n_non_ref","n_het","n_called","call_rate","r_ti_tv","het","het_low","het_high","n_hom_var","r_het_hom_var","n_singleton","avg_ab","avg_ab50")

final case class ConfigMachine(
  cpus: Int,
  mem: Int,
  maxRunTime: Int) extends Debug

final case class ConfigNumericFilters(
  id: String,
  field: String,
  range: String,
  expression: String) extends Debug

final case class ConfigBooleanFilters(
  id: String,
  field: String,
  value: Boolean,
  expression: String) extends Debug

final case class ConfigCategoricalFilters(
  id: String,
  field: String,
  values: Seq[String],
  expression: String) extends Debug

final case class ConfigCompoundFilters(
  id: String,
  filters: Seq[String],
  expression: String) extends Debug

final case class ConfigCloudResources(
  loadCluster: ClusterConfig) extends Debug

final case class ConfigResources(
  preparePlink: ConfigMachine,
  prepareFindBestDuplicateVariants: ConfigMachine,
  prepareLiftOver: ConfigMachine,
  harmonizePlinkFull: ConfigMachine,
  harmonizeGenotypeHarmonizer: ConfigMachine,
  harmonizeAlignNon1kgVariants: ConfigMachine,
  harmonizePlinkChr: ConfigMachine,
  loadHail: ConfigMachine,
  filterHail: ConfigMachine,
  prunePlink: ConfigMachine,
  annotate: ConfigMachine,
  kinshipKing: ConfigMachine,
  ancestryPcaHail: ConfigMachine,
  ancestryPcaPlink: ConfigMachine,
  ancestryPcaFlashPca: ConfigMachine,
  ancestryClusterKlustakwik: ConfigMachine,
  pca: ConfigMachine,
  sampleQcHail: ConfigMachine,
  sampleQcKlustakwikPca: ConfigMachine,
  sampleQcKlustakwikMetric: ConfigMachine,
  filterFinalHail: ConfigMachine,
  exportCleanHail: ConfigMachine,
  tabixClean: ConfigMachine,
  filterImputePlink: ConfigMachine,
  variantAssocHailAssoc: ConfigMachine,
  variantAssocGeneratePheno: ConfigMachine,
  crossCohortPrepPlink: ConfigMachine,
  crossCohortKinshipPlink: ConfigMachine,
  crossCohortKinshipKing: ConfigMachine,
  metaAnalysisHail: ConfigMachine,
  mergeAssocHail: ConfigMachine) extends Debug

final case class ConfigArray(
  id: String,
  filename: String,
  format: String,
  technology: String,
  description: String,
  minPartitions: Option[Int],
  liftOver: Option[String] = None,
  sampleQcMetrics: Seq[String],
  nSampleMetricPcs: Option[Int],
  sampleMetricCovars: Option[String],
  chrs: Seq[String],
  gqThreshold: Option[Int],
  ancestryOutliersKeep: Seq[String],
  duplicatesKeep: Seq[String],
  famsizeKeep: Seq[String],
  sampleqcKeep: Seq[String],
  sexcheckKeep: Seq[String],
  qcVariantFilters: Option[Seq[String]],
  qcVariantSampleN: Option[Int],
  qcVariantSampleSeed: Option[Int],
  postQcSampleFilters: Option[Seq[String]],
  postQcVariantFilters: Option[Seq[String]]) extends Debug

final case class ConfigCohort(
  id: String,
  array: String,
  ancestry: Seq[String],
  stratCol: Option[String],
  stratCodes: Option[Seq[String]],
  cohortSampleFilters: Option[Seq[String]],
  cohortVariantFilters: Option[Seq[String]],
  resultsVariantFilters: Option[Seq[String]],
  minPartitions: Option[Int]) extends Debug

final case class ConfigMeta(
  id: String,
  cohorts: Seq[String],
  minPartitions: Option[Int]) extends Debug

final case class ConfigMerge(
  id: String,
  cohorts_metas: Seq[String],
  minPartitions: Option[Int]) extends Debug

final case class ConfigPheno(
  id: String,
  name: String) extends Debug

final case class ConfigModel(
  id: String,
  pheno: String,
  trans: String,
  test: String,
  covars: String) extends Debug

final case class ConfigKnown(
  id: String,
  data: String,
  hiLd: String,
  n: String,
  nCase: String,
  nCtrl: String,
  desc: String,
  citation: String) extends Debug

final case class ConfigSection(
  id: String,
  title: String,
  models: Seq[String],
  cohorts: Option[Seq[String]],
  metas: Option[Seq[String]],
  merges: Option[Seq[String]],
  knowns: Option[Seq[String]]) extends Debug

final case class ConfigReport(
  id: String,
  name: String,
  sections: Seq[ConfigSection]) extends Debug

final case class ProjectConfig(
  loamstreamVersion: String,
  pipelineVersion: String,
  hailCloud: Boolean,
  cloudShare: Option[URI],
  cloudHome: Option[URI],
  exportCleanData: Boolean,
  projectId: String,
  referenceGenome: String,
  regionsExclude: String,
  genePositions: String,
  kgPurcellVcf: String,
  kgSample: String,
  kgSampleId: String,
  kgSamplePop: String,
  kgSampleGroup: String,
  kgVcf: String,
  kgIds: String,
  humanReferenceWild: String,
  fasta: String,
  vepCacheDir: String,
  vepPluginsDir: String,
  dbNSFP: String,
  sampleFile: String,
  sampleFileId: String,
  sampleFileSrSex: String,
  sampleFileMaleCode: String,
  sampleFileFemaleCode: String,
  sampleFileSrRace: String,
  sampleFileAFRCodes: Seq[String],
  sampleFileAMRCodes: Seq[String],
  sampleFileEURCodes: Seq[String],
  sampleFileEASCodes: Seq[String],
  sampleFileSASCodes: Seq[String],
  phenoFile: String,
  phenoFileId: String,
  authors: Seq[String],
  email: String,
  organization: String,
  acknowledgementsAnalysisReport: Seq[String],
  acknowledgementsQcReport: Seq[String],
  nAncestryInferenceFeatures: Int,
  ancestryInferenceFeatures: String,
  minPCs: Int,
  maxPCs: Int,
  nStddevs: Int,
  cloudResources: ConfigCloudResources,
  resources: ConfigResources,
  nArrays: Int,
  nCohorts: Int,
  nMetas: Int,
  maxSigRegions: Option[Int],
  numericVariantFilters: Seq[ConfigNumericFilters],
  booleanVariantFilters: Seq[ConfigBooleanFilters],
  categoricalVariantFilters: Seq[ConfigCategoricalFilters],
  compoundVariantFilters: Seq[ConfigCompoundFilters],
  numericSampleFilters: Seq[ConfigNumericFilters],
  booleanSampleFilters: Seq[ConfigBooleanFilters],
  categoricalSampleFilters: Seq[ConfigCategoricalFilters],
  compoundSampleFilters: Seq[ConfigCompoundFilters],
  Arrays: Seq[ConfigArray],
  Cohorts: Seq[ConfigCohort],
  Metas: Seq[ConfigMeta],
  Merges: Seq[ConfigMerge],
  Phenos: Seq[ConfigPheno],
  Models: Seq[ConfigModel],
  Knowns: Seq[ConfigKnown],
  Reports: Seq[ConfigReport]) extends Debug

final case class Image(
  imgHail: Path,
  imgLocuszoom: Path,
  imgPython2: Path,
  imgR: Path,
  imgTools: Path,
  imgTexLive: Path,
  imgEnsemblVep: Path,
  imgFlashPca: Path) extends Debug

final case class Binary(
  binLiftOver: Path,
  binGenotypeHarmonizer: Path,
  binKing: Path,
  binPlink: Path,
  binTabix: Path,
  binGhostscript: Path,
  binKlustakwik: Path,
  binPython: Path,
  binLocuszoom: Path,
  binPdflatex: Path,
  binRscript: Path,
  binFlashPca: Path) extends Debug

final case class Python(
  pyBimToUid: Path,
  pyHailUtils: Path,
  pyAlignNon1kgVariants: Path,
  pyHailLoad: Path,
  pyHailExportQcData: Path,
  pyHailFilter: Path,
  pyHailFilterResults: Path,
  pyHailAncestryPcaMerge1kg: Path,
  pyHailPcaMerge1kg: Path,
  pyHailSampleqc: Path,
  pyHailExportCleanData: Path,
  pyHailAssoc: Path,
  pyHailMerge: Path,
  pyHailMetaAnalysis: Path,
  pyQqPlot: Path,
  pyMhtPlot: Path,
  pyExtractTopRegions: Path,
  pyMakeSamplesRestoreTable: Path,
  pyCompileExclusions: Path,
  pyGenerateReportHeader: Path,
  pyGenerateQcReportIntro: Path,
  pyGenerateQcReportData: Path,
  pyGenerateQcReportAncestry: Path,
  pyGenerateQcReportIbdSexcheck: Path,
  pyGenerateQcReportSampleqc: Path,
  pyGenerateQcReportVariantqc: Path,
  pyGenerateQcReportBibliography: Path,
  pyGenerateAnalysisReportIntro: Path,
  pyGenerateAnalysisReportData: Path,
  pyGenerateAnalysisReportStrategy: Path,
  pyGenerateAnalysisReportPhenoSummary: Path,
  pyGenerateAnalysisReportPhenoCalibration: Path,
  pyGenerateAnalysisReportPhenoTopLoci: Path,
  pyGenerateAnalysisReportPhenoKnownLoci: Path,
  pyGenerateAnalysisReportBibliography: Path,
  pyMergeVariantLists: Path,
  pyTop1000: Path,
  pyAddGeneAnnot: Path,
  pyPhenoDistPlot: Path) extends Debug

final case class Bash(
  shRegPlot: Path,
  shAnnotate: Path,
  shKing: Path,
  shPlinkPrepare: Path,
  shPlinkToVcfNoHalfCalls: Path,
  shCrossCohortCommonVariants: Path,
  shMetaCohortSamples: Path,
  shKlustakwikPca: Path,
  shKlustakwikMetric: Path,
  shTop1000Genes: Path) extends Debug

final case class R(
  rFindBestDuplicateVariants: Path,
  rAncestryClusterMerge: Path,
  rAncestryClusterTable: Path,
  rCalcKinshipFamSizes: Path,
  rPcair: Path,
  rPlotAncestryPca: Path,
  rPlotAncestryCluster: Path,
  rIstatsPcsGmmClusterPlot: Path,
  rIstatsAdjGmmPlotMetrics: Path,
  rCalcIstatsAdj: Path,
  rIstatsAdjPca: Path,
  rExcludeCrossArray: Path,
  rGeneratePheno: Path,
  rVariantsSummaryTable: Path,
  rUpsetplotBimFam: Path,
  rMakeOutlierTable: Path,
  rMakeMetricDistPlot: Path,
  rTop20: Path,
  rTop50Known: Path,
  rMetaExclusionsTable: Path) extends Debug

final case class Utils(
  imagesDir: Path,
  scriptsDir: Path,
  image: Image,
  binary: Binary,
  python: Python,
  bash: Bash,
  r: R) extends Debug

object ProjectConfig {

  def parseConfig(config: loamstream.conf.DataConfig): ProjectConfig = {

    // required global values in conf file
    val loamstreamVersion = requiredStr(config = config, field = "loamstreamVersion")
    val pipelineVersion = requiredStr(config = config, field = "pipelineVersion")
    val projectId = requiredStr(config = config, field = "projectId")
    val hailCloud = requiredBool(config = config, field = "hailCloud")
    val cloudShare = optionalStr(config = config, field = "cloudShare") match { case Some(s) => Some(uri(s)); case None => None }
    val cloudHome = optionalStr(config = config, field = "cloudHome") match { case Some(s) => Some(uri(s)); case None => None }
    val exportCleanData = requiredBool(config = config, field = "exportCleanData")
    val referenceGenome = requiredStr(config = config, field = "referenceGenome", regex = "GRCh37|GRCh38")
    val regionsExclude = requiredStr(config = config, field = "regionsExclude")
    val genePositions = requiredStr(config = config, field = "genePositions")
    val kgPurcellVcf = requiredStr(config = config, field = "kgPurcellVcf")
    val kgSample = requiredStr(config = config, field = "kgSample")
    val kgSampleId = requiredStr(config = config, field = "kgSampleId")
    val kgSamplePop = requiredStr(config = config, field = "kgSamplePop")
    val kgSampleGroup = requiredStr(config = config, field = "kgSampleGroup")
    val kgVcf = requiredStr(config = config, field = "kgVcf")
    val kgIds = requiredStr(config = config, field = "kgIds")
    val humanReferenceWild = requiredStr(config = config, field = "humanReferenceWild")
    val fasta = requiredStr(config = config, field = "fasta")
    val vepCacheDir = requiredStr(config = config, field = "vepCacheDir")
    val vepPluginsDir = requiredStr(config = config, field = "vepPluginsDir")
    val dbNSFP = requiredStr(config = config, field = "dbNSFP")
    val sampleFile = requiredStr(config = config, field = "sampleFile")
    val sampleFileId = requiredStr(config = config, field = "sampleFileId")
    val sampleFileSrSex = requiredStr(config = config, field = "sampleFileSrSex")
    val sampleFileMaleCode = requiredStr(config = config, field = "sampleFileMaleCode")
    val sampleFileFemaleCode = requiredStr(config = config, field = "sampleFileFemaleCode")
    val sampleFileSrRace = requiredStr(config = config, field = "sampleFileSrRace")
    val sampleFileAFRCodes = requiredStrList(config = config, field = "sampleFileAFRCodes")
    val sampleFileAMRCodes = requiredStrList(config = config, field = "sampleFileAMRCodes")
    val sampleFileEURCodes = requiredStrList(config = config, field = "sampleFileEURCodes")
    val sampleFileEASCodes = requiredStrList(config = config, field = "sampleFileEASCodes")
    val sampleFileSASCodes = requiredStrList(config = config, field = "sampleFileSASCodes")
    val phenoFile = requiredStr(config = config, field = "phenoFile")
    val phenoFileId = requiredStr(config = config, field = "phenoFileId")
    val authors = requiredStrList(config = config, field = "authors")
    val email = requiredStr(config = config, field = "email")
    val organization = requiredStr(config = config, field = "organization")
    val acknowledgementsAnalysisReport = requiredStrList(config = config, field = "acknowledgementsAnalysisReport")
    val acknowledgementsQcReport = requiredStrList(config = config, field = "acknowledgementsQcReport")
    val maxSigRegions = optionalInt(config = config, field = "maxSigRegions")
    val nAncestryInferenceFeatures = requiredInt(config = config, field = "nAncestryInferenceFeatures", default=Some(3))
    val minPCs = requiredInt(config = config, field = "minPCs")
    val maxPCs = requiredInt(config = config, field = "maxPCs")
    val nStddevs = requiredInt(config = config, field = "nStddevs")

    val cloudResources = ConfigCloudResources(
      loadCluster = {
        val thisConfig = optionalObj(config = config, field = "loadCluster")
        thisConfig match {
          case Some(o) => 
            ClusterConfig(
              zone = requiredStr(config = o, field = "zone"),
              properties = requiredStr(config = o, field = "properties"),
              masterMachineType = requiredStr(config = o, field = "masterMachineType"),
              masterBootDiskSize = requiredInt(config = o, field = "masterBootDiskSize"),
              workerMachineType = requiredStr(config = o, field = "workerMachineType"),
              workerBootDiskSize = requiredInt(config = o, field = "workerBootDiskSize"),
              numWorkers = requiredInt(config = o, field = "numWorkers"),
              numPreemptibleWorkers = requiredInt(config = o, field = "numPreemptibleWorkers"),
              preemptibleWorkerBootDiskSize = requiredInt(config = o, field = "preemptibleWorkerBootDiskSize"),
              maxClusterIdleTime = requiredStr(config = o, field = "maxClusterIdleTime")
            )
          case None => ClusterConfig()
        }
      }
    )

    val resources = ConfigResources(
      preparePlink = {
        val thisConfig = requiredObj(config = config, field = "preparePlink")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      prepareFindBestDuplicateVariants = {
        val thisConfig = requiredObj(config = config, field = "prepareFindBestDuplicateVariants")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      prepareLiftOver = {
        val thisConfig = requiredObj(config = config, field = "prepareLiftOver")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      harmonizePlinkFull = {
        val thisConfig = requiredObj(config = config, field = "harmonizePlinkFull")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      harmonizeGenotypeHarmonizer = {
        val thisConfig = requiredObj(config = config, field = "harmonizeGenotypeHarmonizer")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      harmonizeAlignNon1kgVariants = {
        val thisConfig = requiredObj(config = config, field = "harmonizeAlignNon1kgVariants")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      harmonizePlinkChr = {
        val thisConfig = requiredObj(config = config, field = "harmonizePlinkChr")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      loadHail = {
        val thisConfig = requiredObj(config = config, field = "loadHail")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      filterHail = {
        val thisConfig = requiredObj(config = config, field = "filterHail")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      prunePlink = {
        val thisConfig = requiredObj(config = config, field = "prunePlink")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      annotate = {
        val thisConfig = requiredObj(config = config, field = "annotate")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      kinshipKing = {
        val thisConfig = requiredObj(config = config, field = "kinshipKing")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      ancestryPcaHail = {
        val thisConfig = requiredObj(config = config, field = "ancestryPcaHail")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      ancestryPcaPlink = {
        val thisConfig = requiredObj(config = config, field = "ancestryPcaPlink")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      ancestryPcaFlashPca = {
        val thisConfig = requiredObj(config = config, field = "ancestryPcaFlashPca")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      ancestryClusterKlustakwik = {
        val thisConfig = requiredObj(config = config, field = "ancestryClusterKlustakwik")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      pca = {
        val thisConfig = requiredObj(config = config, field = "pca")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      sampleQcHail = {
        val thisConfig = requiredObj(config = config, field = "sampleQcHail")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      sampleQcKlustakwikPca = {
        val thisConfig = requiredObj(config = config, field = "sampleQcKlustakwikPca")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      sampleQcKlustakwikMetric = {
        val thisConfig = requiredObj(config = config, field = "sampleQcKlustakwikMetric")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      filterFinalHail = {
        val thisConfig = requiredObj(config = config, field = "filterFinalHail")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      exportCleanHail = {
        val thisConfig = requiredObj(config = config, field = "exportCleanHail")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      tabixClean = {
        val thisConfig = requiredObj(config = config, field = "tabixClean")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      filterImputePlink = {
        val thisConfig = requiredObj(config = config, field = "filterImputePlink")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      variantAssocHailAssoc = {
        val thisConfig = requiredObj(config = config, field = "variantAssocHailAssoc")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      variantAssocGeneratePheno = {
        val thisConfig = requiredObj(config = config, field = "variantAssocGeneratePheno")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      crossCohortPrepPlink = {
        val thisConfig = requiredObj(config = config, field = "crossCohortPrepPlink")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      crossCohortKinshipPlink = {
        val thisConfig = requiredObj(config = config, field = "crossCohortKinshipPlink")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      crossCohortKinshipKing = {
        val thisConfig = requiredObj(config = config, field = "crossCohortKinshipKing")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      metaAnalysisHail = {
        val thisConfig = requiredObj(config = config, field = "metaAnalysisHail")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      },
      mergeAssocHail = {
        val thisConfig = requiredObj(config = config, field = "mergeAssocHail")
        ConfigMachine(cpus = requiredInt(config = thisConfig, field = "cpus"), mem = requiredInt(config = thisConfig, field = "mem"), maxRunTime = requiredInt(config = thisConfig, field = "maxRunTime"))
      }
    )

    // inferred global values
    val ancestryInferenceFeatures = "1" * nAncestryInferenceFeatures + "0" * (20 - nAncestryInferenceFeatures)

    val numericVariantFilters = {
      for {
        vfilter <- requiredObjList(config = config, field = "numericVariantFilters")
      } yield {
        ConfigNumericFilters(
          id = requiredStr(config = vfilter, field = "id", regex = "^[a-zA-Z0-9_]*$"),
          field = requiredStr(config = vfilter, field = "field"),
          range = requiredStr(config = vfilter, field = "range"),
          expression = intervalToExpression(requiredStr(config = vfilter, field = "field"), requiredStr(config = vfilter, field = "range"))
        )
      }
    }

    val booleanVariantFilters = {
      for {
        vfilter <- requiredObjList(config = config, field = "booleanVariantFilters")
      } yield {
        ConfigBooleanFilters(
          id = requiredStr(config = vfilter, field = "id", regex = "^[a-zA-Z0-9_]*$"),
          field = requiredStr(config = vfilter, field = "field"),
          value = requiredBool(config = vfilter, field = "value"),
          expression = booleanToExpression(requiredStr(config = vfilter, field = "field"), requiredStr(config = vfilter, field = "value"))
        )
      }
    }

    val categoricalVariantFilters = {
      for {
        vfilter <- requiredObjList(config = config, field = "categoricalVariantFilters")
      } yield {
        ConfigCategoricalFilters(
          id = requiredStr(config = vfilter, field = "id", regex = "^[a-zA-Z0-9_]*$"),
          field = requiredStr(config = vfilter, field = "field"),
          values = requiredStrList(config = vfilter, field = "values"),
          expression = categoricalToExpression(requiredStr(config = vfilter, field = "field"), requiredStrList(config = vfilter, field = "values"))
        )
      }
    }

    val compoundVariantFilters = {
      for {
        vfilter <- requiredObjList(config = config, field = "compoundVariantFilters")
      } yield {
        val expressions = for {
          f <- requiredStrList(config = vfilter, field = "filters")
        } yield {
          f match {
            case n if numericVariantFilters.map(e => e.id) contains n =>
              numericVariantFilters.filter(e => e.id == n).head.expression
            case b if booleanVariantFilters.map(e => e.id) contains b =>
              booleanVariantFilters.filter(e => e.id == b).head.expression
            case c if categoricalVariantFilters.map(e => e.id) contains c =>
              categoricalVariantFilters.filter(e => e.id == c).head.expression
            case _ => throw new CfgException("compoundVariantFilters: variant filter '" + f + "' not found")
          }
        }
        ConfigCompoundFilters(
          id = requiredStr(config = vfilter, field = "id", regex = "^[a-zA-Z0-9_]*$"),
          filters = requiredStrList(config = vfilter, field = "filters"),
          expression = "(" + expressions.mkString(") & (") + ")"
        )
      }
    }

    val numericSampleFilters = {
      for {
        sfilter <- requiredObjList(config = config, field = "numericSampleFilters")
      } yield {
        ConfigNumericFilters(
          id = requiredStr(config = sfilter, field = "id", regex = "^[a-zA-Z0-9_]*$"),
          field = requiredStr(config = sfilter, field = "field"),
          range = requiredStr(config = sfilter, field = "range"),
          expression = intervalToExpression(requiredStr(config = sfilter, field = "field"), requiredStr(config = sfilter, field = "range"))
        )
      }
    }

    val booleanSampleFilters = {
      for {
        sfilter <- requiredObjList(config = config, field = "booleanSampleFilters")
      } yield {
        ConfigBooleanFilters(
          id = requiredStr(config = sfilter, field = "id", regex = "^[a-zA-Z0-9_]*$"),
          field = requiredStr(config = sfilter, field = "field"),
          value = requiredBool(config = sfilter, field = "value"),
          expression = booleanToExpression(requiredStr(config = sfilter, field = "field"), requiredStr(config = sfilter, field = "value"))
        )
      }
    }

    val categoricalSampleFilters = {
      for {
        sfilter <- requiredObjList(config = config, field = "categoricalSampleFilters")
      } yield {
        ConfigCategoricalFilters(
          id = requiredStr(config = sfilter, field = "id", regex = "^[a-zA-Z0-9_]*$"),
          field = requiredStr(config = sfilter, field = "field"),
          values = requiredStrList(config = sfilter, field = "values"),
          expression = categoricalToExpression(requiredStr(config = sfilter, field = "field"), requiredStrList(config = sfilter, field = "values"))
        )
      }
    }

    val compoundSampleFilters = {
      for {
        sfilter <- requiredObjList(config = config, field = "compoundSampleFilters")
      } yield {
        val expressions = for {
          f <- requiredStrList(config = sfilter, field = "filters")
        } yield {
          f match {
            case n if numericSampleFilters.map(e => e.id) contains n =>
              numericSampleFilters.filter(e => e.id == n).head.expression
            case b if booleanSampleFilters.map(e => e.id) contains b =>
              booleanSampleFilters.filter(e => e.id == b).head.expression
            case c if categoricalSampleFilters.map(e => e.id) contains c =>
              categoricalSampleFilters.filter(e => e.id == c).head.expression
            case _ => throw new CfgException("compoundSampleFilters: sample filter '" + f + "' not found")
          }
        }
        ConfigCompoundFilters(
          id = requiredStr(config = sfilter, field = "id", regex = "^[a-zA-Z0-9_]*$"),
          filters = requiredStrList(config = sfilter, field = "filters"),
          expression = "(" + expressions.mkString(") & (") + ")"
        )
      }
    }

    // arrays
    val Arrays = {
    
      for {
        array <- requiredObjList(config = config, field = "arrays")
      } yield {

        val technology = requiredStr(config = array, field = "technology", regex = "gwas|wgs|wes")

        val qcVariantFilters = optionalStrList(config = array, field = "qcVariantFilters") match {
          case Some(s) =>
            for {
              f <- s
            } yield {
              f match {
                case n if numericVariantFilters.map(e => e.id) contains n => ()
                case b if booleanVariantFilters.map(e => e.id) contains b => ()
                case c if categoricalVariantFilters.map(e => e.id) contains c => ()
                case d if compoundVariantFilters.map(e => e.id) contains d => ()
                case _ => throw new CfgException("arrays.qcVariantFilters: variant filter '" + f + "' not found")
              }
            }
            Some(s)
          case None => None
        }

        val postQcSampleFilters = optionalStrList(config = array, field = "postQcSampleFilters") match {
          case Some(s) =>
            for {
              f <- s
            } yield {
              f match {
                case n if numericSampleFilters.map(e => e.id) contains n => ()
                case b if booleanSampleFilters.map(e => e.id) contains b => ()
                case c if categoricalSampleFilters.map(e => e.id) contains c => ()
                case d if compoundSampleFilters.map(e => e.id) contains d => ()
                case _ => throw new CfgException("arrays.postQcSampleFilters: sample filter '" + f + "' not found")
              }
            }
            Some(s)
          case None => None
        }

        val postQcVariantFilters = optionalStrList(config = array, field = "postQcVariantFilters") match {
          case Some(s) =>
            for {
              f <- s
            } yield {
              f match {
                case n if numericVariantFilters.map(e => e.id) contains n => ()
                case b if booleanVariantFilters.map(e => e.id) contains b => ()
                case c if categoricalVariantFilters.map(e => e.id) contains c => ()
                case d if compoundVariantFilters.map(e => e.id) contains d => ()
                case _ => throw new CfgException("arrays.postQcVariantFilters: variant filter '" + f + "' not found")
              }
            }
            Some(s)
          case None => None
        }
    
        ConfigArray(
          id = requiredStr(config = array, field = "id", regex = "^[a-zA-Z0-9_]*$"),
          filename = requiredStr(config = array, field = "filename"),
          format = requiredStr(config = array, field = "format", regex = "plink|vcf"),
          technology = technology,
          description = requiredStr(config = array, field = "description"),
          minPartitions = optionalInt(config = array, field = "minPartitions"),
          liftOver = optionalStr(config = array, field = "liftOver"),
          sampleQcMetrics = optionalStrList(config = array, field = "sampleQcMetrics") match { 
            case None =>
              technology match {
                case "wes" | "wgs" => defaultSampleMetricsSeq
                case _ => defaultSampleMetricsGwas
              }
            case Some(s) => s
          },
          nSampleMetricPcs = optionalInt(config = array, field = "nSampleMetricPcs"),
          sampleMetricCovars = optionalStrList(config = array, field = "sampleMetricCovars") match { case Some(s) => Some(s.mkString("+")); case None => None },
          chrs = requiredStrList(config = array, field = "chrs", regex = "(([1-9]|1[0-9]|2[0-1])-([2-9]|1[0-9]|2[0-2]))|[1-9]|1[0-9]|2[0-2]|X|Y|MT"),
          gqThreshold = optionalInt(config = array, field = "gqThreshold"),
          ancestryOutliersKeep = requiredStrList(config = array, field = "ancestryOutliersKeep"),
          duplicatesKeep = requiredStrList(config = array, field = "duplicatesKeep"),
          famsizeKeep = requiredStrList(config = array, field = "famsizeKeep"),
          sampleqcKeep = requiredStrList(config = array, field = "sampleqcKeep"),
          sexcheckKeep = requiredStrList(config = array, field = "sexcheckKeep"),
          qcVariantFilters = qcVariantFilters,
          qcVariantSampleN = optionalInt(config = array, field = "qcVariantSampleN"),
          qcVariantSampleSeed = optionalInt(config = array, field = "qcVariantSampleSeed"),
          postQcSampleFilters = postQcSampleFilters,
          postQcVariantFilters = postQcVariantFilters
        )
    
      }
    
    }

    val Cohorts = {
    
      for {
        cohort <- requiredObjList(config = config, field = "cohorts")
      } yield {

        val array = requiredStr(config = cohort, field = "array")
        Arrays.map(e => e.id) contains array match {
          case true => ()
          case false => throw new CfgException("cohorts.array: array '" + array + "' not found")
        }

        val cohortSampleFilters = optionalStrList(config = cohort, field = "cohortSampleFilters") match {
          case Some(s) =>
            for {
              f <- s
            } yield {
              f match {
                case n if numericSampleFilters.map(e => e.id) contains n => ()
                case b if booleanSampleFilters.map(e => e.id) contains b => ()
                case c if categoricalSampleFilters.map(e => e.id) contains c => ()
                case d if compoundSampleFilters.map(e => e.id) contains d => ()
                case _ => throw new CfgException("cohorts.cohortSampleFilters: sample filter '" + f + "' not found")
              }
            }
            Some(s)
          case None => None
        }

        val cohortVariantFilters = optionalStrList(config = cohort, field = "cohortVariantFilters") match {
          case Some(s) =>
            for {
              f <- s
            } yield {
              f match {
                case n if numericVariantFilters.map(e => e.id) contains n => ()
                case b if booleanVariantFilters.map(e => e.id) contains b => ()
                case c if categoricalVariantFilters.map(e => e.id) contains c => ()
                case d if compoundVariantFilters.map(e => e.id) contains d => ()
                case _ => throw new CfgException("cohorts.cohortVariantFilters: variant filter '" + f + "' not found")
              }
            }
            Some(s)
          case None => None
        }

        val resultsVariantFilters = optionalStrList(config = cohort, field = "resultsVariantFilters") match {
          case Some(s) =>
            for {
              f <- s
            } yield {
              f match {
                case n if numericVariantFilters.map(e => e.id) contains n => ()
                case b if booleanVariantFilters.map(e => e.id) contains b => ()
                case c if categoricalVariantFilters.map(e => e.id) contains c => ()
                case d if compoundVariantFilters.map(e => e.id) contains d => ()
                case _ => throw new CfgException("cohorts.resultsVariantFilters: variant filter '" + f + "' not found")
              }
            }
            Some(s)
          case None => None
        }

        ConfigCohort(
          id = requiredStr(config = cohort, field = "id"),
          array = array,
          ancestry = requiredStrList(config = cohort, field = "ancestry", regex = "EUR|AFR|AMR|SAS|EAS"),
          minPartitions = optionalInt(config = cohort, field = "minPartitions"),
          stratCol = optionalStr(config = cohort, field = "stratCol"),
          stratCodes = optionalStrList(config = cohort, field = "stratCodes"),
          cohortSampleFilters = cohortSampleFilters,
          cohortVariantFilters = cohortVariantFilters,
          resultsVariantFilters = resultsVariantFilters
        )
    
      }
    
    }

    val Metas = {
    
      for {
        meta <- requiredObjList(config = config, field = "metas")
      } yield {

        val cohorts = for {
          c <- requiredStrList(config = meta, field = "cohorts")
        } yield {
          Cohorts.map(e => e.id) contains c match {
            case true => c
            case false => throw new CfgException("metas.cohorts: cohort '" + c + "' not found")
          }
        }

        ConfigMeta(
          id = requiredStr(config = meta, field = "id"),
          cohorts = cohorts,
          minPartitions = optionalInt(config = meta, field = "minPartitions")
        )
    
      }
    
    }

    val Merges = {
    
      for {
        merge <- requiredObjList(config = config, field = "merges")
      } yield {

        val cohorts_metas = for {
          c <- requiredStrList(config = merge, field = "cohorts_metas")
        } yield {
          Cohorts.map(e => e.id) contains c match {
            case true => c
            case false =>
              Metas.map(e => e.id) contains c match {
                case true => c
                case false => throw new CfgException("merges.cohorts_metas: cohorts_metas '" + c + "' not found")
              }
          }
        }
    
        ConfigMerge(
          id = requiredStr(config = merge, field = "id"),
          cohorts_metas = cohorts_metas,
          minPartitions = optionalInt(config = merge, field = "minPartitions")
        )
    
      }
    
    }

    val Phenos = {
    
      for {
        pheno <- requiredObjList(config = config, field = "phenos")
      } yield {
    
        ConfigPheno(
          id = requiredStr(config = pheno, field = "id"),
          name = requiredStr(config = pheno, field = "name")
        )
    
      }
    
    }

    val Models = {
    
      for {
        model <- requiredObjList(config = config, field = "models")
      } yield {

        val pheno = requiredStr(config = model, field = "pheno")
        Phenos.map(e => e.id) contains pheno match {
          case true => ()
          case false => throw new CfgException("models.pheno: pheno '" + pheno + "' not found")
        }
    
        ConfigModel(
          id = requiredStr(config = model, field = "id"),
          pheno = pheno,
          trans = requiredStr(config = model, field = "trans", regex = "log|invn|$^"),
          test = requiredStr(config = model, field = "test", regex = "lm|wald|firth|lrt|score|lmm"),
          covars = requiredStrList(config = model, field = "covars").mkString("+")
        )
      }
    
    }

    val Knowns = {
    
      for {
        known <- requiredObjList(config = config, field = "knowns")
      } yield {
    
        ConfigKnown(
          id = requiredStr(config = known, field = "id"),
          data = requiredStr(config = known, field = "data"),
          hiLd = requiredStr(config = known, field = "hiLd"),
          n = getStrOrBlank(config = known, field = "n"),
          nCase = getStrOrBlank(config = known, field = "nCase"),
          nCtrl = getStrOrBlank(config = known, field = "nCtrl"),
          desc = requiredStr(config = known, field = "desc"),
          citation = requiredStr(config = known, field = "citation")
        )
    
      }
    
    }

    val Reports = {
    
      for {
        report <- requiredObjList(config = config, field = "reports")
      } yield {
    
        ConfigReport(
          id = requiredStr(config = report, field = "id"),
          name = requiredStr(config = report, field = "name"),
          sections = for {
            section <- requiredObjList(config = report, field = "sections")
          } yield {

            val models = for {
              m <- requiredStrList(config = section, field = "models")
            } yield {
              Models.map(e => e.id) contains m match {
                case true => m
                case false => throw new CfgException("reports.sections.models: model '" + m + "' not found")
              }
            }

            val cohorts = optionalStrList(config = section, field = "cohorts") match {
              case Some(s) =>
                for {
                  f <- s
                } yield {
                  f match {
			        case n if Cohorts.map(e => e.id) contains n => ()
                    case _ => throw new CfgException("reports.sections.cohorts: cohort '" + f + "' not found")
                  }
                }
                Some(s)
              case None => None
            }

            val metas = optionalStrList(config = section, field = "metas") match {
              case Some(s) =>
                for {
                  f <- s
                } yield {
                  f match {
                    case n if Metas.map(e => e.id) contains n => ()
                    case _ => throw new CfgException("reports.sections.metas: meta '" + f + "' not found")
                  }
                }
                Some(s)
              case None => None
            }

            val merges = optionalStrList(config = section, field = "merges") match {
              case Some(s) =>
                for {
                  f <- s
                } yield {
                  f match {
                    case n if Merges.map(e => e.id) contains n => ()
                    case _ => throw new CfgException("reports.sections.merges: merge '" + f + "' not found")
                  }
                }
                Some(s)
              case None => None
            }

            val knowns = optionalStrList(config = section, field = "knowns") match {
              case Some(s) =>
                for {
                  f <- s
                } yield {
                  f match {
                    case n if Knowns.map(e => e.id) contains n => ()
                    case _ => throw new CfgException("reports.sections.knowns: known '" + f + "' not found")
                  }
                }
                Some(s)
              case None => None
            }
    
            ConfigSection(
              id = requiredStr(config = section, field = "id"),
              title = requiredStr(config = section, field = "title"),
              models = models,
              cohorts = cohorts,
              metas = metas,
              merges = merges,
              knowns = knowns
            )
          
          }

        )

      }
    
    }

    val nArrays = Arrays.size
    val nCohorts = Cohorts.size
    val nMetas = Metas.size

    new ProjectConfig(

      loamstreamVersion = loamstreamVersion,
      pipelineVersion = pipelineVersion,
      projectId = projectId,
      hailCloud = hailCloud,
      cloudHome = cloudHome,
      cloudShare = cloudShare,
      exportCleanData = exportCleanData,
      referenceGenome = referenceGenome,
      regionsExclude = regionsExclude,
      genePositions = genePositions,
      kgPurcellVcf = kgPurcellVcf,
      kgSample = kgSample,
      kgSampleId = kgSampleId,
      kgSamplePop = kgSamplePop,
      kgSampleGroup = kgSampleGroup,
      kgVcf = kgVcf,
      kgIds = kgIds,
      humanReferenceWild = humanReferenceWild,
      fasta = fasta,
      vepCacheDir = vepCacheDir,
      vepPluginsDir = vepPluginsDir,
      dbNSFP = dbNSFP,
      sampleFile = sampleFile,
      sampleFileId = sampleFileId,
      sampleFileSrSex = sampleFileSrSex,
      sampleFileMaleCode = sampleFileMaleCode,
      sampleFileFemaleCode = sampleFileFemaleCode,
      sampleFileSrRace = sampleFileSrRace,
      sampleFileAFRCodes = sampleFileAFRCodes,
      sampleFileAMRCodes = sampleFileAMRCodes,
      sampleFileEURCodes = sampleFileEURCodes,
      sampleFileEASCodes = sampleFileEASCodes,
      sampleFileSASCodes = sampleFileSASCodes,
      phenoFile = phenoFile,
      phenoFileId = phenoFileId,
      authors = authors,
      email = email,
      organization = organization,
      acknowledgementsAnalysisReport = acknowledgementsAnalysisReport,
      acknowledgementsQcReport = acknowledgementsQcReport,
      nAncestryInferenceFeatures = nAncestryInferenceFeatures,
      ancestryInferenceFeatures = ancestryInferenceFeatures,
      minPCs = minPCs,
      maxPCs = maxPCs,
      nStddevs = nStddevs,
      cloudResources = cloudResources,
      resources = resources,
      nArrays = nArrays,
      nCohorts = nCohorts,
      nMetas = nMetas,
      maxSigRegions = maxSigRegions,
      numericVariantFilters =  numericVariantFilters,
      booleanVariantFilters = booleanVariantFilters,
      categoricalVariantFilters = categoricalVariantFilters,
      compoundVariantFilters = compoundVariantFilters,
      numericSampleFilters =  numericSampleFilters,
      booleanSampleFilters = booleanSampleFilters,
      categoricalSampleFilters = categoricalSampleFilters,
      compoundSampleFilters = compoundSampleFilters,
      Arrays = Arrays,
      Cohorts = Cohorts,
      Metas = Metas,
      Merges = Merges,
      Phenos = Phenos,
      Models = Models,
      Knowns = Knowns,
      Reports = Reports

    )

  }

  def parseUtils(config: loamstream.conf.DataConfig): Utils = {

    val imagesDir = path(checkPath(requiredStr(config = config, field = "imagesDir")))
    val scriptsDir = path(checkPath(requiredStr(config = config, field = "scriptsDir")))

    val image = Image(
      imgHail = path(s"${imagesDir}/hail.simg"),
      imgLocuszoom = path(s"${imagesDir}/locuszoom.simg"),
      imgPython2 = path(s"${imagesDir}/python2.simg"),
      imgR = path(s"${imagesDir}/r.simg"),
      imgTools = path(s"${imagesDir}/tools.simg"),
      imgTexLive = path(s"${imagesDir}/texlive.simg"),
      imgEnsemblVep = path(s"${imagesDir}/ensemblvep.simg"),
      imgFlashPca = path(s"${imagesDir}/flashpca.simg")
    )

    val binary = Binary(
      binLiftOver = path("/usr/local/bin/liftOver"),
      binGenotypeHarmonizer = path("/usr/local/bin/GenotypeHarmonizer.jar"),
      binKing = path("/usr/local/bin/king"),
      binPlink = path("/usr/local/bin/plink"),
      binTabix = path("/usr/local/bin/tabix"),
      binGhostscript = path("/usr/local/bin/gs"),
      binKlustakwik = path("/usr/local/bin/KlustaKwik"),
      binPython = path("/usr/local/bin/python"),
      binLocuszoom = path("/usr/local/bin/locuszoom"),
      binPdflatex = path("/usr/local/bin/pdflatex"),
      binRscript = path("/usr/local/bin/Rscript"),
      binFlashPca = path("/usr/local/bin/flashpca")
    )

    val python = Python(
      pyBimToUid = path(s"${scriptsDir}/bim_to_uid.py"),
      pyHailUtils = path(s"${scriptsDir}/hail_utils.py"),
      pyAlignNon1kgVariants = path(s"${scriptsDir}/align_non1kg_variants.py"),
      pyHailLoad = path(s"${scriptsDir}/hail_load.py"),
      pyHailExportQcData = path(s"${scriptsDir}/hail_export_qc_data.py"),
      pyHailAncestryPcaMerge1kg = path(s"${scriptsDir}/hail_ancestry_pca_merge_1kg.py"),
      pyHailPcaMerge1kg = path(s"${scriptsDir}/hail_pca_merge_1kg.py"),
      pyHailSampleqc = path(s"${scriptsDir}/hail_sampleqc.py"),
      pyHailExportCleanData = path(s"${scriptsDir}/hail_export_clean_data.py"),
      pyHailFilter = path(s"${scriptsDir}/hail_filter.py"),
      pyHailFilterResults = path(s"${scriptsDir}/hail_filter_results.py"),
      pyHailAssoc = path(s"${scriptsDir}/hail_assoc.py"),
      pyHailMerge = path(s"${scriptsDir}/hail_merge.py"),
      pyHailMetaAnalysis = path(s"${scriptsDir}/hail_meta_analysis.py"),
      pyQqPlot = path(s"${scriptsDir}/qqplot.py"),
      pyMhtPlot = path(s"${scriptsDir}/mhtplot.py"),
      pyExtractTopRegions = path(s"${scriptsDir}/extract_top_regions.py"),
      pyMakeSamplesRestoreTable = path(s"${scriptsDir}/make_samples_restore_table.py"),
      pyCompileExclusions = path(s"${scriptsDir}/compile_exclusions.py"),
      pyGenerateReportHeader = path(s"${scriptsDir}/generate_report_header.py"),
      pyGenerateQcReportIntro = path(s"${scriptsDir}/generate_qc_report_intro.py"),
      pyGenerateQcReportData = path(s"${scriptsDir}/generate_qc_report_data.py"),
      pyGenerateQcReportAncestry = path(s"${scriptsDir}/generate_qc_report_ancestry.py"),
      pyGenerateQcReportIbdSexcheck = path(s"${scriptsDir}/generate_qc_report_ibd_sexcheck.py"),
      pyGenerateQcReportSampleqc = path(s"${scriptsDir}/generate_qc_report_sampleqc.py"),
      pyGenerateQcReportVariantqc = path(s"${scriptsDir}/generate_qc_report_variantqc.py"),
      pyGenerateQcReportBibliography = path(s"${scriptsDir}/generate_qc_report_bibliography.py"),
      pyGenerateAnalysisReportIntro = path(s"${scriptsDir}/generate_analysis_report_intro.py"),
      pyGenerateAnalysisReportData = path(s"${scriptsDir}/generate_analysis_report_data.py"),
      pyGenerateAnalysisReportStrategy = path(s"${scriptsDir}/generate_analysis_report_strategy.py"),
      pyGenerateAnalysisReportPhenoSummary = path(s"${scriptsDir}/generate_analysis_report_pheno_summary.py"),
      pyGenerateAnalysisReportPhenoCalibration = path(s"${scriptsDir}/generate_analysis_report_pheno_calibration.py"),
      pyGenerateAnalysisReportPhenoTopLoci = path(s"${scriptsDir}/generate_analysis_report_pheno_top_loci.py"),
      pyGenerateAnalysisReportPhenoKnownLoci = path(s"${scriptsDir}/generate_analysis_report_pheno_known_loci.py"),
      pyGenerateAnalysisReportBibliography = path(s"${scriptsDir}/generate_analysis_report_bibliography.py"),
      pyMergeVariantLists = path(s"${scriptsDir}/merge_variant_lists.py"),
      pyTop1000 = path(s"${scriptsDir}/top1000.py"),
      pyAddGeneAnnot = path(s"${scriptsDir}/add_gene_annot.py"),
      pyPhenoDistPlot = path(s"${scriptsDir}/pheno_dist_plot.py")
    )

    val bash = Bash(
      shRegPlot = path(s"${scriptsDir}/regplot.sh"),
      shAnnotate = path(s"${scriptsDir}/annotate.sh"),
      shKing = path(s"${scriptsDir}/king.sh"),
      shPlinkPrepare = path(s"${scriptsDir}/plink_prepare.sh"),
      shPlinkToVcfNoHalfCalls = path(s"${scriptsDir}/plink_to_vcf_no_half_calls.sh"),
      shCrossCohortCommonVariants = path(s"${scriptsDir}/cross_cohort_common_variants.sh"),
      shMetaCohortSamples = path(s"${scriptsDir}/meta_cohort_samples.sh"),
      shKlustakwikPca = path(s"${scriptsDir}/klustakwik.pca.sh"),
      shKlustakwikMetric = path(s"${scriptsDir}/klustakwik.metric.sh"),
      shTop1000Genes = path(s"${scriptsDir}/top1000_genes.sh")
    )

    val r = R(
      rFindBestDuplicateVariants = path(s"${scriptsDir}/find_best_duplicate_variants.r"),
      rAncestryClusterMerge = path(s"${scriptsDir}/ancestry_cluster_merge.r"),
      rAncestryClusterTable = path(s"${scriptsDir}/ancestry_cluster_table.r"),
      rCalcKinshipFamSizes = path(s"${scriptsDir}/calc_kinship_fam_sizes.r"),
      rPcair = path(s"${scriptsDir}/pcair.r"),
      rPlotAncestryPca = path(s"${scriptsDir}/plot_ancestry_pca.r"),
      rPlotAncestryCluster = path(s"${scriptsDir}/plot_ancestry_cluster.r"),
      rIstatsPcsGmmClusterPlot = path(s"${scriptsDir}/istats_pcs_gmm_cluster_plot.r"),
      rIstatsAdjGmmPlotMetrics = path(s"${scriptsDir}/istats_adj_gmm_plot_metrics.r"),
      rCalcIstatsAdj = path(s"${scriptsDir}/calc_istats_adj.r"),
      rIstatsAdjPca = path(s"${scriptsDir}/istats_adj_pca.r"),
      rExcludeCrossArray = path(s"${scriptsDir}/exclude_cross_array.r"),
      rGeneratePheno = path(s"${scriptsDir}/generate_pheno.r"),
      rVariantsSummaryTable = path(s"${scriptsDir}/variants_summary_table.r"),
      rUpsetplotBimFam = path(s"${scriptsDir}/upsetplot.bimfam.r"),
      rMakeOutlierTable = path(s"${scriptsDir}/make_outlier_table.r"),
      rMakeMetricDistPlot = path(s"${scriptsDir}/make_metric_dist_plot.r"),
      rTop20 = path(s"${scriptsDir}/top20.r"),
      rTop50Known = path(s"${scriptsDir}/top50_known.r"),
      rMetaExclusionsTable = path(s"${scriptsDir}/meta_exclusions_table.r")
    )

    new Utils(
      imagesDir = imagesDir,
      scriptsDir = scriptsDir,
      image = image,
      binary = binary,
      python = python,
      bash = bash,
      r = r)

  }

}

// Initialize configuration and utilities, verify them, and write all objects to file
println("Loading Project Configuration File ...")
val dataConfig = loadConfig("dataConfig", "")

val projectConfig = ProjectConfig.parseConfig(dataConfig)
projectConfig.debugVars()
for ( d <- projectConfig.Arrays ) { d.debugVars() }
for ( d <- projectConfig.Cohorts ) { d.debugVars() }
for ( d <- projectConfig.Metas ) { d.debugVars() }
for ( d <- projectConfig.Merges ) { d.debugVars() }
for ( d <- projectConfig.Phenos ) { d.debugVars() }
for ( d <- projectConfig.Models ) { d.debugVars() }
for ( d <- projectConfig.Knowns ) { d.debugVars() }
for ( d <- projectConfig.Reports ) { d.debugVars() }
println("... Project Configuration Loaded Successfully!")

println("Loading Pipeline Utilities Configuration ...")
val utils = ProjectConfig.parseUtils(dataConfig)
utils.debugVars()
utils.image.debugVars()
utils.binary.debugVars()
utils.python.debugVars()
utils.bash.debugVars()
utils.r.debugVars()
println("... Pipeline Utilities Configuration Loaded Successfully!")