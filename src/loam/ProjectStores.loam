import ProjectConfig._
import PipelineConfig._
import Fxns._

final case class Known(
  data: Store,
  hiLd: Store,
  hiLdGoogle: Option[Store]
)

object ProjectStores {

  val autosomalChrs = (1 to 22).map(e => e.toString).toSeq

  val nonAutosomalChrs = {

    ( if ( projectConfig.Arrays.map(e => e.xChr).contains(true) ) Seq("X") else Seq.empty ) ++
    ( if ( projectConfig.Arrays.map(e => e.yChr).contains(true) ) Seq("Y") else Seq.empty ) ++
    ( if ( projectConfig.Arrays.map(e => e.mtChr).contains(true) ) Seq("MT") else Seq.empty )

  }

  val kgVcf = ( autosomalChrs ++ nonAutosomalChrs ).map { chr =>
  
    val vcf = store(checkPath(projectConfig.kgVcf.replace("[CHROMOSOME]", s"$chr"))).asInput
  
    chr -> vcf
  
  }.toMap
  
  val kgIds = ( autosomalChrs ++ nonAutosomalChrs ).map { chr =>
  
    val ids = store(checkPath(projectConfig.kgIds.replace("[CHROMOSOME]", s"$chr"))).asInput
  
    chr -> ids
  
  }.toMap
  
  val humanReference = ( autosomalChrs ++ nonAutosomalChrs ).map { chr =>
  
    val ref = store(checkPath(projectConfig.humanReferenceWild.replace("[CHROMOSOME]", s"$chr"))).asInput
  
    chr -> ref
  
  }.toMap

  val knownStores = projectConfig.Knowns.filter(e => projectConfig.Reports.flatMap(e => e.sections).flatMap(e => e.knowns).flatten.toSeq.distinct.contains(e.id)).map { known =>

    known -> Known(
      data = store(path(checkPath(known.data))).asInput,
      hiLd = store(path(checkPath(known.hiLd))).asInput,
      hiLdGoogle = projectConfig.hailCloud match { case true => Some(store(projectConfig.cloudHome.get / s"${known.id}." + s"${known.hiLd}".split("/").last)); case false => None }
    )

  }.toMap

  val regionsExclude = store(path(checkPath(projectConfig.regionsExclude))).asInput
  val regionsExcludeGoogle = projectConfig.hailCloud match { case true => Some(store(projectConfig.cloudShare.get / s"${projectConfig.regionsExclude}".split("/").last)); case false => None }
  val genePositions = store(path(checkPath(projectConfig.genePositions))).asInput
  val kgPurcellVcf = store(path(checkPath(projectConfig.kgPurcellVcf))).asInput
  val kgPurcellVcfGoogle = projectConfig.hailCloud match { case true => Some(store(projectConfig.cloudShare.get / s"${projectConfig.kgPurcellVcf}".split("/").last)); case false => None }
  val kgSample = store(path(checkPath(projectConfig.kgSample))).asInput
  val kgSampleGoogle = projectConfig.hailCloud match { case true => Some(store(projectConfig.cloudShare.get / s"${projectConfig.kgSample}".split("/").last)); case false => None }
  val fasta = store(path(checkPath(projectConfig.fasta))).asInput
  val vepCacheDir = store(path(checkPath(projectConfig.vepCacheDir))).asInput
  val vepPluginsDir = store(path(checkPath(projectConfig.vepPluginsDir))).asInput
  val dbNSFP = store(path(checkPath(projectConfig.dbNSFP))).asInput
  val sampleFile = store(path(projectConfig.sampleFile)).asInput
  val sampleFileGoogle = projectConfig.hailCloud match { case true => Some(store(projectConfig.cloudHome.get / s"${projectConfig.sampleFile}".split("/").last)); case false => None }
  val phenoFile = projectConfig.phenoFile match { case "" => None; case _ => Some(store(path(checkPath(projectConfig.phenoFile))).asInput) }
  val ancestryInferred = store(projectConfig.home / s"${projectConfig.projectId}.ancestry.inferred.tsv")
  val ancestryInferredGoogle = projectConfig.hailCloud match { case true => Some(store(projectConfig.cloudHome.get / s"${ancestryInferred}".split("/").last)); case false => None }
  val ancestryOutliers = store(projectConfig.home / s"${projectConfig.projectId}.ancestry.inferred.outliers.tsv")

}
