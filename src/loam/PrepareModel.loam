/**
 * Prepare Model Cohorts
 * 
 */
import ProjectConfig._
import ArrayStores._
import ProjectStores._
import ModelStores._
import AssocStores._

final case class CfgException(s: String) extends Exception(s)

def PrepareModel(configModel: ConfigModel, configCohorts: Seq[ConfigCohort], configMeta: Option[ConfigMeta] = None): Unit = {

  val array = projectConfig.Arrays.filter(e => e.id == configCohorts.head.array).head

  val stratStrings = {
    for {
      cohort <- configCohorts
    } yield {
      var s = "--strat " + cohort.id + " " + cohort.ancestry.mkString(",")
      cohort.stratCol match {
        case Some(a) => s = s + " " + a
        case None => s = s + " " + """"N/A""""
      }
      cohort.stratCodes match {
        case Some(a) => s = s + " " + a.mkString(",")
        case None => s = s + " " + """"N/A""""
      }
      s
    }
  }

  val metaPriorSamplesString = configMeta match {
    case Some(s) =>
      var mpss = s"--cohorts ${configCohorts.map(e => e.id).mkString(",")}"
      val x = for {
        c <- configMeta.get.cohorts.takeWhile(_ != configCohorts.head.id)
      } yield {
        s"${modelStores((configModel, Seq(projectConfig.Cohorts.filter(e => e.id == c).head), configMeta)).samplesAvailable.toString.split("@")(1)}"
      }
      x.size match {
        case n if n > 0 => mpss = mpss + " --meta-prior-samples " + x.mkString(",") + " --meta-cohorts " + configMeta.get.cohorts.mkString(",") + " --cckinship " + s"${metaKinshipStores(configMeta.get).kin0.toString.split("@")(1)}"
        case _ => ""
      }
      mpss
    case None => ""
  }

  val modelCohortSamplesAvailableIn = configMeta match {
    case Some(s) => 
      val x = for {
        c <- configMeta.get.cohorts.takeWhile(_ != configCohorts.head.id)
      } yield {
        modelStores((configModel, Seq(projectConfig.Cohorts.filter(e => e.id == c).head), configMeta)).samplesAvailable
      }
      (x.toSeq ++ arrayStores(array).filteredData.plink.data.local.get) :+ metaKinshipStores(configMeta.get).kin0 :+ ProjectStores.phenoFile.get :+ ProjectStores.ancestryInferred :+ arrayStores(array).sampleQcData.stats :+ arrayStores(array).kinshipData.kin0 :+ arrayStores(array).filterQc.samplesExclude :+ arrayStores(array).filterPostQc.samplesExclude
    case None =>
      arrayStores(array).filteredData.plink.data.local.get :+ ProjectStores.phenoFile.get :+ ProjectStores.ancestryInferred :+ arrayStores(array).sampleQcData.stats :+ arrayStores(array).kinshipData.kin0 :+ arrayStores(array).filterQc.samplesExclude :+ arrayStores(array).filterPostQc.samplesExclude
  }
  
  drmWith(imageName = s"${utils.image.imgR}") {

    cmd"""${utils.binary.binRscript} --vanilla --verbose
      ${utils.r.rModelCohortSamplesAvailable}
      --pheno-in ${ProjectStores.phenoFile.get}
      --fam-in ${arrayStores(array).filteredData.plink.base.local.get}.fam
      --ancestry-in ${ProjectStores.ancestryInferred}
      ${stratStrings.mkString(" ")}
      ${metaPriorSamplesString}
      --pheno-col ${configModel.pheno}
      --iid-col ${projectConfig.phenoFileId}
      --sampleqc-in ${arrayStores(array).sampleQcData.stats}
      --kinship-in ${arrayStores(array).kinshipData.kin0}
      --samples-exclude-qc ${arrayStores(array).filterQc.samplesExclude}
      --samples-exclude-postqc ${arrayStores(array).filterPostQc.samplesExclude}
      --test ${configModel.test}
      --covars "${configModel.covars}"
      --out-pheno-prelim ${modelStores((configModel, configCohorts, configMeta)).phenoPrelim}
      --out-id-map ${modelStores((configModel, configCohorts, configMeta)).samplesMap}
      --out-cohorts-map ${modelStores((configModel, configCohorts, configMeta)).cohortsMap}
      --out ${modelStores((configModel, configCohorts, configMeta)).samplesAvailable}
      > ${modelStores((configModel, configCohorts, configMeta)).samplesAvailableLog}"""
      .in(modelCohortSamplesAvailableIn)
      .out(modelStores((configModel, configCohorts, configMeta)).samplesMap, modelStores((configModel, configCohorts, configMeta)).phenoPrelim, modelStores((configModel, configCohorts, configMeta)).samplesAvailable, modelStores((configModel, configCohorts, configMeta)).samplesAvailableLog)
      .tag(s"${modelStores((configModel, configCohorts, configMeta)).samplesAvailable}".split("/").last)
  
  }

  val trans = configModel.trans match {
    case Some(s) => configModel.trans.get
    case None => "N/A"
  }

  drmWith(imageName = s"${utils.image.imgFlashPca}", cores = projectConfig.resources.generatePheno.cpus, mem = projectConfig.resources.generatePheno.mem, maxRunTime = projectConfig.resources.generatePheno.maxRunTime) {
  
    cmd"""${utils.bash.shFlashPca}
      ${utils.binary.binFlashPca}
      ${utils.binary.binRscript}
      ${utils.binary.binPlink}
      ${utils.r.rGeneratePheno}
      ${projectConfig.resources.generatePheno.cpus}
      ${arrayStores(array).prunedData.plink.base}
      ${modelStores((configModel, configCohorts, configMeta)).samplesAvailable}
      ${modelStores((configModel, configCohorts, configMeta)).pcaBase}
      ${modelStores((configModel, configCohorts, configMeta)).pcaScores}
      ${modelStores((configModel, configCohorts, configMeta)).pcaEigenVecs}
      ${modelStores((configModel, configCohorts, configMeta)).pcaLoadings}
      ${modelStores((configModel, configCohorts, configMeta)).pcaEigenVals}
      ${modelStores((configModel, configCohorts, configMeta)).pcaPve}
      ${modelStores((configModel, configCohorts, configMeta)).pcaMeansd}
      ${configModel.maxPcaOutlierIterations}
      ${modelStores((configModel, configCohorts, configMeta)).phenoPrelim}
      ${configModel.pheno}
      ${projectConfig.phenoFileId}
      ${configModel.test}
      "${trans}"
      "${configModel.covars}"
      ${projectConfig.minPCs}
      ${projectConfig.maxPCs}
      ${projectConfig.nStddevs}
      ${modelStores((configModel, configCohorts, configMeta)).pheno}
      ${modelStores((configModel, configCohorts, configMeta)).pcsInclude}
      ${modelStores((configModel, configCohorts, configMeta)).outliers}
      > ${modelStores((configModel, configCohorts, configMeta)).pcaLog}"""
      .in(arrayStores(array).prunedData.plink.data :+ modelStores((configModel, configCohorts, configMeta)).samplesAvailable :+ modelStores((configModel, configCohorts, configMeta)).phenoPrelim :+ ProjectStores.phenoFile.get)
      .out(modelStores((configModel, configCohorts, configMeta)).pcaScores, modelStores((configModel, configCohorts, configMeta)).pcaEigenVecs, modelStores((configModel, configCohorts, configMeta)).pcaLoadings, modelStores((configModel, configCohorts, configMeta)).pcaEigenVals, modelStores((configModel, configCohorts, configMeta)).pcaPve, modelStores((configModel, configCohorts, configMeta)).pcaMeansd, modelStores((configModel, configCohorts, configMeta)).pheno, modelStores((configModel, configCohorts, configMeta)).pcsInclude, modelStores((configModel, configCohorts, configMeta)).outliers, modelStores((configModel, configCohorts, configMeta)).pcaLog)
      .tag(s"${modelStores((configModel, configCohorts, configMeta)).pheno}".split("/").last)
  
  }

}
