/**
 * Prepare Model Cohorts
 * 
 */
import ProjectConfig._
import ArrayStores._
import ProjectStores._
import ModelStores._
import AssocStores._
import Fxns._

final case class CfgException(s: String) extends Exception(s)

def PrepareModel(configModel: ConfigModel, configCohorts: Seq[ConfigCohort], configMeta: Option[ConfigMeta] = None): Unit = {

  val array = projectConfig.Arrays.filter(e => e.id == configCohorts.head.array).head

  val stratStrings = {
    for {
      cohort <- configCohorts
    } yield {
      var s = "--strat " + cohort.id + " " + cohort.ancestry.mkString(",")
      cohort.stratCol match {
        case Some(a) => s = s + " " + a
        case None => s = s + " " + """"N/A""""
      }
      cohort.stratCodes match {
        case Some(a) => s = s + " " + a.mkString(",")
        case None => s = s + " " + """"N/A""""
      }
      s
    }
  }

  val metaPriorSamplesString = configMeta match {
    case Some(s) =>
      var mpss = s"--cohorts ${configCohorts.map(e => e.id).mkString(",")}"
      val x = for {
        c <- configMeta.get.cohorts.takeWhile(_ != configCohorts.head.id)
      } yield {
        s"${modelStores((configModel, Seq(projectConfig.Cohorts.filter(e => e.id == c).head), configMeta)).samplesAvailable.toString.split("@")(1)}"
      }
      x.size match {
        case n if n > 0 => mpss = mpss + " --meta-prior-samples " + x.mkString(",") + " --meta-cohorts " + configMeta.get.cohorts.mkString(",") + " --cckinship " + s"${metaKinshipStores(configMeta.get).kin0.toString.split("@")(1)}"
        case _ => ""
      }
      mpss
    case None => ""
  }

  val modelCohortSamplesAvailableIn = configMeta match {
    case Some(s) => 
      val x = for {
        c <- configMeta.get.cohorts.takeWhile(_ != configCohorts.head.id)
      } yield {
        modelStores((configModel, Seq(projectConfig.Cohorts.filter(e => e.id == c).head), configMeta)).samplesAvailable
      }
      (x.toSeq ++ arrayStores(array).filteredData.plink.data.local.get) :+ metaKinshipStores(configMeta.get).kin0 :+ ProjectStores.phenoFile.get :+ ProjectStores.ancestryInferred :+ arrayStores(array).sampleQcData.stats :+ arrayStores(array).kinshipData.kin0 :+ arrayStores(array).filterQc.samplesExclude :+ arrayStores(array).filterPostQc.samplesExclude
    case None =>
      arrayStores(array).filteredData.plink.data.local.get :+ ProjectStores.phenoFile.get :+ ProjectStores.ancestryInferred :+ arrayStores(array).sampleQcData.stats :+ arrayStores(array).kinshipData.kin0 :+ arrayStores(array).filterQc.samplesExclude :+ arrayStores(array).filterPostQc.samplesExclude
  }

  val keepRelated = famTests.contains(configModel.test) match {
    case true => "--keep-related"
    case false => ""
  }
  
  drmWith(imageName = s"${utils.image.imgR}") {

    cmd"""${utils.binary.binRscript} --vanilla --verbose
      ${utils.r.rModelCohortSamplesAvailable}
      --pheno-in ${ProjectStores.phenoFile.get}
      --fam-in ${arrayStores(array).filteredData.plink.base.local.get}.fam
      --ancestry-in ${ProjectStores.ancestryInferred}
      ${stratStrings.mkString(" ")}
      ${metaPriorSamplesString}
      --pheno-col ${configModel.pheno}
      --iid-col ${projectConfig.phenoFileId}
      --sampleqc-in ${arrayStores(array).sampleQcData.stats}
      --kinship-in ${arrayStores(array).kinshipData.kin0}
      --samples-exclude-qc ${arrayStores(array).filterQc.samplesExclude}
      --samples-exclude-postqc ${arrayStores(array).filterPostQc.samplesExclude}
      ${keepRelated}
      --covars "${configModel.covars}"
      --out-pheno-prelim ${modelStores((configModel, configCohorts, configMeta)).phenoPrelim}
      --out-id-map ${modelStores((configModel, configCohorts, configMeta)).sampleMap}
      --out-cohorts-map ${modelStores((configModel, configCohorts, configMeta)).cohortMap}
      --out ${modelStores((configModel, configCohorts, configMeta)).samplesAvailable}
      > ${modelStores((configModel, configCohorts, configMeta)).samplesAvailableLog}"""
      .in(modelCohortSamplesAvailableIn)
      .out(modelStores((configModel, configCohorts, configMeta)).sampleMap, modelStores((configModel, configCohorts, configMeta)).phenoPrelim, modelStores((configModel, configCohorts, configMeta)).samplesAvailable, modelStores((configModel, configCohorts, configMeta)).samplesAvailableLog)
      .tag(s"${modelStores((configModel, configCohorts, configMeta)).samplesAvailable}".split("/").last)
  
  }

  val trans = configModel.trans match {
    case Some(s) => configModel.trans.get
    case None => "N/A"
  }

  drmWith(imageName = s"${utils.image.imgFlashPca}", cores = projectConfig.resources.generatePheno.cpus, mem = projectConfig.resources.generatePheno.mem, maxRunTime = projectConfig.resources.generatePheno.maxRunTime) {
  
    cmd"""${utils.bash.shFlashPca}
      ${utils.binary.binFlashPca}
      ${utils.binary.binRscript}
      ${utils.binary.binPlink}
      ${utils.r.rGeneratePheno}
      ${projectConfig.resources.generatePheno.cpus}
      ${arrayStores(array).prunedData.plink.base}
      ${modelStores((configModel, configCohorts, configMeta)).samplesAvailable}
      ${modelStores((configModel, configCohorts, configMeta)).pcaBase}
      ${modelStores((configModel, configCohorts, configMeta)).pcaScores}
      ${modelStores((configModel, configCohorts, configMeta)).pcaEigenVecs}
      ${modelStores((configModel, configCohorts, configMeta)).pcaLoadings}
      ${modelStores((configModel, configCohorts, configMeta)).pcaEigenVals}
      ${modelStores((configModel, configCohorts, configMeta)).pcaPve}
      ${modelStores((configModel, configCohorts, configMeta)).pcaMeansd}
      ${configModel.maxPcaOutlierIterations}
      ${modelStores((configModel, configCohorts, configMeta)).phenoPrelim}
      ${configModel.pheno}
      ${projectConfig.phenoFileId}
      "${trans}"
      "${configModel.covars}"
      ${projectConfig.minPCs}
      ${projectConfig.maxPCs}
      ${projectConfig.nStddevs}
      ${modelStores((configModel, configCohorts, configMeta)).pheno}
      ${modelStores((configModel, configCohorts, configMeta)).pcsInclude}
      ${modelStores((configModel, configCohorts, configMeta)).outliers}
      > ${modelStores((configModel, configCohorts, configMeta)).pcaLog}"""
      .in(arrayStores(array).prunedData.plink.data :+ modelStores((configModel, configCohorts, configMeta)).samplesAvailable :+ modelStores((configModel, configCohorts, configMeta)).phenoPrelim :+ ProjectStores.phenoFile.get)
      .out(modelStores((configModel, configCohorts, configMeta)).pcaScores, modelStores((configModel, configCohorts, configMeta)).pcaEigenVecs, modelStores((configModel, configCohorts, configMeta)).pcaLoadings, modelStores((configModel, configCohorts, configMeta)).pcaEigenVals, modelStores((configModel, configCohorts, configMeta)).pcaPve, modelStores((configModel, configCohorts, configMeta)).pcaMeansd, modelStores((configModel, configCohorts, configMeta)).pheno, modelStores((configModel, configCohorts, configMeta)).pcsInclude, modelStores((configModel, configCohorts, configMeta)).outliers, modelStores((configModel, configCohorts, configMeta)).pcaLog)
      .tag(s"${modelStores((configModel, configCohorts, configMeta)).pheno}".split("/").last)
  
  }

  var filters = Seq[String]()
  var cohortFilters = Seq[String]()
  var knockoutFilters = Seq[String]()
  var masks = Seq[String]()
  var filterFields = Seq[String]()
  configModel.filters match {
    case Some(l) =>
      filters = filters ++ variantFiltersToPrintableList(cfg = projectConfig, filters = l)
      filterFields = filterFields ++ getFilterFields(cfg = projectConfig, filters = l)
    case None => ()
  }
  configModel.cohortFilters match {
    case Some(l) =>
      for {
        cf <- l if configCohorts.map(e => e.id).contains(cf.cohort)
      } yield {
        cohortFilters = cohortFilters ++ variantFiltersToPrintableList(cfg = projectConfig, filters = cf.filters, id = Some(cf.cohort))
        filterFields = filterFields ++ getFilterFields(cfg = projectConfig, filters = cf.filters)
      }
    case None => ()
  }
  configModel.knockoutFilters match {
    case Some(l) =>
      for {
        cf <- l if configCohorts.map(e => e.id).contains(cf.cohort)
      } yield {
        knockoutFilters = knockoutFilters ++ variantFiltersToPrintableList(cfg = projectConfig, filters = cf.filters, id = Some(cf.cohort))
        filterFields = filterFields ++ getFilterFields(cfg = projectConfig, filters = cf.filters)
      }
    case None => ()
  }
  configModel.masks match {
    case Some(l) =>
      for {
        mf <- l
      } yield {
        masks = masks ++ variantFiltersToPrintableList(cfg = projectConfig, filters = mf.filters, id = Some(mf.id))
        filterFields = filterFields ++ getFilterFields(cfg = projectConfig, filters = mf.filters)
      }
    case None => ()
  }

  filters.size match {

    case n if n > 0 =>

      drmWith(imageName = s"${utils.image.imgTools}") {
      
        cmd"""echo "${filters.mkString("\n")}" > ${modelStores((configModel, configCohorts, configMeta)).filters}"""
          .out(modelStores((configModel, configCohorts, configMeta)).filters)
          .tag(s"${modelStores((configModel, configCohorts, configMeta)).filters}".split("/").last)
      
      }

    case _ => 

      drmWith(imageName = s"${utils.image.imgTools}") {
      
        cmd"""touch ${modelStores((configModel, configCohorts, configMeta)).filters}"""
          .out(modelStores((configModel, configCohorts, configMeta)).filters)
          .tag(s"${modelStores((configModel, configCohorts, configMeta)).filters}".split("/").last)
      
      }

  }

  cohortFilters.size match {

    case n if n > 0 =>

      drmWith(imageName = s"${utils.image.imgTools}") {

        cmd"""echo "${cohortFilters.mkString("\n")}" > ${modelStores((configModel, configCohorts, configMeta)).cohortFilters}"""
          .out(modelStores((configModel, configCohorts, configMeta)).cohortFilters)
          .tag(s"${modelStores((configModel, configCohorts, configMeta)).cohortFilters}".split("/").last)
      
      }

    case _ => 

      drmWith(imageName = s"${utils.image.imgTools}") {
      
        cmd"""touch ${modelStores((configModel, configCohorts, configMeta)).cohortFilters}"""
          .out(modelStores((configModel, configCohorts, configMeta)).cohortFilters)
          .tag(s"${modelStores((configModel, configCohorts, configMeta)).cohortFilters}".split("/").last)
      
      }

  }

  knockoutFilters.size match {

    case n if n > 0 =>

      drmWith(imageName = s"${utils.image.imgTools}") {
      
        cmd"""echo "${knockoutFilters.mkString("\n")}" > ${modelStores((configModel, configCohorts, configMeta)).knockoutFilters}"""
          .out(modelStores((configModel, configCohorts, configMeta)).knockoutFilters)
          .tag(s"${modelStores((configModel, configCohorts, configMeta)).knockoutFilters}".split("/").last)
      
      }

    case _ => 

      drmWith(imageName = s"${utils.image.imgTools}") {
      
        cmd"""touch ${modelStores((configModel, configCohorts, configMeta)).knockoutFilters}"""
          .out(modelStores((configModel, configCohorts, configMeta)).knockoutFilters)
          .tag(s"${modelStores((configModel, configCohorts, configMeta)).knockoutFilters}".split("/").last)
      
      }

  }

  masks.size match {

    case n if n > 0 =>

      drmWith(imageName = s"${utils.image.imgTools}") {
      
        cmd"""echo "${masks.mkString("\n")}" > ${modelStores((configModel, configCohorts, configMeta)).masks}"""
          .out(modelStores((configModel, configCohorts, configMeta)).masks)
          .tag(s"${modelStores((configModel, configCohorts, configMeta)).masks}".split("/").last)
      
      }

    case _ => 

      drmWith(imageName = s"${utils.image.imgTools}") {
      
        cmd"""touch ${modelStores((configModel, configCohorts, configMeta)).masks}"""
          .out(modelStores((configModel, configCohorts, configMeta)).masks)
          .tag(s"${modelStores((configModel, configCohorts, configMeta)).masks}".split("/").last)
      
      }

  }

  val binary = binaryAssocTests.contains(configModel.test) match {
    case true => "--binary"
    case false => ""
  }

  projectConfig.hailCloud match {

    case true =>

      local {
      
        googleCopy(modelStores((configModel, configCohorts, configMeta)).pheno, modelStores((configModel, configCohorts, configMeta)).phenoGoogle.get)
        googleCopy(modelStores((configModel, configCohorts, configMeta)).cohortMap, modelStores((configModel, configCohorts, configMeta)).cohortMapGoogle.get)
        googleCopy(modelStores((configModel, configCohorts, configMeta)).filters, modelStores((configModel, configCohorts, configMeta)).filtersGoogle.get)
        googleCopy(modelStores((configModel, configCohorts, configMeta)).cohortFilters, modelStores((configModel, configCohorts, configMeta)).cohortFiltersGoogle.get)
        googleCopy(modelStores((configModel, configCohorts, configMeta)).knockoutFilters, modelStores((configModel, configCohorts, configMeta)).knockoutFiltersGoogle.get)
        googleCopy(modelStores((configModel, configCohorts, configMeta)).masks, modelStores((configModel, configCohorts, configMeta)).masksGoogle.get)
      
      }
      
      googleWith(projectConfig.cloudResources.mtCluster) {
      
        hail"""${utils.python.pyHailModelVariantStats} --
          --hail-utils ${ProjectStores.hailUtilsGoogle.get}
          --reference-genome ${projectConfig.referenceGenome}
          --mt-in ${arrayStores(array).refData.mtGoogle.get}
          --pheno-in ${modelStores((configModel, configCohorts, configMeta)).phenoGoogle.get}
          --iid-col ${projectConfig.phenoFileId}
          --pheno-col ${configModel.pheno}
          --variants-stats-out ${modelStores((configModel, configCohorts, configMeta)).variantsStatsGoogle.get}
          --variants-stats-ht-out ${modelStores((configModel, configCohorts, configMeta)).variantsStatsHtGoogle.get}
          ${binary}
          --cloud
          --log ${modelStores((configModel, configCohorts, configMeta)).variantsStatsHailLogGoogle.get}"""
            .in(ProjectStores.hailUtilsGoogle.get, arrayStores(array).refData.mtGoogle.get, modelStores((configModel, configCohorts, configMeta)).phenoGoogle.get)
            .out(modelStores((configModel, configCohorts, configMeta)).variantsStatsGoogle.get, modelStores((configModel, configCohorts, configMeta)).variantsStatsHtGoogle.get, modelStores((configModel, configCohorts, configMeta)).variantsStatsHailLogGoogle.get)
            .tag(s"${modelStores((configModel, configCohorts, configMeta)).variantsStats}.google".split("/").last)
      
      }
      
      local {
      
        googleCopy(modelStores((configModel, configCohorts, configMeta)).variantsStatsGoogle.get, modelStores((configModel, configCohorts, configMeta)).variantsStats)
        googleCopy(modelStores((configModel, configCohorts, configMeta)).variantsStatsHailLogGoogle.get, modelStores((configModel, configCohorts, configMeta)).variantsStatsHailLog)
      
      }

    case false =>

      drmWith(imageName = s"${utils.image.imgHail}", cores = projectConfig.resources.filterModelVariantsHail.cpus, mem = projectConfig.resources.filterModelVariantsHail.mem, maxRunTime = projectConfig.resources.filterModelVariantsHail.maxRunTime) {
      
        cmd"""${utils.binary.binPython} ${utils.python.pyHailModelVariantStats}
          --reference-genome ${projectConfig.referenceGenome}
          --mt-in ${arrayStores(array).refData.mt.get}
          --pheno-in ${modelStores((configModel, configCohorts, configMeta)).pheno}
          --iid-col ${projectConfig.phenoFileId}
          --pheno-col ${configModel.pheno}
          --variants-stats-out ${modelStores((configModel, configCohorts, configMeta)).variantsStats}
          --variants-stats-ht-out ${modelStores((configModel, configCohorts, configMeta)).variantsStatsHt}
          ${binary}
          --log ${modelStores((configModel, configCohorts, configMeta)).variantsStatsHailLog}"""
            .in(arrayStores(array).refData.mt.get, modelStores((configModel, configCohorts, configMeta)).pheno)
            .out(modelStores((configModel, configCohorts, configMeta)).variantsStats, modelStores((configModel, configCohorts, configMeta)).variantsStatsHt, modelStores((configModel, configCohorts, configMeta)).variantsStatsHailLog)
            .tag(s"${modelStores((configModel, configCohorts, configMeta)).variantsStats}".split("/").last)
      
      }

  }

  (configModel.design, configModel.filterCohorts.size) match {

    case ("full", n) if n > 0 =>

      for {
      
        cohort <- configCohorts if configModel.filterCohorts.contains(cohort.id)
      
      } yield {

        projectConfig.hailCloud match {
        
          case true =>
        
            googleWith(projectConfig.cloudResources.mtCluster) {
          
              hail"""${utils.python.pyHailModelVariantStats} --
                --hail-utils ${ProjectStores.hailUtilsGoogle.get}
                --reference-genome ${projectConfig.referenceGenome}
                --mt-in ${arrayStores(array).refData.mtGoogle.get}
                --pheno-in ${modelStores((configModel, configCohorts, configMeta)).phenoGoogle.get}
                --iid-col ${projectConfig.phenoFileId}
                --pheno-col ${configModel.pheno}
                --cohorts-map-in ${modelStores((configModel, configCohorts, configMeta)).cohortMapGoogle.get}
                --cohort ${cohort.id}
                --variants-stats-out ${modelStores((configModel, configCohorts, configMeta)).cohortVariantsStatsGoogle.get(cohort)}
                --variants-stats-ht-out ${modelStores((configModel, configCohorts, configMeta)).cohortVariantsStatsHtGoogle.get(cohort)}
                ${binary}
                --cloud
                --log ${modelStores((configModel, configCohorts, configMeta)).cohortVariantsStatsHailLogGoogle.get(cohort)}"""
                  .in(ProjectStores.hailUtilsGoogle.get, arrayStores(array).refData.mtGoogle.get, modelStores((configModel, configCohorts, configMeta)).phenoGoogle.get, modelStores((configModel, configCohorts, configMeta)).cohortMapGoogle.get)
                  .out(modelStores((configModel, configCohorts, configMeta)).cohortVariantsStatsGoogle.get(cohort), modelStores((configModel, configCohorts, configMeta)).cohortVariantsStatsHtGoogle.get(cohort), modelStores((configModel, configCohorts, configMeta)).cohortVariantsStatsHailLogGoogle.get(cohort))
                  .tag(s"${modelStores((configModel, configCohorts, configMeta)).cohortVariantsStatsGoogle.get(cohort)}.google".split("/").last)
            
            }
            
            local {
            
              googleCopy(modelStores((configModel, configCohorts, configMeta)).cohortVariantsStatsGoogle.get(cohort), modelStores((configModel, configCohorts, configMeta)).cohortVariantsStats.get(cohort))
              googleCopy(modelStores((configModel, configCohorts, configMeta)).cohortVariantsStatsHailLogGoogle.get(cohort), modelStores((configModel, configCohorts, configMeta)).cohortVariantsStatsHailLog.get(cohort))
            
            }

          case false =>
          
            drmWith(imageName = s"${utils.image.imgHail}", cores = projectConfig.resources.filterModelVariantsHail.cpus, mem = projectConfig.resources.filterModelVariantsHail.mem, maxRunTime = projectConfig.resources.filterModelVariantsHail.maxRunTime) {
            
                cmd"""${utils.binary.binPython} ${utils.python.pyHailModelVariantStats}
                  --reference-genome ${projectConfig.referenceGenome}
                  --mt-in ${arrayStores(array).refData.mt.get}
                  --pheno-in ${modelStores((configModel, configCohorts, configMeta)).pheno}
                  --iid-col ${projectConfig.phenoFileId}
                  --pheno-col ${configModel.pheno}
                  --cohorts-map-in ${modelStores((configModel, configCohorts, configMeta)).cohortMap}
                  --cohort ${cohort.id}
                  --variants-stats-out ${modelStores((configModel, configCohorts, configMeta)).cohortVariantsStats.get(cohort)}
                  --variants-stats-ht-out ${modelStores((configModel, configCohorts, configMeta)).cohortVariantsStatsHt.get(cohort)}
                  ${binary}
                  --log ${modelStores((configModel, configCohorts, configMeta)).cohortVariantsStatsHailLog.get(cohort)}"""
                    .in(arrayStores(array).refData.mt.get, modelStores((configModel, configCohorts, configMeta)).pheno, modelStores((configModel, configCohorts, configMeta)).cohortMap)
                    .out(modelStores((configModel, configCohorts, configMeta)).cohortVariantsStats.get(cohort), modelStores((configModel, configCohorts, configMeta)).cohortVariantsStatsHt.get(cohort), modelStores((configModel, configCohorts, configMeta)).cohortVariantsStatsHailLog.get(cohort))
                    .tag(s"${modelStores((configModel, configCohorts, configMeta)).cohortVariantsStats.get(cohort)}".split("/").last)
              
              }

        }

      }

    case _ => ()

  }

}
