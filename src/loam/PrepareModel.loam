/**
 * Prepare Model Cohorts
 * 
 */
import ProjectConfig._
import ArrayStores._
import ProjectStores._
import ModelStores._
import AssocStores._

final case class CfgException(s: String) extends Exception(s)

def PrepareModel(configModel: ConfigModel, configCohort: ConfigCohort, configMeta: Option[ConfigMeta] = None): Unit = {

  val array = projectConfig.Arrays.filter(e => e.id == configCohort.array).head

  val stratCol = {
    configCohort.stratCol match {
      case Some(a) => "--strat-col " + a
      case _ => ""
    }
  }

  val stratCodes = {
    configCohort.stratCodes match {
      case Some(a) => "--strat-codes " + a.mkString(",")
      case _ => ""
    }
  }

  val metaPriorSamplesString = configMeta match {
    case Some(s) =>
      val x = for {
        m <- configModel.metas.get.takeWhile(_ != configMeta.get.id)
      } yield {
        s"${modelStores((configModel, configCohort, Some(projectConfig.Metas.filter(e => e.id == m).head))).samplesAvailable.toString.split("@")(1)}"
      }
      x.size match {
        case n if n > 0 => "--meta-prior-samples " + x.mkString(",") + "--meta-cohorts " + s"${configMeta.get.cohorts}".mkString(",") + "--cckinship " + s"${metaKinshipStores(configMeta.get).kin0}"
        case _ => ""
      }
    case None => ""
  }

  val modelCohortSamplesAvailableIn = configMeta match {
    case Some(s) => 
      val x = for {
        m <- configModel.metas.get.takeWhile(_ != configMeta.get.id)
      } yield {
        modelStores((configModel, configCohort, Some(projectConfig.Metas.filter(e => e.id == m).head))).samplesAvailable
      }
      (x.toSeq ++ arrayStores(array).filteredData.plink.data.local.get) :+ metaKinshipStores(configMeta.get).kin0 :+ ProjectStores.phenoFile.get :+ ProjectStores.ancestryInferred :+ arrayStores(array).sampleQcData.stats :+ arrayStores(array).kinshipData.kin0 :+ arrayStores(array).filterQc.samplesExclude :+ arrayStores(array).filterPostQc.samplesExclude
    case None =>
      arrayStores(array).filteredData.plink.data.local.get :+ ProjectStores.phenoFile.get :+ ProjectStores.ancestryInferred :+ arrayStores(array).sampleQcData.stats :+ arrayStores(array).kinshipData.kin0 :+ arrayStores(array).filterQc.samplesExclude :+ arrayStores(array).filterPostQc.samplesExclude
  }
  
  drmWith(imageName = s"${utils.image.imgR}") {

    cmd"""${utils.binary.binRscript} --vanilla --verbose
      ${utils.r.rModelCohortSamplesAvailable}
      --pheno-in ${ProjectStores.phenoFile.get}
      --fam-in ${arrayStores(array).filteredData.plink.base.local.get}.fam
      --ancestry-in ${ProjectStores.ancestryInferred}
      --ancestry-keep ${configCohort.ancestry.mkString(",")}
      ${stratCol}
      ${stratCodes}
      ${metaPriorSamplesString}
      --cohort ${configCohort.id}
      --pheno-col ${configModel.pheno}
      --iid-col ${projectConfig.phenoFileId}
      --sampleqc-in ${arrayStores(array).sampleQcData.stats}
      --kinship-in ${arrayStores(array).kinshipData.kin0}
      --samples-exclude-qc ${arrayStores(array).filterQc.samplesExclude}
      --samples-exclude-postqc ${arrayStores(array).filterPostQc.samplesExclude}
      --test ${configModel.test}
      --covars "${configModel.covars}"
      --out-id-map ${modelStores((configModel, configCohort, configMeta)).samplesMap}
      --out ${modelStores((configModel, configCohort, configMeta)).samplesAvailable}
      > ${modelStores((configModel, configCohort, configMeta)).samplesAvailableLog}"""
      .in(modelCohortSamplesAvailableIn)
      .out(modelStores((configModel, configCohort, configMeta)).samplesMap, modelStores((configModel, configCohort, configMeta)).samplesAvailable, modelStores((configModel, configCohort, configMeta)).samplesAvailableLog)
      .tag(s"${modelStores((configModel, configCohort, configMeta)).samplesAvailable}".split("/").last)
  
  }

}
