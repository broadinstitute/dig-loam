/**
 * Prepare Model Cohorts
 * 
 */
import ProjectConfig._
import ArrayStores._
import ProjectStores._
import ModelStores._
import AssocStores._
import Fxns._

final case class CfgException(s: String) extends Exception(s)

def PrepareModel(configModel: ConfigModel, configCohorts: Seq[ConfigCohort], configMeta: Option[ConfigMeta] = None): Unit = {

  val array = projectConfig.Arrays.filter(e => e.id == configCohorts.head.array).head

  val stratStrings = {
    for {
      cohort <- configCohorts
    } yield {
      var s = "--strat " + cohort.id + " " + cohort.ancestry.mkString(",")
      cohort.stratCol match {
        case Some(a) => s = s + " " + a
        case None => s = s + " " + """"N/A""""
      }
      cohort.stratCodes match {
        case Some(a) => s = s + " " + a.mkString(",")
        case None => s = s + " " + """"N/A""""
      }
      s
    }
  }

  val metaPriorSamplesString = configMeta match {
    case Some(s) =>
      var mpss = s"--cohorts ${configCohorts.map(e => e.id).mkString(",")}"
      val x = for {
        c <- configMeta.get.cohorts.takeWhile(_ != configCohorts.head.id)
      } yield {
        s"${modelStores((configModel, Seq(projectConfig.Cohorts.filter(e => e.id == c).head), configMeta)).samplesAvailable.toString.split("@")(1)}"
      }
      x.size match {
        case n if n > 0 => mpss = mpss + " --meta-prior-samples " + x.mkString(",") + " --meta-cohorts " + configMeta.get.cohorts.mkString(",") + " --cckinship " + s"${metaKinshipStores(configMeta.get).kin0.toString.split("@")(1)}"
        case _ => ""
      }
      mpss
    case None => ""
  }

  val modelCohortSamplesAvailableIn = configMeta match {
    case Some(s) => 
      val x = for {
        c <- configMeta.get.cohorts.takeWhile(_ != configCohorts.head.id)
      } yield {
        modelStores((configModel, Seq(projectConfig.Cohorts.filter(e => e.id == c).head), configMeta)).samplesAvailable
      }
      (x.toSeq ++ arrayStores(array).filteredData.plink.data.local.get) :+ metaKinshipStores(configMeta.get).kin0 :+ ProjectStores.phenoFile.get :+ ProjectStores.ancestryInferred :+ arrayStores(array).sampleQcData.stats :+ arrayStores(array).kinshipData.kin0 :+ arrayStores(array).filterQc.samplesExclude :+ arrayStores(array).filterPostQc.samplesExclude
    case None =>
      arrayStores(array).filteredData.plink.data.local.get :+ ProjectStores.phenoFile.get :+ ProjectStores.ancestryInferred :+ arrayStores(array).sampleQcData.stats :+ arrayStores(array).kinshipData.kin0 :+ arrayStores(array).filterQc.samplesExclude :+ arrayStores(array).filterPostQc.samplesExclude
  }

  val keepRelated = famTests.contains(configModel.test) match {
    case true => "--keep-related"
    case false => ""
  }
  
  drmWith(imageName = s"${utils.image.imgR}") {

    cmd"""${utils.binary.binRscript} --vanilla --verbose
      ${utils.r.rModelCohortSamplesAvailable}
      --pheno-in ${ProjectStores.phenoFile.get}
      --fam-in ${arrayStores(array).filteredData.plink.base.local.get}.fam
      --ancestry-in ${ProjectStores.ancestryInferred}
      ${stratStrings.mkString(" ")}
      ${metaPriorSamplesString}
      --pheno-col ${configModel.pheno}
      --iid-col ${projectConfig.phenoFileId}
      --sampleqc-in ${arrayStores(array).sampleQcData.stats}
      --kinship-in ${arrayStores(array).kinshipData.kin0}
      --samples-exclude-qc ${arrayStores(array).filterQc.samplesExclude}
      --samples-exclude-postqc ${arrayStores(array).filterPostQc.samplesExclude}
      ${keepRelated}
      --covars "${configModel.covars}"
      --out-pheno-prelim ${modelStores((configModel, configCohorts, configMeta)).phenoPrelim}
      --out-id-map ${modelStores((configModel, configCohorts, configMeta)).sampleMap}
      --out-cohorts-map ${modelStores((configModel, configCohorts, configMeta)).cohortMap}
      --out ${modelStores((configModel, configCohorts, configMeta)).samplesAvailable}
      > ${modelStores((configModel, configCohorts, configMeta)).samplesAvailableLog}"""
      .in(modelCohortSamplesAvailableIn)
      .out(modelStores((configModel, configCohorts, configMeta)).sampleMap, modelStores((configModel, configCohorts, configMeta)).phenoPrelim, modelStores((configModel, configCohorts, configMeta)).samplesAvailable, modelStores((configModel, configCohorts, configMeta)).samplesAvailableLog)
      .tag(s"${modelStores((configModel, configCohorts, configMeta)).samplesAvailable}".split("/").last)
  
  }

  val trans = configModel.trans match {
    case Some(s) => configModel.trans.get
    case None => "N/A"
  }
  
  drmWith(imageName = s"${utils.image.imgFlashPca}", cores = projectConfig.resources.generatePheno.cpus, mem = projectConfig.resources.generatePheno.mem, maxRunTime = projectConfig.resources.generatePheno.maxRunTime) {
  
    cmd"""${utils.bash.shFlashPca}
      ${utils.binary.binFlashPca}
      ${utils.binary.binRscript}
      ${utils.binary.binPlink}
      ${utils.r.rGeneratePheno}
      ${projectConfig.resources.generatePheno.cpus}
      ${arrayStores(array).prunedData.plink.base}
      ${modelStores((configModel, configCohorts, configMeta)).samplesAvailable}
      ${modelStores((configModel, configCohorts, configMeta)).pcaBase}
      ${modelStores((configModel, configCohorts, configMeta)).pcaScores}
      ${modelStores((configModel, configCohorts, configMeta)).pcaEigenVecs}
      ${modelStores((configModel, configCohorts, configMeta)).pcaLoadings}
      ${modelStores((configModel, configCohorts, configMeta)).pcaEigenVals}
      ${modelStores((configModel, configCohorts, configMeta)).pcaPve}
      ${modelStores((configModel, configCohorts, configMeta)).pcaMeansd}
      ${configModel.maxPcaOutlierIterations}
      ${modelStores((configModel, configCohorts, configMeta)).phenoPrelim}
      ${configModel.pheno}
      ${projectConfig.phenoFileId}
      "${trans}"
      "${configModel.covars}"
      ${projectConfig.minPCs}
      ${projectConfig.maxPCs}
      ${projectConfig.nStddevs}
      ${modelStores((configModel, configCohorts, configMeta)).pheno}
      ${modelStores((configModel, configCohorts, configMeta)).pcsInclude}
      ${modelStores((configModel, configCohorts, configMeta)).outliers}
      > ${modelStores((configModel, configCohorts, configMeta)).pcaLog}"""
      .in(arrayStores(array).prunedData.plink.data :+ modelStores((configModel, configCohorts, configMeta)).samplesAvailable :+ modelStores((configModel, configCohorts, configMeta)).phenoPrelim :+ ProjectStores.phenoFile.get)
      .out(modelStores((configModel, configCohorts, configMeta)).pcaScores, modelStores((configModel, configCohorts, configMeta)).pcaEigenVecs, modelStores((configModel, configCohorts, configMeta)).pcaLoadings, modelStores((configModel, configCohorts, configMeta)).pcaEigenVals, modelStores((configModel, configCohorts, configMeta)).pcaPve, modelStores((configModel, configCohorts, configMeta)).pcaMeansd, modelStores((configModel, configCohorts, configMeta)).pheno, modelStores((configModel, configCohorts, configMeta)).pcsInclude, modelStores((configModel, configCohorts, configMeta)).outliers, modelStores((configModel, configCohorts, configMeta)).pcaLog)
      .tag(s"${modelStores((configModel, configCohorts, configMeta)).pheno}".split("/").last)
  
  }
  
  var filters = Seq[String]()
  var cohortFilters = Seq[String]()
  var knockoutFilters = Seq[String]()
  var masks = Seq[String]()
  var filterFields = Seq[String]()
  configModel.filters match {
    case Some(l) =>
      filters = filters ++ variantFiltersToPrintableList(cfg = projectConfig, filters = l)
      filterFields = filterFields ++ getFilterFields(cfg = projectConfig, filters = l)
    case None => ()
  }
  configModel.cohortFilters match {
    case Some(l) =>
      for {
        cf <- l if configCohorts.map(e => e.id).contains(cf.cohort)
      } yield {
        cohortFilters = cohortFilters ++ variantFiltersToPrintableList(cfg = projectConfig, filters = cf.filters, id = Some(cf.cohort))
        filterFields = filterFields ++ getFilterFields(cfg = projectConfig, filters = cf.filters)
      }
    case None => ()
  }
  configModel.knockoutFilters match {
    case Some(l) =>
      for {
        cf <- l if configCohorts.map(e => e.id).contains(cf.cohort)
      } yield {
        knockoutFilters = knockoutFilters ++ variantFiltersToPrintableList(cfg = projectConfig, filters = cf.filters, id = Some(cf.cohort))
        filterFields = filterFields ++ getFilterFields(cfg = projectConfig, filters = cf.filters)
      }
    case None => ()
  }
  configModel.masks match {
    case Some(l) =>
      for {
        mf <- l
      } yield {
        masks = masks ++ variantFiltersToPrintableList(cfg = projectConfig, filters = mf.filters, id = Some(mf.id))
        filterFields = filterFields ++ getFilterFields(cfg = projectConfig, filters = mf.filters)
      }
    case None => ()
  }
  
  val fString = filters.size match {
  
    case n if n > 0 => s"""echo "${filters.mkString("\n")}" > """
    case _ => "touch "
  
  }

  drmWith(imageName = s"${utils.image.imgTools}") {
  
    cmd"""${fString} ${modelStores((configModel, configCohorts, configMeta)).filters}"""
      .out(modelStores((configModel, configCohorts, configMeta)).filters)
      .tag(s"${modelStores((configModel, configCohorts, configMeta)).filters}".split("/").last)
  
  }

  configModel.design match {
  
    case "full" =>

      val cfString = cohortFilters.size match {
      
        case n if n > 0 => s"""echo "${cohortFilters.mkString("\n")}" > """
        case _ => "touch "
      
      }
      
      drmWith(imageName = s"${utils.image.imgTools}") {
      
        cmd"""${cfString} ${modelStores((configModel, configCohorts, configMeta)).cohortFilters.get}"""
          .out(modelStores((configModel, configCohorts, configMeta)).cohortFilters.get)
          .tag(s"${modelStores((configModel, configCohorts, configMeta)).cohortFilters.get}".split("/").last)
      
      }

    case _ => ()

  }

  configModel.design match {
  
    case "full" =>
  
      val kfString = knockoutFilters.size match {
      
        case n if n > 0 => s"""echo "${knockoutFilters.mkString("\n")}" > """
        case _ => "touch "
      
      }
      
      drmWith(imageName = s"${utils.image.imgTools}") {
      
        cmd"""${kfString} ${modelStores((configModel, configCohorts, configMeta)).knockoutFilters.get}"""
          .out(modelStores((configModel, configCohorts, configMeta)).knockoutFilters.get)
          .tag(s"${modelStores((configModel, configCohorts, configMeta)).knockoutFilters.get}".split("/").last)
      
      }

    case _ => ()

  }

  val mString = masks.size match {
  
    case n if n > 0 => s"""echo "${masks.mkString("\n")}" > """
    case _ => "touch "
  
  }

  drmWith(imageName = s"${utils.image.imgTools}") {
  
    cmd"""${mString} ${modelStores((configModel, configCohorts, configMeta)).masks}"""
      .out(modelStores((configModel, configCohorts, configMeta)).masks)
      .tag(s"${modelStores((configModel, configCohorts, configMeta)).masks}".split("/").last)
  
  }

  val binary = binaryAssocTests.contains(configModel.test) match {
    case true => "--binary"
    case false => ""
  }
  
  projectConfig.hailCloud match {
  
    case true =>
  
      local {
      
        googleCopy(modelStores((configModel, configCohorts, configMeta)).pheno, modelStores((configModel, configCohorts, configMeta)).phenoGoogle.get)
      
      }
      
      googleWith(projectConfig.cloudResources.mtCluster) {
      
        hail"""${utils.python.pyHailModelVariantStats} --
          --hail-utils ${ProjectStores.hailUtilsGoogle.get}
          --reference-genome ${projectConfig.referenceGenome}
          --mt-in ${arrayStores(array).refData.mtGoogle.get}
          --pheno-in ${modelStores((configModel, configCohorts, configMeta)).phenoGoogle.get}
          --iid-col ${projectConfig.phenoFileId}
          --pheno-col ${configModel.pheno}
          --variants-stats-out ${modelStores((configModel, configCohorts, configMeta)).variantsStatsGoogle.get}
          --variants-stats-ht-out ${modelStores((configModel, configCohorts, configMeta)).variantsStatsHtGoogle.get}
          ${binary}
          --cloud
          --log ${modelStores((configModel, configCohorts, configMeta)).variantsStatsHailLogGoogle.get}"""
            .in(ProjectStores.hailUtilsGoogle.get, arrayStores(array).refData.mtGoogle.get, modelStores((configModel, configCohorts, configMeta)).phenoGoogle.get)
            .out(modelStores((configModel, configCohorts, configMeta)).variantsStatsGoogle.get, modelStores((configModel, configCohorts, configMeta)).variantsStatsHtGoogle.get, modelStores((configModel, configCohorts, configMeta)).variantsStatsHailLogGoogle.get)
            .tag(s"${modelStores((configModel, configCohorts, configMeta)).variantsStats}.google".split("/").last)
      
      }
      
      local {
      
        googleCopy(modelStores((configModel, configCohorts, configMeta)).variantsStatsGoogle.get, modelStores((configModel, configCohorts, configMeta)).variantsStats)
        googleCopy(modelStores((configModel, configCohorts, configMeta)).variantsStatsHailLogGoogle.get, modelStores((configModel, configCohorts, configMeta)).variantsStatsHailLog)
      
      }
  
    case false =>

      drmWith(imageName = s"${utils.image.imgHail}", cores = projectConfig.resources.filterModelVariantsHail.cpus, mem = projectConfig.resources.filterModelVariantsHail.mem, maxRunTime = projectConfig.resources.filterModelVariantsHail.maxRunTime) {
      
        cmd"""${utils.binary.binPython} ${utils.python.pyHailModelVariantStats}
          --reference-genome ${projectConfig.referenceGenome}
          --mt-in ${arrayStores(array).refData.mt.get}
          --pheno-in ${modelStores((configModel, configCohorts, configMeta)).pheno}
          --iid-col ${projectConfig.phenoFileId}
          --pheno-col ${configModel.pheno}
          --variants-stats-out ${modelStores((configModel, configCohorts, configMeta)).variantsStats}
          --variants-stats-ht-out ${modelStores((configModel, configCohorts, configMeta)).variantsStatsHt.get}
          ${binary}
          --log ${modelStores((configModel, configCohorts, configMeta)).variantsStatsHailLog}"""
            .in(arrayStores(array).refData.mt.get, modelStores((configModel, configCohorts, configMeta)).pheno)
            .out(modelStores((configModel, configCohorts, configMeta)).variantsStats, modelStores((configModel, configCohorts, configMeta)).variantsStatsHt.get, modelStores((configModel, configCohorts, configMeta)).variantsStatsHailLog)
            .tag(s"${modelStores((configModel, configCohorts, configMeta)).variantsStats}".split("/").last)
      
      }
  
  }

  (configModel.design, configModel.filterCohorts.size) match {
  
    case ("full", n) if n > 0 =>

      projectConfig.hailCloud match {
        
        case true =>
  
          local {
  
            googleCopy(modelStores((configModel, configCohorts, configMeta)).cohortMap, modelStores((configModel, configCohorts, configMeta)).cohortMapGoogle.get)
  
          }

        case false => ()

      }
  
      for {
      
        cohort <- configCohorts if configModel.filterCohorts.contains(cohort.id)
      
      } yield {
  
        projectConfig.hailCloud match {
        
          case true =>
        
            googleWith(projectConfig.cloudResources.mtCluster) {
          
              hail"""${utils.python.pyHailModelVariantStats} --
                --hail-utils ${ProjectStores.hailUtilsGoogle.get}
                --reference-genome ${projectConfig.referenceGenome}
                --mt-in ${arrayStores(array).refData.mtGoogle.get}
                --pheno-in ${modelStores((configModel, configCohorts, configMeta)).phenoGoogle.get}
                --iid-col ${projectConfig.phenoFileId}
                --pheno-col ${configModel.pheno}
                --cohorts-map-in ${modelStores((configModel, configCohorts, configMeta)).cohortMapGoogle.get}
                --cohort ${cohort.id}
                --variants-stats-out ${modelStores((configModel, configCohorts, configMeta)).cohortVariantsStatsGoogle.get(cohort)}
                --variants-stats-ht-out ${modelStores((configModel, configCohorts, configMeta)).cohortVariantsStatsHtGoogle.get(cohort)}
                ${binary}
                --cloud
                --log ${modelStores((configModel, configCohorts, configMeta)).cohortVariantsStatsHailLogGoogle.get(cohort)}"""
                  .in(ProjectStores.hailUtilsGoogle.get, arrayStores(array).refData.mtGoogle.get, modelStores((configModel, configCohorts, configMeta)).phenoGoogle.get, modelStores((configModel, configCohorts, configMeta)).cohortMapGoogle.get)
                  .out(modelStores((configModel, configCohorts, configMeta)).cohortVariantsStatsGoogle.get(cohort), modelStores((configModel, configCohorts, configMeta)).cohortVariantsStatsHtGoogle.get(cohort), modelStores((configModel, configCohorts, configMeta)).cohortVariantsStatsHailLogGoogle.get(cohort))
                  .tag(s"${modelStores((configModel, configCohorts, configMeta)).cohortVariantsStats.get(cohort)}.google".split("/").last)
            
            }
            
            local {
            
              googleCopy(modelStores((configModel, configCohorts, configMeta)).cohortVariantsStatsGoogle.get(cohort), modelStores((configModel, configCohorts, configMeta)).cohortVariantsStats.get(cohort))
              googleCopy(modelStores((configModel, configCohorts, configMeta)).cohortVariantsStatsHailLogGoogle.get(cohort), modelStores((configModel, configCohorts, configMeta)).cohortVariantsStatsHailLog.get(cohort))
            
            }
  
          case false =>
          
            drmWith(imageName = s"${utils.image.imgHail}", cores = projectConfig.resources.filterModelVariantsHail.cpus, mem = projectConfig.resources.filterModelVariantsHail.mem, maxRunTime = projectConfig.resources.filterModelVariantsHail.maxRunTime) {
            
                cmd"""${utils.binary.binPython} ${utils.python.pyHailModelVariantStats}
                  --reference-genome ${projectConfig.referenceGenome}
                  --mt-in ${arrayStores(array).refData.mt.get}
                  --pheno-in ${modelStores((configModel, configCohorts, configMeta)).pheno}
                  --iid-col ${projectConfig.phenoFileId}
                  --pheno-col ${configModel.pheno}
                  --cohorts-map-in ${modelStores((configModel, configCohorts, configMeta)).cohortMap}
                  --cohort ${cohort.id}
                  --variants-stats-out ${modelStores((configModel, configCohorts, configMeta)).cohortVariantsStats.get(cohort)}
                  --variants-stats-ht-out ${modelStores((configModel, configCohorts, configMeta)).cohortVariantsStatsHt.get(cohort)}
                  ${binary}
                  --log ${modelStores((configModel, configCohorts, configMeta)).cohortVariantsStatsHailLog.get(cohort)}"""
                    .in(arrayStores(array).refData.mt.get, modelStores((configModel, configCohorts, configMeta)).pheno, modelStores((configModel, configCohorts, configMeta)).cohortMap)
                    .out(modelStores((configModel, configCohorts, configMeta)).cohortVariantsStats.get(cohort), modelStores((configModel, configCohorts, configMeta)).cohortVariantsStatsHt.get(cohort), modelStores((configModel, configCohorts, configMeta)).cohortVariantsStatsHailLog.get(cohort))
                    .tag(s"${modelStores((configModel, configCohorts, configMeta)).cohortVariantsStats.get(cohort)}".split("/").last)
              
              }
  
        }
  
      }
  
    case _ => ()
  
  }
  
  projectConfig.hailCloud match {
  
    case true =>
  
      local {
  
        googleCopy(modelStores((configModel, configCohorts, configMeta)).filters, modelStores((configModel, configCohorts, configMeta)).filtersGoogle.get)
        googleCopy(modelStores((configModel, configCohorts, configMeta)).masks, modelStores((configModel, configCohorts, configMeta)).masksGoogle.get)
  
      }
  
      configModel.design match {
  
        case "full" =>
  
          local {
  
            googleCopy(modelStores((configModel, configCohorts, configMeta)).cohortFilters.get, modelStores((configModel, configCohorts, configMeta)).cohortFiltersGoogle.get)
            googleCopy(modelStores((configModel, configCohorts, configMeta)).knockoutFilters.get, modelStores((configModel, configCohorts, configMeta)).knockoutFiltersGoogle.get)
  
          }
  
        case _ => ()
  
      }
  
      val cohortStatsInString = {
      
        modelStores((configModel, configCohorts, configMeta)).cohortVariantsStatsHtGoogle match {
          case Some(s) =>
            val x = "--cohort-stats-in"
            val y = for {
              (k, v) <- s
            } yield {
              s"""${k.id},${v.toString.split("@")(1)}"""
            }
            x + " " + y.mkString(" ")
          case None => ""
        }
      
      }
  
      val cohortFiltersInString = {
  
        configModel.design match {
  
          case "full" => s"""--cohort-filters ${modelStores((configModel, configCohorts, configMeta)).cohortFiltersGoogle.get.toString.split("@")(1)}"""
          case _ => ""
  
        }
  
      }
  
      val knockoutFiltersInString = {
  
        configModel.design match {
          case "full" => s"""--knockout-filters ${modelStores((configModel, configCohorts, configMeta)).knockoutFiltersGoogle.get.toString.split("@")(1)}"""
          case _ => ""
  
        }
  
      }
  
      var cohortStatsIn = Seq(ProjectStores.hailUtilsGoogle.get, modelStores((configModel, configCohorts, configMeta)).variantsStatsHtGoogle.get, arrayStores(array).refData.annotationsHtGoogle.get, modelStores((configModel, configCohorts, configMeta)).filtersGoogle.get, modelStores((configModel, configCohorts, configMeta)).masksGoogle.get, arrayStores(array).filterPostQc.variantsExcludeGoogle.get)
      
      modelStores((configModel, configCohorts, configMeta)).cohortVariantsStatsHtGoogle match {
        case Some(s) =>
          cohortStatsIn = cohortStatsIn ++ {
            for {
              (k, v) <- s
            } yield {
              v
            }
          }
        case None => ()
      }
  
      configModel.design match {
  
          case "full" => cohortStatsIn = cohortStatsIn ++ Seq(modelStores((configModel, configCohorts, configMeta)).cohortFiltersGoogle.get, modelStores((configModel, configCohorts, configMeta)).knockoutFiltersGoogle.get)
          case _ => ()
  
      }
      
      googleWith(projectConfig.cloudResources.mtCluster) {
      
        hail"""${utils.python.pyHailFilterModelVariants} --
          --cloud
          --hail-utils ${ProjectStores.hailUtilsGoogle.get}
          --reference-genome ${projectConfig.referenceGenome}
          --full-stats-in ${modelStores((configModel, configCohorts, configMeta)).variantsStatsHtGoogle.get}
          ${cohortStatsInString}
          --annotation ${arrayStores(array).refData.annotationsHtGoogle.get}
          --filters ${modelStores((configModel, configCohorts, configMeta)).filtersGoogle.get}
          ${cohortFiltersInString}
          ${knockoutFiltersInString}
          --masks ${modelStores((configModel, configCohorts, configMeta)).masksGoogle.get}
          --variants-remove ${arrayStores(array).filterPostQc.variantsExcludeGoogle.get}
          --variant-filters-out ${modelStores((configModel, configCohorts, configMeta)).variantFilterTableGoogle.get}
          --ht-checkpoint ${modelStores((configModel, configCohorts, configMeta)).variantFilterHtCheckpointGoogle.get}
          --variant-filters-ht-out ${modelStores((configModel, configCohorts, configMeta)).variantFilterHailTableGoogle.get}
          --log ${modelStores((configModel, configCohorts, configMeta)).variantFilterHailLogGoogle.get}"""
            .in(cohortStatsIn)
            .out(modelStores((configModel, configCohorts, configMeta)).variantFilterTableGoogle.get, modelStores((configModel, configCohorts, configMeta)).variantFilterHtCheckpointGoogle.get, modelStores((configModel, configCohorts, configMeta)).variantFilterHailTableGoogle.get, modelStores((configModel, configCohorts, configMeta)).variantFilterHailLogGoogle.get)
            .tag(s"${modelStores((configModel, configCohorts, configMeta)).variantFilterTable}.google".split("/").last)
      
      }
      
      local {
      
        googleCopy(modelStores((configModel, configCohorts, configMeta)).variantFilterTableGoogle.get, modelStores((configModel, configCohorts, configMeta)).variantFilterTable)
        googleCopy(modelStores((configModel, configCohorts, configMeta)).variantFilterHailLogGoogle.get, modelStores((configModel, configCohorts, configMeta)).variantFilterHailLog)
      
      }
  
    case false =>
  
      val cohortStatsInString = {
      
        modelStores((configModel, configCohorts, configMeta)).cohortVariantsStatsHt match {
          case Some(s) =>
            val x = "--cohort-stats-in"
            val y = for {
              (k, v) <- s
            } yield {
              s"""${k.id},${v.toString.split("@")(1)}"""
            }
            x + " " + y.mkString(" ")
          case None => ""
        }
      
      }
  
      val cohortFiltersInString = {
  
        configModel.design match {
  
          case "full" => s"""--cohort-filters ${modelStores((configModel, configCohorts, configMeta)).cohortFilters.get.toString.split("@")(1)}"""
          case _ => ""
  
        }
  
      }
  
      val knockoutFiltersInString = {
  
        configModel.design match {
          case "full" => s"""--knockout-filters ${modelStores((configModel, configCohorts, configMeta)).knockoutFilters.get.toString.split("@")(1)}"""
          case _ => ""
  
        }
  
      }
      
      var cohortStatsIn = Seq(modelStores((configModel, configCohorts, configMeta)).variantsStatsHt.get, arrayStores(array).refData.annotationsHt, modelStores((configModel, configCohorts, configMeta)).filters, modelStores((configModel, configCohorts, configMeta)).masks, arrayStores(array).filterPostQc.variantsExclude)
      
      modelStores((configModel, configCohorts, configMeta)).cohortVariantsStatsHt match {
        case Some(s) =>
          cohortStatsIn = cohortStatsIn ++ {
            for {
              (k, v) <- s
            } yield {
              v
            }
          }
        case None => ()
      }
  
      configModel.design match {
  
          case "full" => cohortStatsIn = cohortStatsIn ++ Seq(modelStores((configModel, configCohorts, configMeta)).cohortFilters.get, modelStores((configModel, configCohorts, configMeta)).knockoutFilters.get)
          case _ => ()
  
      }
  
      drmWith(imageName = s"${utils.image.imgHail}", cores = projectConfig.resources.filterModelVariantsHail.cpus, mem = projectConfig.resources.filterModelVariantsHail.mem, maxRunTime = projectConfig.resources.filterModelVariantsHail.maxRunTime) {
      
        cmd"""${utils.binary.binPython} ${utils.python.pyHailFilterModelVariants}
          --reference-genome ${projectConfig.referenceGenome}
          --full-stats-in ${modelStores((configModel, configCohorts, configMeta)).variantsStatsHt.get}
          ${cohortStatsInString}
          --annotation ${arrayStores(array).refData.annotationsHt}
          --filters ${modelStores((configModel, configCohorts, configMeta)).filters}
          ${cohortFiltersInString}
          ${knockoutFiltersInString}
          --masks ${modelStores((configModel, configCohorts, configMeta)).masks}
          --variants-remove ${arrayStores(array).filterPostQc.variantsExclude}
          --variant-filters-out ${modelStores((configModel, configCohorts, configMeta)).variantFilterTable}
          --ht-checkpoint ${modelStores((configModel, configCohorts, configMeta)).variantFilterHtCheckpoint.get}
          --variant-filters-ht-out ${modelStores((configModel, configCohorts, configMeta)).variantFilterHailTable.get}
          --log ${modelStores((configModel, configCohorts, configMeta)).variantFilterHailLog}"""
            .in(cohortStatsIn)
            .out(modelStores((configModel, configCohorts, configMeta)).variantFilterTable, modelStores((configModel, configCohorts, configMeta)).variantFilterHtCheckpoint.get, modelStores((configModel, configCohorts, configMeta)).variantFilterHailTable.get, modelStores((configModel, configCohorts, configMeta)).variantFilterHailLog)
            .tag(s"${modelStores((configModel, configCohorts, configMeta)).variantFilterTable}".split("/").last)
      
      }
  
  }

  groupTests.contains(configModel.test) match {

    case true =>

      projectConfig.hailCloud match {
      
        case true =>

          val maskedGroupFiles = {
            modelStores((configModel, configCohorts, configMeta)).maskedGroupFileGoogle match {
              case Some(s) =>
                val x = "--masked-groupfiles-out"
                val y = for {
                  (k, v) <- s
                } yield {
                  s"""${k.id},${v.toString.split("@")(1)}"""
                }
                x + " " + y.mkString(" ")
              case None => ""
            }
          }
    
          googleWith(projectConfig.cloudResources.mtCluster) {
          
            hail"""${utils.python.pyHailGenerateGroupfile} --
              --cloud
              --hail-utils ${ProjectStores.hailUtilsGoogle.get}
              ${maskedGroupFiles}
              --filter-table-in ${modelStores((configModel, configCohorts, configMeta)).variantFilterHailTableGoogle.get}
              --groupfile-out ${modelStores((configModel, configCohorts, configMeta)).groupFileGoogle.get}
              --log ${modelStores((configModel, configCohorts, configMeta)).groupFileHailLogGoogle.get}"""
              .in(modelStores((configModel, configCohorts, configMeta)).variantFilterHailTableGoogle.get)
              .out(modelStores((configModel, configCohorts, configMeta)).groupFileGoogle.get, modelStores((configModel, configCohorts, configMeta)).groupFileHailLogGoogle.get)
              .tag(s"${modelStores((configModel, configCohorts, configMeta)).groupFile.get}.google".split("/").last)
    
          }

          local {

            googleCopy(modelStores((configModel, configCohorts, configMeta)).groupFileGoogle.get, modelStores((configModel, configCohorts, configMeta)).groupFile.get)
            googleCopy(modelStores((configModel, configCohorts, configMeta)).groupFileHailLogGoogle.get, modelStores((configModel, configCohorts, configMeta)).groupFileHailLog.get)

          }

        case false =>

          val maskedGroupFiles = {
            modelStores((configModel, configCohorts, configMeta)).maskedGroupFile match {
              case Some(s) =>
                val x = "--masked-groupfiles-out"
                val y = for {
                  (k, v) <- s
                } yield {
                  s"""${k.id},${v.toString.split("@")(1)}"""
                }
                x + " " + y.mkString(" ")
              case None => ""
            }
          }

          drmWith(imageName = s"${utils.image.imgHail}", cores = projectConfig.resources.filterModelVariantsHail.cpus, mem = projectConfig.resources.filterModelVariantsHail.mem, maxRunTime = projectConfig.resources.filterModelVariantsHail.maxRunTime) {
          
            cmd"""${utils.binary.binPython} ${utils.python.pyHailGenerateGroupfile}
              ${maskedGroupFiles}
              --filter-table-in ${modelStores((configModel, configCohorts, configMeta)).variantFilterHailTable.get}
              --groupfile-out ${modelStores((configModel, configCohorts, configMeta)).groupFile.get}
              --log ${modelStores((configModel, configCohorts, configMeta)).groupFileHailLog.get}"""
              .in(modelStores((configModel, configCohorts, configMeta)).variantFilterHailTable.get)
              .out(modelStores((configModel, configCohorts, configMeta)).groupFile.get, modelStores((configModel, configCohorts, configMeta)).groupFileHailLog.get)
              .tag(s"${modelStores((configModel, configCohorts, configMeta)).groupFile.get}".split("/").last)

          }
    
      }

    case false => ()

  }

}
