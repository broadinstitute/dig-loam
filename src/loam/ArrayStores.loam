import ProjectConfig._
import PipelineConfig._
import StoreHelpers._
import Stores._
import Fxns._

final case class RawData(
  plink: Option[Plink],
  vcf: Option[MultiPathVcf],
  unplaced: Option[Store],
  unique: Option[Store],
  indel: Option[Store],
  lmiss: Option[Store],
  imiss: Option[Store],
  imissRemove: Option[Store],
  freq: Option[Store],
  mono: Option[Store],
  dupRemove: Option[Store])

final case class PreparedData(
  plink: Plink,
  multiallelic: Store,
  chain: Option[Store] = None,
  bed: Option[Store] = None,
  lifted: Option[Store] = None,
  unlifted: Option[Store] = None,
  liftedUpdate: Option[Store] = None,
  liftedExtract: Option[Store] = None)

final case class AnnotatedData(
  plink: Plink)

final case class AnnotatedChrData(
  plink: Plink,
  mergedKgPlink: Plink,
  mergedKgHuRefPlink: Plink,
  mergedKgNonKgBase: Path,
  nonKgRemove: Store,
  nonKgIgnore: Store,
  nonKgMono: Store,
  nonKgNomatch: Store,
  nonKgFlip: Store,
  nonKgForceA1: Store,
  mergedKgVarIdUpdate: Store,
  mergedKgVarSnpLog: Store)

final case class HarmonizedData(
  plink: Plink,
  mergeList: Store,
  nonKgRemove: Store,
  nonKgIgnore: Store,
  nonKgMono: Store,
  nonKgNomatch: Store,
  nonKgFlip: Store,
  nonKgForceA1: Store,
  mergedKgVarIdUpdate: Store,
  mergedKgVarSnpLog: Store,
  forceA2: Store)

final case class RefData(
  plink: Option[Plink],
  vcf: MultiPathVcf,
  mt: Option[Store],
  mtGoogle: Option[Store],
  hailLog: Store,
  hailLogGoogle: Option[Store],
  variantMetrics: Store,
  variantMetricsGoogle: Option[Store],
  sitesVcf: Store,
  sitesVcfGoogle: Option[Store],
  annotations: Store,
  annotationWarnings: Store)

final case class ImputeData(
  data: Seq[Store],
  base: Path)

final case class FilteredData(
  variantMetrics: Store,
  variantMetricsGoogle: Option[Store],
  plink: MultiPathPlink,
  hailLog: Store,
  hailLogGoogle: Option[Store],
  pruneIn: Store)

final case class PrunedData(
  plink: Plink)

final case class KinshipData(
  base: Path,
  log: Store,
  kin: Store,
  kin0: Store,
  kin0Related: Store,
  famSizes: Store)

final case class Ref1kgData(
  plink: MultiPathPlink,
  hailLog: Store,
  hailLogGoogle: Option[Store],
  kgSamples: Store,
  kgSamplesGoogle: Option[Store],
  gds: Store)

final case class AncestryData(
  inferred: Store)

final case class AncestryPcaData(
  base: Path,
  log: Store,
  scores: Store,
  plots: Store)

final case class AncestryClusterData(
  base: Path,
  log: Store,
  fet: Store,
  clu: Store,
  klg: Store,
  plots: Store,
  centerPlots: Store,
  no1kgPlots: Store,
  xtab: Store,
  groups: Store)

final case class PcaData(
  gds: Store,
  log: Store,
  scores: Store)

final case class SexcheckData(
  sexcheck: Store,
  sexcheckGoogle: Option[Store],
  problems: Store,
  problemsGoogle: Option[Store],
  hailLog: Store,
  hailLogGoogle: Option[Store])

final case class SampleQcData(
  stats: Store,
  statsGoogle: Option[Store],
  hailLog: Store,
  hailLogGoogle: Option[Store],
  statsAdj: Store,
  corrPlots: Store,
  boxPlots: Store,
  discreteness: Store,
  pcaLoadings: Store,
  pcaPlots: Store,
  pcaScores: Store,
  outliers: Store,
  metricPlots: Store)

final case class SampleQcPcaClusterData(
  base: Path,
  fet: Store,
  clu: Store,
  klg: Store,
  log: Store,
  outliers: Store,
  plots: Store,
  xtab: Store)

final case class SampleQcMetricClusterData(
  base: Path,
  fet: Store,
  clu: Store,
  klg: Store,
  log: Store)

final case class FinalData(
  samplesExclude: Store,
  samplesExcludeGoogle: Option[Store],
  samplesRestore: Store,
  variantsExclude: Store,
  variantsExcludeIds: Store,
  variantsExcludeGoogle: Option[Store])

final case class VariantQcData(
  stats: Store,
  statsGoogle: Option[Store])

final case class CleanData(
  plink: Plink,
  hailLog: Store,
  hailLogGoogle: Option[Store],
  gds: Store,
  baseGoogle: Option[URI],
  vcf: Store,
  tbi: Store,
  vcfGoogle: Option[Store],
  mt: Option[Store],
  mtGoogle: Option[Store],
  pcaScores: Store,
  pcaLog: Store)

final case class Array(
  rawData: RawData,
  preparedData: Option[PreparedData],
  annotatedData: Option[AnnotatedData],
  annotatedChrData: Option[Map[String, AnnotatedChrData]],
  harmonizedData: Option[HarmonizedData],
  refData: RefData,
  imputeData: ImputeData,
  filteredData: FilteredData,
  prunedData: PrunedData,
  kinshipData: KinshipData,
  ref1kgData: Ref1kgData,
  ancestryData: AncestryData,
  ancestryPcaData: AncestryPcaData,
  ancestryClusterData: AncestryClusterData,
  pcaData: PcaData,
  sexcheckData: SexcheckData,
  sampleQcData: SampleQcData,
  sampleQcPcaClusterData: SampleQcPcaClusterData,
  sampleQcMetricClusterData: Map[String, SampleQcMetricClusterData],
  finalData: FinalData,
  variantQcData: VariantQcData,
  cleanData: CleanData)

val arrayStores = projectConfig.Arrays.map { arrayCfg =>

  val rawBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.raw"
  val preparedBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.prepared"
  val annotatedBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.prepared.annotated"
  val harmonizedBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.harmonized"
  val refBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.ref"
  val imputeBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.impute"
  val filteredBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.ref.filtered"
  val prunedBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.ref.filtered.pruned"
  val kinshipBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.kinship"
  val ref1kgBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.ref1kg"
  val ancestryBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.ancestry"
  val ancestryPcaBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.ancestry.pca"
  val ancestryClusterBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.ancestry.cluster"
  val pcaBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.pca"
  val sampleQcBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.sampleqc"
  val finalBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.final"
  val variantQcBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.variantqc"
  val cleanBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.clean"

  val baseName = arrayCfg.filename.split("/").last

  val plink = arrayCfg.technology match {

    case "gwas" =>

      arrayCfg.format match {
        case "plink" =>
          Some(Plink(
            base = path(arrayCfg.filename),
            data = Seq(store(path(checkPath(arrayCfg.filename + s".bed"))).asInput,store(path(checkPath(arrayCfg.filename + s".bim"))).asInput,store(path(checkPath(arrayCfg.filename + s".fam"))).asInput),
          ))
        case _ =>
          Some(Plink(
            base = localOutDir / rawBaseString,
            data = bedBimFam(path(checkPlinkPath(s"${localOutDir}" + s"/${rawBaseString}")))
          ))
      }

    case _ => None

  }

  val vcf = arrayCfg.format match {
    case "vcf" =>
      arrayCfg.technology match {
        case "gwas" =>
          Some(MultiPathVcf(
            base = MultiPath(local = Some(path(arrayCfg.filename.replaceAll(".vcf.gz$|.vcf.bgz$|.gz$|.bgz$",""))), google = None),
            data = MultiStore(local = Some(store(checkPath(arrayCfg.filename)).asInput), google = None),
            tbi = MultiStore(local = Some(store(checkPath(arrayCfg.filename + s".tbi")).asInput), google = None)))
        case _ =>
          Some(MultiPathVcf(
            base = MultiPath(local = Some(path(arrayCfg.filename.replaceAll(".vcf.gz$|.vcf.bgz$|.gz$|.bgz$",""))), google = hailCloud match { case true => Some(googleOutDir.get / baseName.replaceAll(".vcf.gz$|.vcf.bgz$|.gz$|.bgz$","")); case false => None }),
            data = MultiStore(local = Some(store(checkPath(arrayCfg.filename)).asInput), google = hailCloud match { case true => Some(store(googleOutDir.get / baseName)); case false => None }),
            tbi = MultiStore(local = Some(store(checkPath(arrayCfg.filename + s".tbi")).asInput), google = hailCloud match { case true => Some(store(googleOutDir.get / s"${baseName}.tbi")); case false => None })))
      }
    case _ => None
  }

  val rawData = RawData(
    plink = plink,
    vcf = vcf,
    unplaced = arrayCfg.technology match { case "gwas" => Some(store(localOutDir / s"${rawBaseString}.unplaced")); case _ => None },
    unique = arrayCfg.technology match { case "gwas" => Some(store(localOutDir / s"${rawBaseString}.unique")); case _ => None },
    indel = arrayCfg.technology match { case "gwas" => Some(store(localOutDir / s"${rawBaseString}.indel")); case _ => None },
    lmiss = arrayCfg.technology match { case "gwas" => Some(store(localOutDir / s"${rawBaseString}.missing.lmiss")); case _ => None },
    imiss = arrayCfg.technology match { case "gwas" => Some(store(localOutDir / s"${rawBaseString}.missing.imiss")); case _ => None },
    imissRemove = arrayCfg.technology match { case "gwas" => Some(store(localOutDir / s"${rawBaseString}.missing.imiss.remove")); case _ => None },
    freq = arrayCfg.technology match { case "gwas" => Some(store(localOutDir / s"${rawBaseString}.freq.frq")); case _ => None },
    mono = arrayCfg.technology match { case "gwas" => Some(store(localOutDir / s"${rawBaseString}.mono")); case _ => None },
    dupRemove = arrayCfg.technology match { case "gwas" => Some(store(localOutDir / s"${rawBaseString}.dup.remove")); case _ => None })

  val preparedData = arrayCfg.technology match {

    case "gwas" =>

      Some(PreparedData(
        plink = Plink(base = localOutDir / preparedBaseString, data = bedBimFam(localOutDir / preparedBaseString)),
        multiallelic = store(localOutDir / s"${preparedBaseString}.multiallelic"),
        chain = arrayCfg.liftOver.map(s => store(path(checkPath(s))).asInput),
        bed = arrayCfg.liftOver.map(s => store(localOutDir / s"${preparedBaseString}.liftover.bed")),
        lifted = arrayCfg.liftOver.map(s => store(localOutDir / s"${preparedBaseString}.lifted")),
        unlifted = arrayCfg.liftOver.map(s => store(localOutDir / s"${preparedBaseString}.unlifted")),
        liftedUpdate = arrayCfg.liftOver.map(s => store(localOutDir / s"${preparedBaseString}.lifted.update")),
        liftedExtract = arrayCfg.liftOver.map(s => store(localOutDir / s"${preparedBaseString}.lifted.extract"))))

    case _ => None

  }

  val annotatedData = arrayCfg.technology match {

    case "gwas" =>

      Some(AnnotatedData(
        plink = arrayCfg.liftOver match {
          case Some(s) => Plink(base = localOutDir / annotatedBaseString, data = bedBimFam(localOutDir / annotatedBaseString))
          case None => preparedData.get.plink
        }
      ))

    case _ => None

  }

  val chrSeq = (1 to 22).map(e => e.toString).toSeq ++ (if (arrayCfg.xChr) Seq("X") else Seq.empty) ++ (if (arrayCfg.yChr) Seq("Y") else Seq.empty) ++ (if (arrayCfg.mtChr) Seq("MT") else Seq.empty)

  val annotatedChrData = arrayCfg.technology match {

    case "gwas" =>

      Some(chrSeq.map { chr =>

        val chrBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.chr${chr}"
        
        val mergedKgBaseString = ! arrayCfg.skipGh.contains(chr) match {
          case true => s"${chrBaseString}.harmkg"
          case false => s"$chrBaseString"
        }

        val mergedKgHuRefBaseString = s"${mergedKgBaseString}.huref"
        val mergedKgNonKgBaseString = s"${mergedKgBaseString}.nonkg"
        
        chr -> AnnotatedChrData(
          plink = Plink(base = localOutDir / chrBaseString, data = bedBimFam(localOutDir / chrBaseString)),
          mergedKgPlink = Plink(base = localOutDir / mergedKgBaseString, data = bedBimFam(localOutDir / mergedKgBaseString)),
          mergedKgHuRefPlink = Plink(base = localOutDir / mergedKgHuRefBaseString, data = bedBimFam(localOutDir / mergedKgHuRefBaseString)),
          mergedKgNonKgBase = localOutDir / mergedKgNonKgBaseString,
          nonKgRemove = store(localOutDir / s"${mergedKgNonKgBaseString}.remove"),
          nonKgIgnore = store(localOutDir / s"${mergedKgNonKgBaseString}.ignore"),
          nonKgMono = store(localOutDir / s"${mergedKgNonKgBaseString}.mono"),
          nonKgNomatch = store(localOutDir / s"${mergedKgNonKgBaseString}.nomatch"),
          nonKgFlip = store(localOutDir / s"${mergedKgNonKgBaseString}.flip"),
          nonKgForceA1 = store(localOutDir / s"${mergedKgNonKgBaseString}.force_a1"),
          mergedKgVarIdUpdate = store(localOutDir / s"${mergedKgBaseString}_idUpdates.txt"),
          mergedKgVarSnpLog = store(localOutDir / s"${mergedKgBaseString}_snpLog.log"))

      }.toMap)

    case _ => None

  }

  val harmonizedData = arrayCfg.technology match {

    case "gwas" =>

      Some(HarmonizedData(
        plink = Plink(base = localOutDir / harmonizedBaseString, data = bedBimFam(localOutDir / harmonizedBaseString)),
        mergeList = store(localOutDir / s"${harmonizedBaseString}.merge.txt"),
        nonKgRemove = store(localOutDir / s"${harmonizedBaseString}.nonkg.remove"),
        nonKgIgnore = store(localOutDir / s"${harmonizedBaseString}.nonkg.ignore"),
        nonKgMono = store(localOutDir / s"${harmonizedBaseString}.nonkg.mono"),
        nonKgNomatch = store(localOutDir / s"${harmonizedBaseString}.nonkg.nomatch"),
        nonKgFlip = store(localOutDir / s"${harmonizedBaseString}.nonkg.flip"),
        nonKgForceA1 = store(localOutDir / s"${harmonizedBaseString}.nonkg.force_a1"),
        mergedKgVarIdUpdate = store(localOutDir / s"${harmonizedBaseString}_idUpdates.txt"),
        mergedKgVarSnpLog = store(localOutDir / s"${harmonizedBaseString}_snpLog.log"),
        forceA2 = store(localOutDir / s"${harmonizedBaseString}.force_a2.txt")))

    case _ => None

  }

  val refVcf = arrayCfg.technology match {
    case "gwas" =>
      MultiPathVcf(
      base = MultiPath(local = Some(localOutDir / refBaseString), google = hailCloud match { case true => Some(googleOutDir.get / refBaseString); case false => None }),
      data = MultiStore(local = Some(store(localOutDir / s"${refBaseString}.vcf.gz")), google = hailCloud match { case true => Some(store(googleOutDir.get / s"${refBaseString}.vcf.gz")); case false => None }),
      tbi = MultiStore(local = Some(store(localOutDir / s"${refBaseString}.vcf.gz.tbi")), google = hailCloud match { case true => Some(store(googleOutDir.get / s"${refBaseString}.vcf.gz.tbi")); case false => None }))
    case _ =>
      rawData.vcf.get
  }

  val refData = RefData(
    plink = arrayCfg.technology match { case "gwas" => Some(Plink(base = localOutDir / refBaseString, data = bedBimFam(localOutDir / refBaseString))); case _ => None },
    vcf = refVcf,
    mt = hailCloud match { case false => Some(store(localOutDir / s"${refBaseString}.mt")); case true => None },
    mtGoogle = hailCloud match { case true => Some(store(googleOutDir.get / s"${refBaseString}.mt")); case false => None },
    hailLog = store(localOutDir / s"${refBaseString}.hail.log"),
    hailLogGoogle = hailCloud match { case true => Some(store(googleOutDir.get / s"${refBaseString}.hail.log")); case false => None },
    variantMetrics = store(localOutDir / s"${refBaseString}.variant.metrics.tsv.bgz"),
    variantMetricsGoogle = hailCloud match { case true => Some(store(googleOutDir.get / s"${refBaseString}.variant.metrics.tsv.bgz")); case false => None },
    sitesVcf = store(localOutDir / s"${refBaseString}.sites_only.vcf.bgz"),
    sitesVcfGoogle = hailCloud match { case true => Some(store(googleOutDir.get / s"${refBaseString}.sites_only.vcf.bgz")); case false => None },
    annotations = store(localOutDir / s"${refBaseString}.annotations.bgz"),
    annotationWarnings = store(localOutDir / s"${refBaseString}.annotations.warnings"))

  val imputeData = ImputeData(
    data = bedBimFam(localOutDir / imputeBaseString),
    base = localOutDir / imputeBaseString)

  val filteredData = FilteredData(
    variantMetrics = store(localOutDir / s"${filteredBaseString}.variant.metrics.tsv.bgz"),
    variantMetricsGoogle = hailCloud match { case true => Some(store(googleOutDir.get / s"${filteredBaseString}.variant.metrics.tsv.bgz")); case false => None },
    plink = MultiPathPlink(base = MultiPath(local = Some(localOutDir / filteredBaseString), google = hailCloud match { case true => Some(googleOutDir.get / filteredBaseString); case false => None }), data = MultiSeqStore(local = Some(bedBimFam(localOutDir / filteredBaseString)), google = hailCloud match { case true => Some(bedBimFam(googleOutDir.get / filteredBaseString)); case false => None })),
    hailLog = store(localOutDir / s"${filteredBaseString}.hail.log"),
    hailLogGoogle = hailCloud match { case true => Some(store(googleOutDir.get / s"${filteredBaseString}.hail.log")); case false => None },
    pruneIn = store(localOutDir / s"${filteredBaseString}.prune.in"))

  val prunedData = PrunedData(
    plink = Plink(base = localOutDir / prunedBaseString, data = bedBimFam(localOutDir / prunedBaseString)))

  val kinshipData = KinshipData(
    base = localOutDir / kinshipBaseString,
    log = store(localOutDir / s"${kinshipBaseString}.log"),
    kin = store(localOutDir / s"${kinshipBaseString}.kin"),
    kin0 = store(localOutDir / s"${kinshipBaseString}.kin0"),
    kin0Related = store(localOutDir / s"${kinshipBaseString}.kin0.related"),
    famSizes = store(localOutDir / s"${kinshipBaseString}.famsizes.tsv"))

  val ref1kgData = Ref1kgData(
    plink = MultiPathPlink(base = MultiPath(local = Some(localOutDir / ref1kgBaseString), google = hailCloud match { case true => Some(googleOutDir.get / ref1kgBaseString); case false => None }), data = MultiSeqStore(local = Some(bedBimFam(localOutDir / ref1kgBaseString)), google = hailCloud match { case true => Some(bedBimFam(googleOutDir.get / ref1kgBaseString)); case false => None })),
    hailLog = store(localOutDir / s"${ref1kgBaseString}.hail.log"),
    hailLogGoogle = hailCloud match { case true => Some(store(googleOutDir.get / s"${ref1kgBaseString}.hail.log")); case false => None },
    kgSamples = store(localOutDir / s"${ref1kgBaseString}.kgsamples.tsv"),
    kgSamplesGoogle = hailCloud match { case true => Some(store(googleOutDir.get / s"${ref1kgBaseString}.kgsamples.tsv")); case false => None },
    gds = store(localOutDir / s"${ref1kgBaseString}.gds"))

  val ancestryData = AncestryData(
    inferred = store(localOutDir / s"${ancestryBaseString}.inferred.tsv"))

  val ancestryPcaData = AncestryPcaData(
    base = localOutDir / ancestryPcaBaseString,
    log = store(localOutDir / s"${ancestryPcaBaseString}.log"),
    scores = store(localOutDir / s"${ancestryPcaBaseString}.scores.tsv"),
    plots = store(localOutDir / s"${ancestryPcaBaseString}.plots.pdf"))
  
  val ancestryClusterData = AncestryClusterData(
    base = localOutDir / ancestryClusterBaseString,
    log = store(localOutDir / s"${ancestryClusterBaseString}.log"),
    fet = store(localOutDir / s"${ancestryClusterBaseString}.fet.1"),
    clu = store(localOutDir / s"${ancestryClusterBaseString}.clu.1"),
    klg = store(localOutDir / s"${ancestryClusterBaseString}.klg.1"),
    plots = store(localOutDir / s"${ancestryClusterBaseString}.plots.pdf"),
    centerPlots = store(localOutDir / s"${ancestryClusterBaseString}.plots.centers.pdf"),
    no1kgPlots = store(localOutDir / s"${ancestryClusterBaseString}.plots.no1kg.pdf"),
    xtab = store(localOutDir / s"${ancestryClusterBaseString}.xtab"),
    groups = store(localOutDir / s"${ancestryClusterBaseString}.groups.tsv"))

  val pcaData = PcaData(
    gds = store(localOutDir / s"${pcaBaseString}.gds"),
    log = store(localOutDir / s"${pcaBaseString}.log"),
    scores = store(localOutDir / s"${pcaBaseString}.scores.tsv"))

  val sexcheckData = SexcheckData(
    sexcheck = store(localOutDir / s"${sampleQcBaseString}.sexcheck.tsv"),
    sexcheckGoogle = hailCloud match { case true => Some(store(googleOutDir.get / s"${sampleQcBaseString}.sexcheck.tsv")); case false => None },
    problems = store(localOutDir / s"${sampleQcBaseString}.sexcheck.problems.tsv"),
    problemsGoogle = hailCloud match { case true => Some(store(googleOutDir.get / s"${sampleQcBaseString}.sexcheck.problems.tsv")); case false => None },
    hailLog = store(localOutDir / s"${sampleQcBaseString}.sexcheck.hail.log"),
    hailLogGoogle = hailCloud match { case true => Some(store(googleOutDir.get / s"${sampleQcBaseString}.sexcheck.hail.log")); case false => None })

  val sampleQcData = SampleQcData(
    stats = store(localOutDir / s"${sampleQcBaseString}.stats.tsv"),
    statsGoogle = hailCloud match { case true => Some(store(googleOutDir.get / s"${sampleQcBaseString}.stats.tsv")); case false => None },
    hailLog = store(localOutDir / s"${sampleQcBaseString}.stats.hail.log"),
    hailLogGoogle = hailCloud match { case true => Some(store(googleOutDir.get / s"${sampleQcBaseString}.stats.hail.log")); case false => None },
    statsAdj = store(localOutDir / s"${sampleQcBaseString}.stats.adj.tsv"),
    corrPlots = store(localOutDir / s"${sampleQcBaseString}.corr.pdf"),
    boxPlots = store(localOutDir / s"${sampleQcBaseString}.boxplots.pdf"),
    discreteness = store(localOutDir / s"${sampleQcBaseString}.discreteness.txt"),
    pcaLoadings = store(localOutDir / s"${sampleQcBaseString}.pca.loadings.tsv"),
    pcaPlots = store(localOutDir / s"${sampleQcBaseString}.pca.plots.pdf"),
    pcaScores = store(localOutDir / s"${sampleQcBaseString}.pca.scores.tsv"),
    outliers = store(localOutDir / s"${sampleQcBaseString}.outliers.tsv"),
    metricPlots = store(localOutDir / s"${sampleQcBaseString}.metricplots.pdf"))

  val sampleQcPcaClusterData = SampleQcPcaClusterData(
    base = localOutDir / s"${sampleQcBaseString}.pca.cluster",
    fet = store(localOutDir / s"${sampleQcBaseString}.pca.cluster.fet.1"),
    clu = store(localOutDir / s"${sampleQcBaseString}.pca.cluster.clu.1"),
    klg = store(localOutDir / s"${sampleQcBaseString}.pca.cluster.klg.1"),
    log = store(localOutDir / s"${sampleQcBaseString}.pca.cluster.log"),
    outliers = store(localOutDir / s"${sampleQcBaseString}.pca.cluster.outliers.tsv"),
    plots = store(localOutDir / s"${sampleQcBaseString}.pca.cluster.plots.pdf"),
    xtab = store(localOutDir / s"${sampleQcBaseString}.pca.cluster.xtab"))

  val sampleQcMetricClusterData = projectConfig.sampleQcMetrics.map { metric =>
  
      metric -> SampleQcMetricClusterData(
        base = localOutDir / s"${sampleQcBaseString}.${metric}.cluster",
        fet = store(localOutDir / s"${sampleQcBaseString}.${metric}.cluster.fet.1"),
        clu = store(localOutDir / s"${sampleQcBaseString}.${metric}.cluster.clu.1"),
        klg = store(localOutDir / s"${sampleQcBaseString}.${metric}.cluster.klg.1"),
        log = store(localOutDir / s"${sampleQcBaseString}.${metric}.cluster.log"))

  }.toMap

  val finalData = FinalData(
    samplesExclude = store(localOutDir / s"${finalBaseString}.samples.exclude.txt"),
    samplesExcludeGoogle = hailCloud match { case true => Some(store(googleOutDir.get / s"${finalBaseString}.samples.exclude.txt")); case false => None },
	samplesRestore = store(localOutDir / s"${finalBaseString}.samples.restore.tbl"),
    variantsExclude = store(localOutDir / s"${finalBaseString}.variants.exclude.txt"),
    variantsExcludeIds = store(localOutDir / s"${finalBaseString}.variants.exclude.ids.txt"),
    variantsExcludeGoogle = hailCloud match { case true => Some(store(googleOutDir.get / s"${finalBaseString}.variants.exclude.txt")); case false => None })

  val variantQcData = VariantQcData(
    stats = store(localOutDir / s"${variantQcBaseString}.stats.tsv"),
    statsGoogle = hailCloud match { case true => Some(store(googleOutDir.get / s"${variantQcBaseString}.stats.tsv")); case false => None })

  val cleanData = CleanData(
    plink = Plink(base = localOutDir / cleanBaseString, data = bedBimFam(localOutDir / cleanBaseString)),
    hailLog = store(localOutDir / s"${cleanBaseString}.hail.log"),
    hailLogGoogle = hailCloud match { case true => Some(store(googleOutDir.get / s"${cleanBaseString}.hail.log")); case false => None },
    gds = store(localOutDir / s"${cleanBaseString}.gds"),
    baseGoogle = hailCloud match { case true => Some(googleOutDir.get / cleanBaseString); case false => None },
    vcf = store(localOutDir / s"${cleanBaseString}.vcf.bgz"),
    tbi = store(localOutDir / s"${cleanBaseString}.vcf.bgz.tbi"),
    vcfGoogle = hailCloud match { case true => Some(store(googleOutDir.get / s"${cleanBaseString}.vcf.bgz")); case false => None },
    mt = hailCloud match { case false => Some(store(localOutDir / s"${cleanBaseString}.mt")); case true => None },
    mtGoogle = hailCloud match { case true => Some(store(googleOutDir.get / s"${cleanBaseString}.mt")); case false => None },
    pcaScores = store(localOutDir / s"${cleanBaseString}.pca.scores.tsv"),
    pcaLog = store(localOutDir / s"${cleanBaseString}.pca.log"))

  arrayCfg -> Array(
    rawData = rawData,
    preparedData = preparedData,
    annotatedData = annotatedData,
    annotatedChrData = annotatedChrData,
    harmonizedData = harmonizedData,
    refData = refData,
    imputeData = imputeData,
    filteredData = filteredData,
    prunedData = prunedData,
    kinshipData = kinshipData,
    ref1kgData = ref1kgData,
    ancestryData = ancestryData,
    ancestryPcaData = ancestryPcaData,
    ancestryClusterData = ancestryClusterData,
    pcaData = pcaData,
    sexcheckData = sexcheckData,
    sampleQcData = sampleQcData,
    sampleQcPcaClusterData = sampleQcPcaClusterData,
    sampleQcMetricClusterData = sampleQcMetricClusterData,
    finalData = finalData,
    variantQcData = variantQcData,
    cleanData = cleanData)

}.toMap
