import ProjectConfig._
import PipelineConfig._
import Stores._

final case class RawData(
  data: GenotypeData,
  unplaced: Option[Store],
  unique: Store,
  indel: Store,
  lmiss: Store,
  imiss: Store,
  imissRemove: Store,
  freq: Store,
  mono: Store,
  dupRemove: Store)

final case class PreparedData(
  data: Seq[Store],
  multiallelic: Store,
  chain: Option[Store] = None,
  bed: Option[Store] = None,
  lifted: Option[Store] = None,
  unlifted: Option[Store] = None,
  liftedUpdate: Option[Store] = None,
  liftedExtract: Option[Store] = None)

final case class AnnotatedData(
  data: Seq[Store])

final case class AnnotatedChrData(
  data: Seq[Store],
  mergedKgBase: Path,
  mergedKg: Seq[Store],
  mergedKgHuRefBase: Path,
  mergedKgHuRef: Seq[Store],
  mergedKgNonKgBase: Path,
  nonKgRemove: Store,
  nonKgIgnore: Store,
  nonKgMono: Store,
  nonKgNomatch: Store,
  nonKgFlip: Store,
  nonKgForceA1: Store,
  mergedKgVarIdUpdate: Store,
  mergedKgVarSnpLog: Store)

final case class HarmonizedData(
  data: GenotypeData,
  hailLog: MultiStore,
  mergeList: Store,
  nonKgRemove: Store,
  nonKgIgnore: Store,
  nonKgMono: Store,
  nonKgNomatch: Store,
  nonKgFlip: Store,
  nonKgForceA1: Store,
  mergedKgVarIdUpdate: Store,
  mergedKgVarSnpLog: Store,
  forceA2: Store,
  refData: GenotypeData,
  vcf: GenotypeData,
  tbi: MultiStore,
  imputeData: GenotypeData,
  mt: MultiStore,
  pruneIn: Store,
  regionsExcludePlink: Store)

final case class PrunedData(
  data: GenotypeData,
  vcf: GenotypeData,
  tbi: MultiStore)

final case class KinshipData(
  base: Path,
  log: Store,
  kin: Store,
  kin0: Store,
  kin0Related: Store,
  famSizes: Store)

final case class Ref1kgData(
  vcf: GenotypeData,
  data: GenotypeData,
  base: MultiStrPath,
  hailLog: MultiStore,
  kgSamples: MultiStore,
  gds: Store)

final case class AncestryData(
  inferred: Store)

final case class AncestryPcaData(
  base: Path,
  log: Store,
  scores: Store,
  plots: Store)

final case class AncestryClusterData(
  base: Path,
  log: Store,
  fet: Store,
  clu: Store,
  klg: Store,
  plots: Store,
  centerPlots: Store,
  no1kgPlots: Store,
  xtab: Store,
  groups: Store)

final case class PcaData(
  gds: Store,
  log: Store,
  scores: Store)

final case class SexcheckData(
  sexcheck: MultiStore,
  problems: MultiStore,
  hailLog: MultiStore)

final case class SampleQcData(
  stats: MultiStore,
  hailLog: MultiStore,
  statsAdj: Store,
  corrPlots: Store,
  boxPlots: Store,
  discreteness: Store,
  pcaLoadings: Store,
  pcaPlots: Store,
  pcaScores: Store,
  outliers: Store,
  metricPlots: Store)

final case class SampleQcPcaClusterData(
  base: Path,
  fet: Store,
  clu: Store,
  klg: Store,
  log: Store,
  outliers: Store,
  plots: Store,
  xtab: Store)

final case class SampleQcMetricClusterData(
  base: Path,
  fet: Store,
  clu: Store,
  klg: Store,
  log: Store)

final case class FinalData(
  samplesExclude: MultiStore,
  samplesRestore: Store,
  variantsExclude: MultiStore,
  variantsExcludeIds: Store)

final case class VariantQcData(
  stats: MultiStore)

final case class CleanData(
  data: GenotypeData,
  base: MultiStrPath,
  hailLog: MultiStore,
  gds: Store,
  vcf: GenotypeData,
  tbi: Store,
  mt: MultiStore,
  pcaScores: Store,
  pcaLog: Store)

final case class Array(
  rawData: RawData,
  preparedData: PreparedData,
  annotatedData: AnnotatedData,
  annotatedChrData: Map[String, AnnotatedChrData],
  harmonizedData: HarmonizedData,
  prunedData: PrunedData,
  kinshipData: KinshipData,
  ref1kgData: Ref1kgData,
  ancestryData: AncestryData,
  ancestryPcaData: AncestryPcaData,
  ancestryClusterData: AncestryClusterData,
  pcaData: PcaData,
  sexcheckData: SexcheckData,
  sampleQcData: SampleQcData,
  sampleQcPcaClusterData: SampleQcPcaClusterData,
  sampleQcMetricClusterData: Map[String, SampleQcMetricClusterData],
  finalData: FinalData,
  variantQcData: VariantQcData,
  cleanData: CleanData)

val arrayStores = cfg.Arrays.map(a => a.id).map { array =>

  val cfgArray = cfg.Arrays.filter(_.id == array).head

  val rawBaseString = s"${cfg.projectId}.${cfgArray.id}.raw"
  val preparedBaseString = s"${cfg.projectId}.${cfgArray.id}.prepared"
  val annotatedBaseString = s"${cfg.projectId}.${cfgArray.id}.prepared.annotated"
  val harmonizedBaseString = s"${cfg.projectId}.${cfgArray.id}.harmonized"
  val refBaseString = s"${cfg.projectId}.${cfgArray.id}.ref"
  val imputeBaseString = s"${cfg.projectId}.${cfgArray.id}.impute"
  val qcBaseString = s"${cfg.projectId}.${cfgArray.id}.ref.qc"
  val kinshipBaseString = s"${cfg.projectId}.${cfgArray.id}.kinship"
  val ref1kgBaseString = s"${cfg.projectId}.${cfgArray.id}.ref1kg"
  val ancestryBaseString = s"${cfg.projectId}.${cfgArray.id}.ancestry"
  val ancestryPcaBaseString = s"${cfg.projectId}.${cfgArray.id}.ancestry.pca"
  val ancestryClusterBaseString = s"${cfg.projectId}.${cfgArray.id}.ancestry.cluster"
  val pcaBaseString = s"${cfg.projectId}.${cfgArray.id}.pca"
  val sampleQcBaseString = s"${cfg.projectId}.${cfgArray.id}.sampleqc"
  val finalBaseString = s"${cfg.projectId}.${cfgArray.id}.final"
  val variantQcBaseString = s"${cfg.projectId}.${cfgArray.id}.variantqc"
  val cleanBaseString = s"${cfg.projectId}.${cfgArray.id}.clean"

  val data = {
    cfgArray.format match {
      case "plink" =>
        Plink(
          base = MultiStrPath(local = Some(cfgArray.file), google = None),
          bed = MultiStore(local = Some(store(checkPath(cfgArray.file + ".bed")).asInput), google = None),
          bim = MultiStore(local = Some(store(checkPath(cfgArray.file + ".bim")).asInput), google = None),
          fam = MultiStore(local = Some(store(checkPath(cfgArray.file + ".fam")).asInput), google = None)
        )
      case "vcf" =>
        Vcf(
          base = MultiStrPath(local = Some(cfgArray.file.replaceAll(".vcf.gz$","").replaceAll(".vcf.bgz$","").replaceAll(".gz$","").replaceAll(".bgz$","")), google = None),
          vcf = MultiStore(local = Some(store(checkPath(cfgArray.file)).asInput), google = None)
        )
    }
  }

  val rawData = RawData(
    data = data,
    unplaced = data match {
      case _: Plink => store(dirTree.dataArrayMap(cfgArray).prepare.local.get / s"${rawBaseString}.unplaced")
      case _: Vcf => None
    },
    unique = store(dirTree.dataArrayMap(cfgArray).prepare.local.get / s"${rawBaseString}.unique"),
    indel = store(dirTree.dataArrayMap(cfgArray).prepare.local.get / s"${rawBaseString}.indel"),
    lmiss = store(dirTree.dataArrayMap(cfgArray).prepare.local.get / s"${rawBaseString}.missing.lmiss"),
    imiss = store(dirTree.dataArrayMap(cfgArray).prepare.local.get / s"${rawBaseString}.missing.imiss"),
    imissRemove = store(dirTree.dataArrayMap(cfgArray).prepare.local.get / s"${rawBaseString}.missing.imiss.remove"),
    freq = store(dirTree.dataArrayMap(cfgArray).prepare.local.get / s"${rawBaseString}.freq.frq"),
    mono = store(dirTree.dataArrayMap(cfgArray).prepare.local.get / s"${rawBaseString}.mono"),
    dupRemove = store(dirTree.dataArrayMap(cfgArray).prepare.local.get / s"${rawBaseString}.dup.remove"))

  val preparedData = PreparedData(
    data = Plink(
      base = MultiStrPath(local = Some(dirTree.dataArrayMap(cfgArray).prepare.local.get / preparedBaseString), google = None),
      bed = MultiStore(local = Some(store(dirTree.dataArrayMap(cfgArray).prepare.local.get / s"${preparedBaseString}.bed").asInput), google = None),
      bim = MultiStore(local = Some(store(dirTree.dataArrayMap(cfgArray).prepare.local.get / s"${preparedBaseString}.bim").asInput), google = None),
      fam = MultiStore(local = Some(store(dirTree.dataArrayMap(cfgArray).prepare.local.get / s"${preparedBaseString}.fam").asInput), google = None)
    ),
    multiallelic = store(dirTree.dataArrayMap(cfgArray).prepare.local.get / s"${preparedBaseString}.multiallelic"),
    chain = cfgArray.liftOver.map(s => store(path(s)).asInput),
    bed = cfgArray.liftOver.map(s => store(dirTree.dataArrayMap(cfgArray).prepare.local.get / s"${preparedBaseString}.liftover.bed")),
    lifted = cfgArray.liftOver.map(s => store(dirTree.dataArrayMap(cfgArray).prepare.local.get / s"${preparedBaseString}.lifted")),
    unlifted = cfgArray.liftOver.map(s => store(dirTree.dataArrayMap(cfgArray).prepare.local.get / s"${preparedBaseString}.unlifted")),
    liftedUpdate = cfgArray.liftOver.map(s => store(dirTree.dataArrayMap(cfgArray).prepare.local.get / s"${preparedBaseString}.lifted.update")),
    liftedExtract = cfgArray.liftOver.map(s => store(dirTree.dataArrayMap(cfgArray).prepare.local.get / s"${preparedBaseString}.lifted.extract")))

  val annotatedData = AnnotatedData(
    data = cfgArray.liftOver match {
      case Some(s) => 
        Plink(
          base = MultiStrPath(local = Some(dirTree.dataArrayMap(cfgArray).prepare.local.get / annotatedBaseString), google = None),
          bed = MultiStore(local = Some(store(dirTree.dataArrayMap(cfgArray).prepare.local.get / s"${annotatedBaseString}.bed").asInput), google = None),
          bim = MultiStore(local = Some(store(dirTree.dataArrayMap(cfgArray).prepare.local.get / s"${annotatedBaseString}.bim").asInput), google = None),
          fam = MultiStore(local = Some(store(dirTree.dataArrayMap(cfgArray).prepare.local.get / s"${annotatedBaseString}.fam").asInput), google = None)
        )
      case None => preparedData.data 
    }
  )

  val annotatedChrData = expandChrList(cfgArray.chrs).map { chr =>

    val chrBaseString = s"${cfg.projectId}.${cfgArray.id}.chr${chr}"

    val mergedKgBaseString = s"${chrBaseString}.harmkg"
    val mergedKgHuRefBaseString = s"${mergedKgBaseString}.huref"
    val mergedKgNonKgBaseString = s"${mergedKgBaseString}.nonkg"

    chr -> AnnotatedChrData(
      data = Plink(
        base = MultiStrPath(local = Some(dirTree.dataArrayMap(cfgArray).harmonize.local.get / chrBaseString), google = None),
        bed = MultiStore(local = Some(store(dirTree.dataArrayMap(cfgArray).harmonize.local.get / s"${chrBaseString}.bed").asInput), google = None),
        bim = MultiStore(local = Some(store(dirTree.dataArrayMap(cfgArray).harmonize.local.get / s"${chrBaseString}.bim").asInput), google = None),
        fam = MultiStore(local = Some(store(dirTree.dataArrayMap(cfgArray).harmonize.local.get / s"${chrBaseString}.fam").asInput), google = None)
      ),
      mergedKgBase = dirTree.dataArrayMap(cfgArray).harmonize.local.get / mergedKgBaseString,
      mergedKg = bedBimFam(dirTree.dataArrayMap(cfgArray).harmonize.local.get / mergedKgBaseString),
      mergedKgHuRefBase = dirTree.dataArrayMap(cfgArray).harmonize.local.get / mergedKgHuRefBaseString,
      mergedKgHuRef = bedBimFam(dirTree.dataArrayMap(cfgArray).harmonize.local.get / mergedKgHuRefBaseString),
      mergedKgNonKgBase = dirTree.dataArrayMap(cfgArray).harmonize.local.get / mergedKgNonKgBaseString,
      nonKgRemove = store(dirTree.dataArrayMap(cfgArray).harmonize.local.get / s"${mergedKgNonKgBaseString}.remove"),
      nonKgIgnore = store(dirTree.dataArrayMap(cfgArray).harmonize.local.get / s"${mergedKgNonKgBaseString}.ignore"),
      nonKgMono = store(dirTree.dataArrayMap(cfgArray).harmonize.local.get / s"${mergedKgNonKgBaseString}.mono"),
      nonKgNomatch = store(dirTree.dataArrayMap(cfgArray).harmonize.local.get / s"${mergedKgNonKgBaseString}.nomatch"),
      nonKgFlip = store(dirTree.dataArrayMap(cfgArray).harmonize.local.get / s"${mergedKgNonKgBaseString}.flip"),
      nonKgForceA1 = store(dirTree.dataArrayMap(cfgArray).harmonize.local.get / s"${mergedKgNonKgBaseString}.force_a1"),
      mergedKgVarIdUpdate = store(dirTree.dataArrayMap(cfgArray).harmonize.local.get / s"${mergedKgBaseString}_idUpdates.txt"),
      mergedKgVarSnpLog = store(dirTree.dataArrayMap(cfgArray).harmonize.local.get / s"${mergedKgBaseString}_snpLog.log"))

  }.toMap

  val harmonizedData = HarmonizedData(
    data = Plink(
      base = MultiStrPath(local = Some(dirTree.dataArrayMap(cfgArray).harmonize.local.get / harmonizedBaseString), google = None),
      bed = MultiStore(local = Some(store(dirTree.dataArrayMap(cfgArray).harmonize.local.get / s"${harmonizedBaseString}.bed").asInput), google = None),
      bim = MultiStore(local = Some(store(dirTree.dataArrayMap(cfgArray).harmonize.local.get / s"${harmonizedBaseString}.bim").asInput), google = None),
      fam = MultiStore(local = Some(store(dirTree.dataArrayMap(cfgArray).harmonize.local.get / s"${harmonizedBaseString}.fam").asInput), google = None)
    ),
    hailLog = MultiStore(
      local = Some(store(dirTree.dataArrayMap(cfgArray).harmonize.local.get / s"${harmonizedBaseString}.hail.log")),
      google = hailCloud match { case true => Some(store(dirTree.dataArrayMap(cfgArray).harmonize.google.get / s"${harmonizedBaseString}.hail.log")); case false => None }
    ),
    mergeList = store(dirTree.dataArrayMap(cfgArray).harmonize.local.get / s"${harmonizedBaseString}.merge.txt"),
    nonKgRemove = store(dirTree.dataArrayMap(cfgArray).harmonize.local.get / s"${harmonizedBaseString}.nonkg.remove"),
    nonKgIgnore = store(dirTree.dataArrayMap(cfgArray).harmonize.local.get / s"${harmonizedBaseString}.nonkg.ignore"),
    nonKgMono = store(dirTree.dataArrayMap(cfgArray).harmonize.local.get / s"${harmonizedBaseString}.nonkg.mono"),
    nonKgNomatch = store(dirTree.dataArrayMap(cfgArray).harmonize.local.get / s"${harmonizedBaseString}.nonkg.nomatch"),
    nonKgFlip = store(dirTree.dataArrayMap(cfgArray).harmonize.local.get / s"${harmonizedBaseString}.nonkg.flip"),
    nonKgForceA1 = store(dirTree.dataArrayMap(cfgArray).harmonize.local.get / s"${harmonizedBaseString}.nonkg.force_a1"),
    mergedKgVarIdUpdate = store(dirTree.dataArrayMap(cfgArray).harmonize.local.get / s"${harmonizedBaseString}_idUpdates.txt"),
    mergedKgVarSnpLog = store(dirTree.dataArrayMap(cfgArray).harmonize.local.get / s"${harmonizedBaseString}_snpLog.log"),
    forceA2 = store(dirTree.dataArrayMap(cfgArray).harmonize.local.get / s"${refBaseString}.force_a2.txt"),
    refData = Plink(
      base = MultiStrPath(local = Some(dirTree.dataArrayMap(cfgArray).harmonize.local.get / refBaseString), google = None),
      bed = MultiStore(local = Some(store(dirTree.dataArrayMap(cfgArray).harmonize.local.get / s"${refBaseString}.bed").asInput), google = None),
      bim = MultiStore(local = Some(store(dirTree.dataArrayMap(cfgArray).harmonize.local.get / s"${refBaseString}.bim").asInput), google = None),
      fam = MultiStore(local = Some(store(dirTree.dataArrayMap(cfgArray).harmonize.local.get / s"${refBaseString}.fam").asInput), google = None)
    ),
    vcf = Vcf(
      base = MultiStrPath(
        local = Some(dirTree.dataArrayMap(cfgArray).harmonize.local.get / s"${refBaseString}.vcf.gz"),
        google = hailCloud match { case true => Some(dirTree.dataArrayMap(cfgArray).harmonize.google.get / s"${refBaseString}.vcf.gz"); case false => None }
      ),
      vcf = MultiStore(
        local = Some(store(dirTree.dataArrayMap(cfgArray).harmonize.local.get / s"${refBaseString}.vcf.gz")),
        google = hailCloud match { case true => Some(store(dirTree.dataArrayMap(cfgArray).harmonize.google.get / s"${refBaseString}.vcf.gz")); case false => None }
      )
    ),
    tbi = MultiStore(
      local = Some(store(dirTree.dataArrayMap(cfgArray).harmonize.local.get / s"${refBaseString}.vcf.gz.tbi")),
      google = hailCloud match { case true => Some(store(dirTree.dataArrayMap(cfgArray).harmonize.google.get / s"${refBaseString}.vcf.gz.tbi")); case false => None }
    ),
    imputeData = Plink(
      base = MultiStrPath(local = Some(dirTree.dataArrayMap(cfgArray).impute.local.get / imputeBaseString), google = None),
      bed = MultiStore(local = Some(store(dirTree.dataArrayMap(cfgArray).impute.local.get / s"${imputeBaseString}.bed").asInput), google = None),
      bim = MultiStore(local = Some(store(dirTree.dataArrayMap(cfgArray).impute.local.get / s"${imputeBaseString}.bim").asInput), google = None),
      fam = MultiStore(local = Some(store(dirTree.dataArrayMap(cfgArray).impute.local.get / s"${imputeBaseString}.fam").asInput), google = None)
    ),
    mt = MultiStore(
      local = hailCloud match { case false => Some(store(dirTree.dataArrayMap(cfgArray).harmonize.local.get / s"${refBaseString}.mt")); case true => None },
      google = hailCloud match { case true => Some(store(dirTree.dataArrayMap(cfgArray).harmonize.google.get / s"${refBaseString}.mt")); case false => None }
    ),
    pruneIn = store(dirTree.dataArrayMap(cfgArray).filterforqc.local.get / s"${refBaseString}.prune.in"),
    regionsExcludePlink = store(dirTree.dataArrayMap(cfgArray).filterforqc.local.get / s"${refBaseString}.regions_exclude.txt"))

  val prunedData = PrunedData(
    data = Plink(
      base = MultiStrPath(local = Some(dirTree.dataArrayMap(cfgArray).filterforqc.local.get / qcBaseString), google = None),
      bed = MultiStore(local = Some(store(dirTree.dataArrayMap(cfgArray).filterforqc.local.get / s"${qcBaseString}.bed").asInput), google = None),
      bim = MultiStore(
        local = Some(store(dirTree.dataArrayMap(cfgArray).filterforqc.local.get / s"${qcBaseString}.bim").asInput),
        google = hailCloud match { case true => Some(store(dirTree.dataArrayMap(cfgArray).filterforqc.google.get / s"${qcBaseString}.bim")); case false => None }
      ),
      fam = MultiStore(local = Some(store(dirTree.dataArrayMap(cfgArray).filterforqc.local.get / s"${qcBaseString}.fam").asInput), google = None)
    ),
    vcf = Vcf(
      base = MultiStrPath(
        local = Some(dirTree.dataArrayMap(cfgArray).filterforqc.local.get / s"${qcBaseString}.vcf.gz"),
        google = None }
      ),
      vcf = MultiStore(
        local = Some(store(dirTree.dataArrayMap(cfgArray).filterforqc.local.get / s"${qcBaseString}.vcf.gz")),
        google = None }
      )
    ),
    tbi = MultiStore(
      local = Some(dirTree.dataArrayMap(cfgArray).filterforqc.local.get / s"${qcBaseString}.vcf.gz.tbi"),
      google = None
    ))

  val kinshipData = KinshipData(
    base = dirTree.dataArrayMap(cfgArray).kinship.local.get / kinshipBaseString,
    log = store(dirTree.dataArrayMap(cfgArray).kinship.local.get / s"${kinshipBaseString}.log"),
    kin = store(dirTree.dataArrayMap(cfgArray).kinship.local.get / s"${kinshipBaseString}.kin"),
    kin0 = store(dirTree.dataArrayMap(cfgArray).kinship.local.get / s"${kinshipBaseString}.kin0"),
    kin0Related = store(dirTree.dataArrayMap(cfgArray).kinship.local.get / s"${kinshipBaseString}.kin0.related"),
    famSizes = store(dirTree.dataArrayMap(cfgArray).kinship.local.get / s"${kinshipBaseString}.famsizes.tsv"))

  val ref1kgData = Ref1kgData(
    vcf = Vcf(
      base = MultiStrPath(
        local = Some(dirTree.dataArrayMap(cfgArray).ancestry.local.get / ref1kgBaseString),
        google = hailCloud match { case true => Some(dirTree.dataArrayMap(cfgArray).ancestry.google.get / ref1kgBaseString); case false => None }
      ),
      vcf = MultiStore(
        local = Some(store(dirTree.dataArrayMap(cfgArray).ancestry.local.get / s"${ref1kgBaseString}.vcf.bgz")),
        google = hailCloud match { case true => Some(store(dirTree.dataArrayMap(cfgArray).ancestry.google.get / s"${ref1kgBaseString}.vcf.bgz")); case false => None }
      )
    ),
    data = Plink(
      base = MultiStrPath(local = Some(dirTree.dataArrayMap(cfgArray).ancestry.local.get / ref1kgBaseString), google = None),
      bed = MultiStore(local = Some(store(dirTree.dataArrayMap(cfgArray).ancestry.local.get / s"${ref1kgBaseString}.bed").asInput), google = None),
      bim = MultiStore(local = Some(store(dirTree.dataArrayMap(cfgArray).ancestry.local.get / s"${ref1kgBaseString}.bim").asInput), google = None),
      fam = MultiStore(local = Some(store(dirTree.dataArrayMap(cfgArray).ancestry.local.get / s"${ref1kgBaseString}.fam").asInput), google = None)
    ),
    base = MultiStrPath(
      local = Some(dirTree.dataArrayMap(cfgArray).ancestry.local.get / ref1kgBaseString),
      google = hailCloud match { case true => Some(dirTree.dataArrayMap(cfgArray).ancestry.google.get / ref1kgBaseString); case false => None }
    ),
    hailLog = MultiStore(
      local = Some(store(dirTree.dataArrayMap(cfgArray).ancestry.local.get / s"${ref1kgBaseString}.hail.log")),
      google = hailCloud match { case true => Some(store(dirTree.dataArrayMap(cfgArray).ancestry.google.get / s"${ref1kgBaseString}.hail.log")); case false => None }
    ),
    kgSamples = MultiStore(
      local = Some(store(dirTree.dataArrayMap(cfgArray).ancestry.local.get / s"${ref1kgBaseString}.kgsamples.tsv")),
      google = hailCloud match { case true => Some(store(dirTree.dataArrayMap(cfgArray).ancestry.google.get / s"${ref1kgBaseString}.kgsamples.tsv")); case false => None }
    ),
    gds = store(dirTree.dataArrayMap(cfgArray).ancestry.local.get / s"${ref1kgBaseString}.gds"))

  val ancestryData = AncestryData(
    inferred = store(dirTree.dataArrayMap(cfgArray).ancestry.local.get / s"${ancestryBaseString}.inferred.tsv"))

  val ancestryPcaData = AncestryPcaData(
    base = dirTree.dataArrayMap(cfgArray).ancestry.local.get / ancestryPcaBaseString,
    log = store(dirTree.dataArrayMap(cfgArray).ancestry.local.get / s"${ancestryPcaBaseString}.log"),
    scores = store(dirTree.dataArrayMap(cfgArray).ancestry.local.get / s"${ancestryPcaBaseString}.scores.tsv"),
    plots = store(dirTree.dataArrayMap(cfgArray).ancestry.local.get / s"${ancestryPcaBaseString}.plots.pdf"))
  
  val ancestryClusterData = AncestryClusterData(
    base = dirTree.dataArrayMap(cfgArray).ancestry.local.get / ancestryClusterBaseString,
    log = store(dirTree.dataArrayMap(cfgArray).ancestry.local.get / s"${ancestryClusterBaseString}.log"),
    fet = store(dirTree.dataArrayMap(cfgArray).ancestry.local.get / s"${ancestryClusterBaseString}.fet.1"),
    clu = store(dirTree.dataArrayMap(cfgArray).ancestry.local.get / s"${ancestryClusterBaseString}.clu.1"),
    klg = store(dirTree.dataArrayMap(cfgArray).ancestry.local.get / s"${ancestryClusterBaseString}.klg.1"),
    plots = store(dirTree.dataArrayMap(cfgArray).ancestry.local.get / s"${ancestryClusterBaseString}.plots.pdf"),
    centerPlots = store(dirTree.dataArrayMap(cfgArray).ancestry.local.get / s"${ancestryClusterBaseString}.plots.centers.pdf"),
    no1kgPlots = store(dirTree.dataArrayMap(cfgArray).ancestry.local.get / s"${ancestryClusterBaseString}.plots.no1kg.pdf"),
    xtab = store(dirTree.dataArrayMap(cfgArray).ancestry.local.get / s"${ancestryClusterBaseString}.xtab"),
    groups = store(dirTree.dataArrayMap(cfgArray).ancestry.local.get / s"${ancestryClusterBaseString}.groups.tsv"))

  val pcaData = PcaData(
    gds = store(dirTree.dataArrayMap(cfgArray).pca.local.get / s"${pcaBaseString}.gds"),
    log = store(dirTree.dataArrayMap(cfgArray).pca.local.get / s"${pcaBaseString}.log"),
    scores = store(dirTree.dataArrayMap(cfgArray).pca.local.get / s"${pcaBaseString}.scores.tsv"))

  val sexcheckData = SexcheckData(
    sexcheck = MultiStore(
      local = Some(store(dirTree.dataArrayMap(cfgArray).sampleqc.local.get / s"${sampleQcBaseString}.sexcheck.tsv")),
      google = hailCloud match { case true => Some(store(dirTree.dataArrayMap(cfgArray).sampleqc.google.get / s"${sampleQcBaseString}.sexcheck.tsv")); case false => None }
    ),
    problems = MultiStore(
      local = Some(store(dirTree.dataArrayMap(cfgArray).sampleqc.local.get / s"${sampleQcBaseString}.sexcheck.problems.tsv")),
      google = hailCloud match { case true => Some(store(dirTree.dataArrayMap(cfgArray).sampleqc.google.get / s"${sampleQcBaseString}.sexcheck.problems.tsv")); case false => None }
    ),
    hailLog = MultiStore(
      local = Some(store(dirTree.dataArrayMap(cfgArray).sampleqc.local.get / s"${sampleQcBaseString}.sexcheck.hail.log")),
      google = hailCloud match { case true => Some(store(dirTree.dataArrayMap(cfgArray).sampleqc.google.get / s"${sampleQcBaseString}.sexcheck.hail.log")); case false => None }
    ))

  val sampleQcData = SampleQcData(
    stats = MultiStore(
      local = Some(store(dirTree.dataArrayMap(cfgArray).sampleqc.local.get / s"${sampleQcBaseString}.stats.tsv")),
      google = hailCloud match { case true => Some(store(dirTree.dataArrayMap(cfgArray).sampleqc.google.get / s"${sampleQcBaseString}.stats.tsv")); case false => None }
    ),
    hailLog = MultiStore(
      local = Some(store(dirTree.dataArrayMap(cfgArray).sampleqc.local.get / s"${sampleQcBaseString}.stats.hail.log")),
      google = hailCloud match { case true => Some(store(dirTree.dataArrayMap(cfgArray).sampleqc.google.get / s"${sampleQcBaseString}.stats.hail.log")); case false => None }
    ),
    statsAdj = store(dirTree.dataArrayMap(cfgArray).sampleqc.local.get / s"${sampleQcBaseString}.stats.adj.tsv"),
    corrPlots = store(dirTree.dataArrayMap(cfgArray).sampleqc.local.get / s"${sampleQcBaseString}.corr.pdf"),
    boxPlots = store(dirTree.dataArrayMap(cfgArray).sampleqc.local.get / s"${sampleQcBaseString}.boxplots.pdf"),
    discreteness = store(dirTree.dataArrayMap(cfgArray).sampleqc.local.get / s"${sampleQcBaseString}.discreteness.txt"),
    pcaLoadings = store(dirTree.dataArrayMap(cfgArray).sampleqc.local.get / s"${sampleQcBaseString}.pca.loadings.tsv"),
    pcaPlots = store(dirTree.dataArrayMap(cfgArray).sampleqc.local.get / s"${sampleQcBaseString}.pca.plots.pdf"),
    pcaScores = store(dirTree.dataArrayMap(cfgArray).sampleqc.local.get / s"${sampleQcBaseString}.pca.scores.tsv"),
    outliers = store(dirTree.dataArrayMap(cfgArray).sampleqc.local.get / s"${sampleQcBaseString}.outliers.tsv"),
    metricPlots = store(dirTree.dataArrayMap(cfgArray).sampleqc.local.get / s"${sampleQcBaseString}.metricplots.pdf"))

  val sampleQcPcaClusterData = SampleQcPcaClusterData(
    base = dirTree.dataArrayMap(cfgArray).sampleqc.local.get / s"${sampleQcBaseString}.pca.cluster",
    fet = store(dirTree.dataArrayMap(cfgArray).sampleqc.local.get / s"${sampleQcBaseString}.pca.cluster.fet.1"),
    clu = store(dirTree.dataArrayMap(cfgArray).sampleqc.local.get / s"${sampleQcBaseString}.pca.cluster.clu.1"),
    klg = store(dirTree.dataArrayMap(cfgArray).sampleqc.local.get / s"${sampleQcBaseString}.pca.cluster.klg.1"),
    log = store(dirTree.dataArrayMap(cfgArray).sampleqc.local.get / s"${sampleQcBaseString}.pca.cluster.log"),
    outliers = store(dirTree.dataArrayMap(cfgArray).sampleqc.local.get / s"${sampleQcBaseString}.pca.cluster.outliers.tsv"),
    plots = store(dirTree.dataArrayMap(cfgArray).sampleqc.local.get / s"${sampleQcBaseString}.pca.cluster.plots.pdf"),
    xtab = store(dirTree.dataArrayMap(cfgArray).sampleqc.local.get / s"${sampleQcBaseString}.pca.cluster.xtab"))

  val sampleQcMetricClusterData = cfg.sampleQcMetrics.map { metric =>
  
      metric -> SampleQcMetricClusterData(
        base = dirTree.dataArrayMap(cfgArray).sampleqc.local.get / s"${sampleQcBaseString}.${metric}.cluster",
        fet = store(dirTree.dataArrayMap(cfgArray).sampleqc.local.get / s"${sampleQcBaseString}.${metric}.cluster.fet.1"),
        clu = store(dirTree.dataArrayMap(cfgArray).sampleqc.local.get / s"${sampleQcBaseString}.${metric}.cluster.clu.1"),
        klg = store(dirTree.dataArrayMap(cfgArray).sampleqc.local.get / s"${sampleQcBaseString}.${metric}.cluster.klg.1"),
        log = store(dirTree.dataArrayMap(cfgArray).sampleqc.local.get / s"${sampleQcBaseString}.${metric}.cluster.log"))

  }.toMap

  val finalData = FinalData(
    samplesExclude = MultiStore(
      local = Some(store(dirTree.dataArrayMap(cfgArray).filterfinal.local.get / s"${finalBaseString}.samples.exclude.txt")),
      google = hailCloud match { case true => Some(store(dirTree.dataArrayMap(cfgArray).filterfinal.google.get / s"${finalBaseString}.samples.exclude.txt")); case false => None }
    ),
	samplesRestore = store(dirTree.dataArrayMap(cfgArray).filterfinal.local.get / s"${finalBaseString}.samples.restore.tbl"),
    variantsExclude = MultiStore(
      local = Some(store(dirTree.dataArrayMap(cfgArray).filterfinal.local.get / s"${finalBaseString}.variants.exclude.txt")),
      google = hailCloud match { case true => Some(store(dirTree.dataArrayMap(cfgArray).filterfinal.google.get / s"${finalBaseString}.variants.exclude.txt")); case false => None }
    ),
    variantsExcludeIds = store(dirTree.dataArrayMap(cfgArray).filterfinal.local.get / s"${finalBaseString}.variants.exclude.ids.txt"))

  val variantQcData = VariantQcData(
    stats = MultiStore(
      local = Some(store(dirTree.dataArrayMap(cfgArray).filterfinal.local.get / s"${variantQcBaseString}.stats.tsv")),
      google = hailCloud match { case true => Some(store(dirTree.dataArrayMap(cfgArray).filterfinal.google.get / s"${variantQcBaseString}.stats.tsv")); case false => None }
    ))

  val cleanData = CleanData(
    data = Plink(
      base = MultiStrPath(local = Some(dirTree.dataArrayMap(cfgArray).clean.local.get / cleanBaseString), google = None),
      bed = MultiStore(local = Some(store(dirTree.dataArrayMap(cfgArray).clean.local.get / s"${cleanBaseString}.bed").asInput), google = None),
      bim = MultiStore(local = Some(store(dirTree.dataArrayMap(cfgArray).clean.local.get / s"${cleanBaseString}.bim").asInput), google = None),
      fam = MultiStore(local = Some(store(dirTree.dataArrayMap(cfgArray).clean.local.get / s"${cleanBaseString}.fam").asInput), google = None)
    ),
    base = MultiStrPath(
      local = Some(dirTree.dataArrayMap(cfgArray).clean.local.get / cleanBaseString),
      google = hailCloud match { case true => Some(dirTree.dataArrayMap(cfgArray).clean.google.get / cleanBaseString); case false => None }
    ),
    hailLog = MultiStore(
      local = Some(store(dirTree.dataArrayMap(cfgArray).clean.local.get / s"${cleanBaseString}.hail.log")),
      google = hailCloud match { case true => Some(store(dirTree.dataArrayMap(cfgArray).clean.google.get / s"${cleanBaseString}.hail.log")); case false => None }
    ),
    gds = store(dirTree.dataArrayMap(cfgArray).clean.local.get / s"${cleanBaseString}.gds"),
    vcf = Vcf(
      base = MultiStrPath(
        local = Some(dirTree.dataArrayMap(cfgArray).clean.local.get / cleanBaseString),
        google = hailCloud match { case true => Some(dirTree.dataArrayMap(cfgArray).clean.google.get / cleanBaseString); case false => None }
      ),
      vcf = MultiStore(
        local = Some(store(dirTree.dataArrayMap(cfgArray).clean.local.get / s"${cleanBaseString}.vcf.bgz")),
        google = hailCloud match { case true => Some(store(dirTree.dataArrayMap(cfgArray).clean.google.get / s"${cleanBaseString}.vcf.bgz")); case false => None }
      )
    ),
    tbi = store(dirTree.dataArrayMap(cfgArray).clean.local.get / s"${cleanBaseString}.vcf.bgz.tbi"),
    mt = MultiStore(
      local = hailCloud match { case false => Some(store(dirTree.dataArrayMap(cfgArray).clean.local.get / s"${cleanBaseString}.mt")); case true => None },
      google = hailCloud match { case true => Some(store(dirTree.dataArrayMap(cfgArray).clean.google.get / s"${cleanBaseString}.mt")); case false => None }
    ),
    pcaScores = store(dirTree.dataArrayMap(cfgArray).clean.local.get / s"${cleanBaseString}.pca.scores.tsv"),
    pcaLog = store(dirTree.dataArrayMap(cfgArray).clean.local.get / s"${cleanBaseString}.pca.log"))

  array -> Array(
    rawData = rawData,
    preparedData = preparedData,
    annotatedData = annotatedData,
    annotatedChrData = annotatedChrData,
    harmonizedData = harmonizedData,
    prunedData = prunedData,
    kinshipData = kinshipData,
    ref1kgData = ref1kgData,
    ancestryData = ancestryData,
    ancestryPcaData = ancestryPcaData,
    ancestryClusterData = ancestryClusterData,
    pcaData = pcaData,
    sexcheckData = sexcheckData,
    sampleQcData = sampleQcData,
    sampleQcPcaClusterData = sampleQcPcaClusterData,
    sampleQcMetricClusterData = sampleQcMetricClusterData,
    finalData = finalData,
    variantQcData = variantQcData,
    cleanData = cleanData)

}.toMap
