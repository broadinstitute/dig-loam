import ProjectConfig._
import PipelineConfig._
import StoreHelpers._
import Stores._
import Fxns._

final case class RawData(
  plink: Option[Plink],
  vcf: Option[MultiPathVcf],
  unplaced: Option[Store],
  unique: Option[Store],
  indel: Option[Store],
  lmiss: Option[Store],
  imiss: Option[Store],
  imissRemove: Option[Store],
  freq: Option[Store],
  mono: Option[Store],
  dupRemove: Option[Store])

final case class PreparedData(
  plink: Plink,
  multiallelic: Store,
  chain: Option[Store] = None,
  bed: Option[Store] = None,
  lifted: Option[Store] = None,
  unlifted: Option[Store] = None,
  liftedUpdate: Option[Store] = None,
  liftedExtract: Option[Store] = None)

final case class AnnotatedData(
  plink: Plink)

final case class AnnotatedChrData(
  plink: Plink,
  mergedKgPlink: Plink,
  mergedKgHuRefPlink: Plink,
  mergedKgNonKgBase: Path,
  nonKgRemove: Store,
  nonKgIgnore: Store,
  nonKgMono: Store,
  nonKgNomatch: Store,
  nonKgFlip: Store,
  nonKgForceA1: Store,
  mergedKgVarIdUpdate: Store,
  mergedKgVarSnpLog: Store)

final case class HarmonizedData(
  plink: Plink,
  mergeList: Store,
  nonKgRemove: Store,
  nonKgIgnore: Store,
  nonKgMono: Store,
  nonKgNomatch: Store,
  nonKgFlip: Store,
  nonKgForceA1: Store,
  mergedKgVarIdUpdate: Store,
  mergedKgVarSnpLog: Store,
  forceA2: Store)

final case class RefData(
  plink: Option[Plink],
  vcf: MultiPathVcf,
  mtCheckpoint: Option[Store],
  mtCheckpointGoogle: Option[Store],
  mt: Option[Store],
  mtGoogle: Option[Store],
  hailLog: Store,
  hailLogGoogle: Option[Store],
  variantMetrics: Store,
  variantMetricsGoogle: Option[Store],
  sitesVcf: Store,
  sitesVcfGoogle: Option[Store],
  annotations: Store,
  annotationWarnings: Store)

final case class ImputeData(
  data: Seq[Store],
  base: Path)

final case class FilteredData(
  variantMetrics: Store,
  variantMetricsGoogle: Option[Store],
  plink: MultiPathPlink,
  hailLog: Store,
  hailLogGoogle: Option[Store],
  pruneIn: Store)

final case class PrunedData(
  plink: Plink)

final case class KinshipData(
  base: Path,
  log: Store,
  kin: Store,
  kin0: Store,
  kin0Related: Store,
  famSizes: Store)

final case class Ref1kgData(
  plink: MultiPathPlink,
  hailLog: Store,
  hailLogGoogle: Option[Store],
  kgSamples: Store,
  kgSamplesGoogle: Option[Store],
  gds: Store)

final case class AncestryData(
  inferred: Store)

final case class AncestryPcaData(
  base: Path,
  log: Store,
  scores: Store,
  plots: Store)

final case class AncestryClusterData(
  base: Path,
  log: Store,
  fet: Store,
  clu: Store,
  klg: Store,
  plots: Store,
  centerPlots: Store,
  no1kgPlots: Store,
  xtab: Store,
  groups: Store)

final case class PcaData(
  gds: Store,
  log: Store,
  scores: Store)

final case class SexcheckData(
  sexcheck: Store,
  sexcheckGoogle: Option[Store],
  problems: Store,
  problemsGoogle: Option[Store],
  hailLog: Store,
  hailLogGoogle: Option[Store])

final case class SampleQcData(
  stats: Store,
  statsGoogle: Option[Store],
  hailLog: Store,
  hailLogGoogle: Option[Store],
  statsAdj: Store,
  corrPlots: Store,
  boxPlots: Store,
  discreteness: Store,
  pcaLoadings: Store,
  pcaPlots: Store,
  pcaScores: Store,
  outliers: Store,
  incompleteObs: Store,
  metricPlots: Store)

final case class SampleQcPcaClusterData(
  base: Path,
  fet: Store,
  clu: Store,
  klg: Store,
  log: Store,
  outliers: Store,
  plots: Store,
  xtab: Store)

final case class SampleQcMetricClusterData(
  base: Path,
  fet: Store,
  clu: Store,
  klg: Store,
  log: Store)

final case class QcData(
  samplesExclude: Store,
  samplesExcludeGoogle: Option[Store],
  samplesRestore: Store)

final case class AnalysisData(
  samplesStats: Store,
  samplesExclude: Store,
  samplesStatsGoogle: Option[Store],
  samplesExcludeGoogle: Option[Store],
  variantsStats: Store,
  variantsExclude: Store,
  variantsStatsGoogle: Option[Store],
  variantsExcludeGoogle: Option[Store],
  hailLog: Store,
  hailLogGoogle: Option[Store])

//final case class CleanData(
//  plink: Plink,
//  gds: Store,
//  baseGoogle: Option[URI],
//  vcf: Store,
//  tbi: Store,
//  vcfGoogle: Option[Store],
//  mt: Option[Store],
//  mtGoogle: Option[Store],
//  pcaScores: Store,
//  pcaLog: Store)

final case class Array(
  rawData: RawData,
  preparedData: Option[PreparedData],
  annotatedData: Option[AnnotatedData],
  annotatedChrData: Option[Map[String, AnnotatedChrData]],
  harmonizedData: Option[HarmonizedData],
  refData: RefData,
  imputeData: ImputeData,
  filteredData: FilteredData,
  prunedData: PrunedData,
  kinshipData: KinshipData,
  ref1kgData: Ref1kgData,
  ancestryData: AncestryData,
  ancestryPcaData: AncestryPcaData,
  ancestryClusterData: AncestryClusterData,
  pcaData: PcaData,
  sexcheckData: SexcheckData,
  sampleQcData: SampleQcData,
  sampleQcPcaClusterData: SampleQcPcaClusterData,
  sampleQcMetricClusterData: Map[String, SampleQcMetricClusterData],
  qcData: QcData,
  analysisData: AnalysisData)
  //removed: cleanData: CleanData

val arrayStores = projectConfig.Arrays.map { arrayCfg =>

  val rawBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.raw"
  val preparedBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.prepared"
  val annotatedBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.prepared.annotated"
  val harmonizedBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.harmonized"
  val refBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.ref"
  val imputeBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.impute"
  val filteredBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.ref.filtered"
  val prunedBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.ref.filtered.pruned"
  val kinshipBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.kinship"
  val ref1kgBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.ref1kg"
  val ancestryBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.ancestry"
  val ancestryPcaBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.ancestry.pca"
  val ancestryClusterBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.ancestry.cluster"
  val pcaBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.pca"
  val sampleQcBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.sampleqc"
  val qcBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.qc"
  val analysisBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.analysis"
  //val cleanBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.clean"

  val baseName = arrayCfg.filename.split("/").last

  val plink = arrayCfg.technology match {

    case "gwas" =>

      arrayCfg.format match {
        case "plink" =>
          Some(Plink(
            base = path(arrayCfg.filename),
            data = Seq(store(path(checkPath(arrayCfg.filename + s".bed"))).asInput,store(path(checkPath(arrayCfg.filename + s".bim"))).asInput,store(path(checkPath(arrayCfg.filename + s".fam"))).asInput),
          ))
        case _ =>
          Some(Plink(
            base = projectConfig.home / rawBaseString,
            data = bedBimFam(path(checkPlinkPath(s"${projectConfig.home}" + s"/${rawBaseString}")))
          ))
      }

    case _ => None

  }

  val vcf = arrayCfg.format match {
    case "vcf" =>
      arrayCfg.technology match {
        case "gwas" =>
          Some(MultiPathVcf(
            base = MultiPath(local = Some(path(arrayCfg.filename.replaceAll(".vcf.gz$|.vcf.bgz$|.gz$|.bgz$",""))), google = None),
            data = MultiStore(local = Some(store(checkPath(arrayCfg.filename)).asInput), google = None),
            tbi = MultiStore(local = Some(store(checkPath(arrayCfg.filename + s".tbi")).asInput), google = None)))
        case _ =>
          Some(MultiPathVcf(
            base = MultiPath(local = Some(path(arrayCfg.filename.replaceAll(".vcf.gz$|.vcf.bgz$|.gz$|.bgz$",""))), google = projectConfig.hailCloud match { case true => Some(projectConfig.cloudHome.get / baseName.replaceAll(".vcf.gz$|.vcf.bgz$|.gz$|.bgz$","")); case false => None }),
            data = MultiStore(local = Some(store(checkPath(arrayCfg.filename)).asInput), google = projectConfig.hailCloud match { case true => Some(store(projectConfig.cloudHome.get / baseName)); case false => None }),
            tbi = MultiStore(local = Some(store(checkPath(arrayCfg.filename + s".tbi")).asInput), google = projectConfig.hailCloud match { case true => Some(store(projectConfig.cloudHome.get / s"${baseName}.tbi")); case false => None })))
      }
    case _ => None
  }

  val rawData = RawData(
    plink = plink,
    vcf = vcf,
    unplaced = arrayCfg.technology match { case "gwas" => Some(store(projectConfig.home / s"${rawBaseString}.unplaced")); case _ => None },
    unique = arrayCfg.technology match { case "gwas" => Some(store(projectConfig.home / s"${rawBaseString}.unique")); case _ => None },
    indel = arrayCfg.technology match { case "gwas" => Some(store(projectConfig.home / s"${rawBaseString}.indel")); case _ => None },
    lmiss = arrayCfg.technology match { case "gwas" => Some(store(projectConfig.home / s"${rawBaseString}.missing.lmiss")); case _ => None },
    imiss = arrayCfg.technology match { case "gwas" => Some(store(projectConfig.home / s"${rawBaseString}.missing.imiss")); case _ => None },
    imissRemove = arrayCfg.technology match { case "gwas" => Some(store(projectConfig.home / s"${rawBaseString}.missing.imiss.remove")); case _ => None },
    freq = arrayCfg.technology match { case "gwas" => Some(store(projectConfig.home / s"${rawBaseString}.freq.frq")); case _ => None },
    mono = arrayCfg.technology match { case "gwas" => Some(store(projectConfig.home / s"${rawBaseString}.mono")); case _ => None },
    dupRemove = arrayCfg.technology match { case "gwas" => Some(store(projectConfig.home / s"${rawBaseString}.dup.remove")); case _ => None })

  val preparedData = arrayCfg.technology match {

    case "gwas" =>

      Some(PreparedData(
        plink = Plink(base = projectConfig.home / preparedBaseString, data = bedBimFam(projectConfig.home / preparedBaseString)),
        multiallelic = store(projectConfig.home / s"${preparedBaseString}.multiallelic"),
        chain = arrayCfg.liftOver.map(s => store(path(checkPath(s))).asInput),
        bed = arrayCfg.liftOver.map(s => store(projectConfig.home / s"${preparedBaseString}.liftover.bed")),
        lifted = arrayCfg.liftOver.map(s => store(projectConfig.home / s"${preparedBaseString}.lifted")),
        unlifted = arrayCfg.liftOver.map(s => store(projectConfig.home / s"${preparedBaseString}.unlifted")),
        liftedUpdate = arrayCfg.liftOver.map(s => store(projectConfig.home / s"${preparedBaseString}.lifted.update")),
        liftedExtract = arrayCfg.liftOver.map(s => store(projectConfig.home / s"${preparedBaseString}.lifted.extract"))))

    case _ => None

  }

  val annotatedData = arrayCfg.technology match {

    case "gwas" =>

      Some(AnnotatedData(
        plink = arrayCfg.liftOver match {
          case Some(s) => Plink(base = projectConfig.home / annotatedBaseString, data = bedBimFam(projectConfig.home / annotatedBaseString))
          case None => preparedData.get.plink
        }
      ))

    case _ => None

  }

  val chrSeq = (1 to 22).map(e => e.toString).toSeq ++ (if (arrayCfg.xChr) Seq("X") else Seq.empty) ++ (if (arrayCfg.yChr) Seq("Y") else Seq.empty) ++ (if (arrayCfg.mtChr) Seq("MT") else Seq.empty)

  val annotatedChrData = arrayCfg.technology match {

    case "gwas" =>

      Some(chrSeq.map { chr =>

        val chrBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.chr${chr}"
        
        val mergedKgBaseString = ! arrayCfg.skipGh.contains(chr) match {
          case true => s"${chrBaseString}.harmkg"
          case false => s"$chrBaseString"
        }

        val mergedKgHuRefBaseString = s"${mergedKgBaseString}.huref"
        val mergedKgNonKgBaseString = s"${mergedKgBaseString}.nonkg"
        
        chr -> AnnotatedChrData(
          plink = Plink(base = projectConfig.home / chrBaseString, data = bedBimFam(projectConfig.home / chrBaseString)),
          mergedKgPlink = Plink(base = projectConfig.home / mergedKgBaseString, data = bedBimFam(projectConfig.home / mergedKgBaseString)),
          mergedKgHuRefPlink = Plink(base = projectConfig.home / mergedKgHuRefBaseString, data = bedBimFam(projectConfig.home / mergedKgHuRefBaseString)),
          mergedKgNonKgBase = projectConfig.home / mergedKgNonKgBaseString,
          nonKgRemove = store(projectConfig.home / s"${mergedKgNonKgBaseString}.remove"),
          nonKgIgnore = store(projectConfig.home / s"${mergedKgNonKgBaseString}.ignore"),
          nonKgMono = store(projectConfig.home / s"${mergedKgNonKgBaseString}.mono"),
          nonKgNomatch = store(projectConfig.home / s"${mergedKgNonKgBaseString}.nomatch"),
          nonKgFlip = store(projectConfig.home / s"${mergedKgNonKgBaseString}.flip"),
          nonKgForceA1 = store(projectConfig.home / s"${mergedKgNonKgBaseString}.force_a1"),
          mergedKgVarIdUpdate = store(projectConfig.home / s"${mergedKgBaseString}_idUpdates.txt"),
          mergedKgVarSnpLog = store(projectConfig.home / s"${mergedKgBaseString}_snpLog.log"))

      }.toMap)

    case _ => None

  }

  val harmonizedData = arrayCfg.technology match {

    case "gwas" =>

      Some(HarmonizedData(
        plink = Plink(base = projectConfig.home / harmonizedBaseString, data = bedBimFam(projectConfig.home / harmonizedBaseString)),
        mergeList = store(projectConfig.home / s"${harmonizedBaseString}.merge.txt"),
        nonKgRemove = store(projectConfig.home / s"${harmonizedBaseString}.nonkg.remove"),
        nonKgIgnore = store(projectConfig.home / s"${harmonizedBaseString}.nonkg.ignore"),
        nonKgMono = store(projectConfig.home / s"${harmonizedBaseString}.nonkg.mono"),
        nonKgNomatch = store(projectConfig.home / s"${harmonizedBaseString}.nonkg.nomatch"),
        nonKgFlip = store(projectConfig.home / s"${harmonizedBaseString}.nonkg.flip"),
        nonKgForceA1 = store(projectConfig.home / s"${harmonizedBaseString}.nonkg.force_a1"),
        mergedKgVarIdUpdate = store(projectConfig.home / s"${harmonizedBaseString}_idUpdates.txt"),
        mergedKgVarSnpLog = store(projectConfig.home / s"${harmonizedBaseString}_snpLog.log"),
        forceA2 = store(projectConfig.home / s"${harmonizedBaseString}.force_a2.txt")))

    case _ => None

  }

  val refVcf = arrayCfg.technology match {
    case "gwas" =>
      MultiPathVcf(
      base = MultiPath(local = Some(projectConfig.home / refBaseString), google = projectConfig.hailCloud match { case true => Some(projectConfig.cloudHome.get / refBaseString); case false => None }),
      data = MultiStore(local = Some(store(projectConfig.home / s"${refBaseString}.vcf.gz")), google = projectConfig.hailCloud match { case true => Some(store(projectConfig.cloudHome.get / s"${refBaseString}.vcf.gz")); case false => None }),
      tbi = MultiStore(local = Some(store(projectConfig.home / s"${refBaseString}.vcf.gz.tbi")), google = projectConfig.hailCloud match { case true => Some(store(projectConfig.cloudHome.get / s"${refBaseString}.vcf.gz.tbi")); case false => None }))
    case _ =>
      rawData.vcf.get
  }

  val refData = RefData(
    plink = arrayCfg.technology match { case "gwas" => Some(Plink(base = projectConfig.home / refBaseString, data = bedBimFam(projectConfig.home / refBaseString))); case _ => None },
    vcf = refVcf,
    mtCheckpoint = projectConfig.hailCloud match { case false => Some(store(projectConfig.home / s"${refBaseString}.mt.checkpoint")); case true => None },
    mtCheckpointGoogle = projectConfig.hailCloud match { case true => Some(store(projectConfig.cloudHome.get / s"${refBaseString}.mt.checkpoint")); case false => None },
    mt = projectConfig.hailCloud match { case false => Some(store(projectConfig.home / s"${refBaseString}.mt")); case true => None },
    mtGoogle = projectConfig.hailCloud match { case true => Some(store(projectConfig.cloudHome.get / s"${refBaseString}.mt")); case false => None },
    hailLog = store(projectConfig.home / s"${refBaseString}.hail.log"),
    hailLogGoogle = projectConfig.hailCloud match { case true => Some(store(projectConfig.cloudHome.get / s"${refBaseString}.hail.log")); case false => None },
    variantMetrics = store(projectConfig.home / s"${refBaseString}.variant.metrics.tsv.bgz"),
    variantMetricsGoogle = projectConfig.hailCloud match { case true => Some(store(projectConfig.cloudHome.get / s"${refBaseString}.variant.metrics.tsv.bgz")); case false => None },
    sitesVcf = store(projectConfig.home / s"${refBaseString}.sites_only.vcf.bgz"),
    sitesVcfGoogle = projectConfig.hailCloud match { case true => Some(store(projectConfig.cloudHome.get / s"${refBaseString}.sites_only.vcf.bgz")); case false => None },
    annotations = store(projectConfig.home / s"${refBaseString}.annotations.bgz"),
    annotationWarnings = store(projectConfig.home / s"${refBaseString}.annotations.warnings"))

  val imputeData = ImputeData(
    data = bedBimFam(projectConfig.home / imputeBaseString),
    base = projectConfig.home / imputeBaseString)

  val filteredData = FilteredData(
    variantMetrics = store(projectConfig.home / s"${filteredBaseString}.variant.metrics.tsv.bgz"),
    variantMetricsGoogle = projectConfig.hailCloud match { case true => Some(store(projectConfig.cloudHome.get / s"${filteredBaseString}.variant.metrics.tsv.bgz")); case false => None },
    plink = MultiPathPlink(base = MultiPath(local = Some(projectConfig.home / filteredBaseString), google = projectConfig.hailCloud match { case true => Some(projectConfig.cloudHome.get / filteredBaseString); case false => None }), data = MultiSeqStore(local = Some(bedBimFam(projectConfig.home / filteredBaseString)), google = projectConfig.hailCloud match { case true => Some(bedBimFam(projectConfig.cloudHome.get / filteredBaseString)); case false => None })),
    hailLog = store(projectConfig.home / s"${filteredBaseString}.hail.log"),
    hailLogGoogle = projectConfig.hailCloud match { case true => Some(store(projectConfig.cloudHome.get / s"${filteredBaseString}.hail.log")); case false => None },
    pruneIn = store(projectConfig.home / s"${filteredBaseString}.prune.in"))

  val prunedData = PrunedData(
    plink = Plink(base = projectConfig.home / prunedBaseString, data = bedBimFam(projectConfig.home / prunedBaseString)))

  val kinshipData = KinshipData(
    base = projectConfig.home / kinshipBaseString,
    log = store(projectConfig.home / s"${kinshipBaseString}.log"),
    kin = store(projectConfig.home / s"${kinshipBaseString}.kin"),
    kin0 = store(projectConfig.home / s"${kinshipBaseString}.kin0"),
    kin0Related = store(projectConfig.home / s"${kinshipBaseString}.kin0.related"),
    famSizes = store(projectConfig.home / s"${kinshipBaseString}.famsizes.tsv"))

  val ref1kgData = Ref1kgData(
    plink = MultiPathPlink(base = MultiPath(local = Some(projectConfig.home / ref1kgBaseString), google = projectConfig.hailCloud match { case true => Some(projectConfig.cloudHome.get / ref1kgBaseString); case false => None }), data = MultiSeqStore(local = Some(bedBimFam(projectConfig.home / ref1kgBaseString)), google = projectConfig.hailCloud match { case true => Some(bedBimFam(projectConfig.cloudHome.get / ref1kgBaseString)); case false => None })),
    hailLog = store(projectConfig.home / s"${ref1kgBaseString}.hail.log"),
    hailLogGoogle = projectConfig.hailCloud match { case true => Some(store(projectConfig.cloudHome.get / s"${ref1kgBaseString}.hail.log")); case false => None },
    kgSamples = store(projectConfig.home / s"${ref1kgBaseString}.kgsamples.tsv"),
    kgSamplesGoogle = projectConfig.hailCloud match { case true => Some(store(projectConfig.cloudHome.get / s"${ref1kgBaseString}.kgsamples.tsv")); case false => None },
    gds = store(projectConfig.home / s"${ref1kgBaseString}.gds"))

  val ancestryData = AncestryData(
    inferred = store(projectConfig.home / s"${ancestryBaseString}.inferred.tsv"))

  val ancestryPcaData = AncestryPcaData(
    base = projectConfig.home / ancestryPcaBaseString,
    log = store(projectConfig.home / s"${ancestryPcaBaseString}.log"),
    scores = store(projectConfig.home / s"${ancestryPcaBaseString}.scores.tsv"),
    plots = store(projectConfig.home / s"${ancestryPcaBaseString}.plots.pdf"))
  
  val ancestryClusterData = AncestryClusterData(
    base = projectConfig.home / ancestryClusterBaseString,
    log = store(projectConfig.home / s"${ancestryClusterBaseString}.log"),
    fet = store(projectConfig.home / s"${ancestryClusterBaseString}.fet.1"),
    clu = store(projectConfig.home / s"${ancestryClusterBaseString}.clu.1"),
    klg = store(projectConfig.home / s"${ancestryClusterBaseString}.klg.1"),
    plots = store(projectConfig.home / s"${ancestryClusterBaseString}.plots.pdf"),
    centerPlots = store(projectConfig.home / s"${ancestryClusterBaseString}.plots.centers.pdf"),
    no1kgPlots = store(projectConfig.home / s"${ancestryClusterBaseString}.plots.no1kg.pdf"),
    xtab = store(projectConfig.home / s"${ancestryClusterBaseString}.xtab"),
    groups = store(projectConfig.home / s"${ancestryClusterBaseString}.groups.tsv"))

  val pcaData = PcaData(
    gds = store(projectConfig.home / s"${pcaBaseString}.gds"),
    log = store(projectConfig.home / s"${pcaBaseString}.log"),
    scores = store(projectConfig.home / s"${pcaBaseString}.scores.tsv"))

  val sexcheckData = SexcheckData(
    sexcheck = store(projectConfig.home / s"${sampleQcBaseString}.sexcheck.tsv"),
    sexcheckGoogle = projectConfig.hailCloud match { case true => Some(store(projectConfig.cloudHome.get / s"${sampleQcBaseString}.sexcheck.tsv")); case false => None },
    problems = store(projectConfig.home / s"${sampleQcBaseString}.sexcheck.problems.tsv"),
    problemsGoogle = projectConfig.hailCloud match { case true => Some(store(projectConfig.cloudHome.get / s"${sampleQcBaseString}.sexcheck.problems.tsv")); case false => None },
    hailLog = store(projectConfig.home / s"${sampleQcBaseString}.sexcheck.hail.log"),
    hailLogGoogle = projectConfig.hailCloud match { case true => Some(store(projectConfig.cloudHome.get / s"${sampleQcBaseString}.sexcheck.hail.log")); case false => None })

  val sampleQcData = SampleQcData(
    stats = store(projectConfig.home / s"${sampleQcBaseString}.stats.tsv"),
    statsGoogle = projectConfig.hailCloud match { case true => Some(store(projectConfig.cloudHome.get / s"${sampleQcBaseString}.stats.tsv")); case false => None },
    hailLog = store(projectConfig.home / s"${sampleQcBaseString}.stats.hail.log"),
    hailLogGoogle = projectConfig.hailCloud match { case true => Some(store(projectConfig.cloudHome.get / s"${sampleQcBaseString}.stats.hail.log")); case false => None },
    statsAdj = store(projectConfig.home / s"${sampleQcBaseString}.stats.adj.tsv"),
    corrPlots = store(projectConfig.home / s"${sampleQcBaseString}.corr.pdf"),
    boxPlots = store(projectConfig.home / s"${sampleQcBaseString}.boxplots.pdf"),
    discreteness = store(projectConfig.home / s"${sampleQcBaseString}.discreteness.txt"),
    pcaLoadings = store(projectConfig.home / s"${sampleQcBaseString}.pca.loadings.tsv"),
    pcaPlots = store(projectConfig.home / s"${sampleQcBaseString}.pca.plots.pdf"),
    pcaScores = store(projectConfig.home / s"${sampleQcBaseString}.pca.scores.tsv"),
    outliers = store(projectConfig.home / s"${sampleQcBaseString}.outliers.tsv"),
    incompleteObs = store(projectConfig.home / s"${sampleQcBaseString}.incomplete_obs.tsv"),
    metricPlots = store(projectConfig.home / s"${sampleQcBaseString}.metricplots.pdf"))

  val sampleQcPcaClusterData = SampleQcPcaClusterData(
    base = projectConfig.home / s"${sampleQcBaseString}.pca.cluster",
    fet = store(projectConfig.home / s"${sampleQcBaseString}.pca.cluster.fet.1"),
    clu = store(projectConfig.home / s"${sampleQcBaseString}.pca.cluster.clu.1"),
    klg = store(projectConfig.home / s"${sampleQcBaseString}.pca.cluster.klg.1"),
    log = store(projectConfig.home / s"${sampleQcBaseString}.pca.cluster.log"),
    outliers = store(projectConfig.home / s"${sampleQcBaseString}.pca.cluster.outliers.tsv"),
    plots = store(projectConfig.home / s"${sampleQcBaseString}.pca.cluster.plots.pdf"),
    xtab = store(projectConfig.home / s"${sampleQcBaseString}.pca.cluster.xtab"))

  val sampleQcMetricClusterData = arrayCfg.sampleQcMetrics.map { metric =>
  
      metric -> SampleQcMetricClusterData(
        base = projectConfig.home / s"${sampleQcBaseString}.${metric}.cluster",
        fet = store(projectConfig.home / s"${sampleQcBaseString}.${metric}.cluster.fet.1"),
        clu = store(projectConfig.home / s"${sampleQcBaseString}.${metric}.cluster.clu.1"),
        klg = store(projectConfig.home / s"${sampleQcBaseString}.${metric}.cluster.klg.1"),
        log = store(projectConfig.home / s"${sampleQcBaseString}.${metric}.cluster.log"))

  }.toMap

  val qcData = QcData(
    samplesExclude = store(projectConfig.home / s"${qcBaseString}.samples.exclude.txt"),
    samplesExcludeGoogle = projectConfig.hailCloud match { case true => Some(store(projectConfig.cloudHome.get / s"${qcBaseString}.samples.exclude.txt")); case false => None },
	samplesRestore = store(projectConfig.home / s"${qcBaseString}.samples.restore.tbl"))

  val analysisData = AnalysisData(
    samplesStats = store(projectConfig.home / s"${analysisBaseString}.samples.stats.tsv"),
    samplesExclude = store(projectConfig.home / s"${analysisBaseString}.samples.exclude.txt"),
    samplesStatsGoogle = projectConfig.hailCloud match { case true => Some(store(projectConfig.cloudHome.get / s"${analysisBaseString}.samples.stats.tsv")); case false => None },
    samplesExcludeGoogle = projectConfig.hailCloud match { case true => Some(store(projectConfig.cloudHome.get / s"${analysisBaseString}.samples.exclude.txt")); case false => None },
    variantsStats = store(projectConfig.home / s"${analysisBaseString}.variants.stats.tsv"),
    variantsExclude = store(projectConfig.home / s"${analysisBaseString}.variants.exclude.txt"),
    variantsStatsGoogle = projectConfig.hailCloud match { case true => Some(store(projectConfig.cloudHome.get / s"${analysisBaseString}.variants.stats.tsv")); case false => None },
    variantsExcludeGoogle = projectConfig.hailCloud match { case true => Some(store(projectConfig.cloudHome.get / s"${analysisBaseString}.variants.exclude.txt")); case false => None },
    hailLog = store(projectConfig.home / s"${analysisBaseString}.hail.log"),
    hailLogGoogle = projectConfig.hailCloud match { case true => Some(store(projectConfig.cloudHome.get / s"${analysisBaseString}.hail.log")); case false => None })

  //val cleanData = CleanData(
  //  plink = Plink(base = projectConfig.home / cleanBaseString, data = bedBimFam(projectConfig.home / cleanBaseString)),
  //  gds = store(projectConfig.home / s"${cleanBaseString}.gds"),
  //  baseGoogle = projectConfig.hailCloud match { case true => Some(projectConfig.cloudHome.get / cleanBaseString); case false => None },
  //  vcf = store(projectConfig.home / s"${cleanBaseString}.vcf.bgz"),
  //  tbi = store(projectConfig.home / s"${cleanBaseString}.vcf.bgz.tbi"),
  //  vcfGoogle = projectConfig.hailCloud match { case true => Some(store(projectConfig.cloudHome.get / s"${cleanBaseString}.vcf.bgz")); case false => None },
  //  mt = projectConfig.hailCloud match { case false => Some(store(projectConfig.home / s"${cleanBaseString}.mt")); case true => None },
  //  mtGoogle = projectConfig.hailCloud match { case true => Some(store(projectConfig.cloudHome.get / s"${cleanBaseString}.mt")); case false => None },
  //  pcaScores = store(projectConfig.home / s"${cleanBaseString}.pca.scores.tsv"),
  //  pcaLog = store(projectConfig.home / s"${cleanBaseString}.pca.log"))

  arrayCfg -> Array(
    rawData = rawData,
    preparedData = preparedData,
    annotatedData = annotatedData,
    annotatedChrData = annotatedChrData,
    harmonizedData = harmonizedData,
    refData = refData,
    imputeData = imputeData,
    filteredData = filteredData,
    prunedData = prunedData,
    kinshipData = kinshipData,
    ref1kgData = ref1kgData,
    ancestryData = ancestryData,
    ancestryPcaData = ancestryPcaData,
    ancestryClusterData = ancestryClusterData,
    pcaData = pcaData,
    sexcheckData = sexcheckData,
    sampleQcData = sampleQcData,
    sampleQcPcaClusterData = sampleQcPcaClusterData,
    sampleQcMetricClusterData = sampleQcMetricClusterData,
    qcData = qcData,
    analysisData = analysisData)
    //removed: cleanData = cleanData

}.toMap
