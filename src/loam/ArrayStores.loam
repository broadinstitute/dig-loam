import ProjectConfig._
import StoreHelpers._
import Stores._
import Fxns._
import DirTree._

final case class RawData(
  plink: Option[Plink],
  vcf: Option[MultiPathVcf],
  rawBase: Option[Path],
  unplaced: Option[Store],
  unique: Option[Store],
  indel: Option[Store],
  lmiss: Option[Store],
  imiss: Option[Store],
  imissRemove: Option[Store],
  freq: Option[Store],
  mono: Option[Store],
  dupVars: Option[Store],
  dupVarsPlink: Option[Plink],
  dupVarsBase: Path,
  dupVarsFreq: Option[Store],
  dupVarsImiss: Option[Store],
  dupVarsLmiss: Option[Store],
  dupVarsRemove: Option[Store])

final case class PreparedData(
  plink: Plink,
  multiallelic: Store,
  chain: Option[Store] = None,
  bed: Option[Store] = None,
  lifted: Option[Store] = None,
  unlifted: Option[Store] = None,
  liftedUpdate: Option[Store] = None,
  liftedExtract: Option[Store] = None)

final case class AnnotatedData(
  plink: Plink)

final case class AnnotatedChrData(
  plink: Plink,
  mergedKgPlink: Plink,
  mergedKgHuRefPlink: Plink,
  mergedKgNonKgBase: Path,
  nonKgRemove: Store,
  nonKgIgnore: Store,
  nonKgMono: Store,
  nonKgNomatch: Store,
  nonKgFlip: Store,
  nonKgForceA1: Store,
  mergedKgVarIdUpdate: Store,
  mergedKgVarSnpLog: Store)

final case class HarmonizedData(
  plink: Plink,
  mergeList: Store,
  nonKgRemove: Store,
  nonKgIgnore: Store,
  nonKgMono: Store,
  nonKgNomatch: Store,
  nonKgFlip: Store,
  nonKgForceA1: Store,
  mergedKgVarIdUpdate: Store,
  mergedKgVarSnpLog: Store,
  forceA2: Store)

final case class RefData(
  plink: Option[MultiPathPlink],
  vcf: Option[MultiPathVcf],
  mtCheckpoint: Option[Store],
  mtCheckpointGoogle: Option[Store],
  mt: Option[Store],
  mtGoogle: Option[Store],
  hailLog: Store,
  hailLogGoogle: Option[Store],
  variantMetrics: Store,
  variantMetricsGoogle: Option[Store],
  sitesVcf: Store,
  sitesVcfGoogle: Option[Store],
  annotations: Store,
  annotationWarnings: Store)

final case class ImputeData(
  data: Seq[Store],
  base: Path)

final case class FilteredData(
  variantMetrics: Store,
  variantMetricsGoogle: Option[Store],
  plink: MultiPathPlink,
  hailLog: Store,
  hailLogGoogle: Option[Store],
  pruneIn: Store)

final case class PrunedData(
  plink: Plink,
  bimGoogle: Option[Store])

final case class KinshipData(
  base: Path,
  log: Store,
  kin0: Store,
  famSizes: Store)

final case class Ref1kgData(
  plink: MultiPathPlink,
  hailLog: Store,
  hailLogGoogle: Option[Store],
  kgSamples: Store,
  kgSamplesGoogle: Option[Store],
  gds: Store)

final case class AncestryData(
  inferred: Store)

final case class AncestryPcaData(
  base: Path,
  log: Store,
  scores: Store,
  eigenVecs: Store,
  loadings: Store,
  eigenVals: Store,
  pve: Store,
  meansd: Store,
  plots: Store)

final case class AncestryClusterData(
  base: Path,
  log: Store,
  fet: Store,
  clu: Store,
  klg: Store,
  plots: Store,
  centerPlots: Store,
  no1kgPlots: Store,
  xtab: Store,
  groups: Store)

final case class PcaData(
  log: Store,
  scores: Store,
  eigenVecs: Store,
  loadings: Store,
  eigenVals: Store,
  pve: Store,
  meansd: Store)

final case class SexcheckData(
  sexcheck: Store,
  sexcheckGoogle: Option[Store],
  problems: Store,
  problemsGoogle: Option[Store],
  hailLog: Store,
  hailLogGoogle: Option[Store])

final case class SampleQcData(
  stats: Store,
  statsGoogle: Option[Store],
  hailLog: Store,
  hailLogGoogle: Option[Store],
  statsAdj: Store,
  corrPlots: Store,
  boxPlots: Store,
  discreteness: Store,
  pcaLoadings: Store,
  pcaPlots: Store,
  pcaScores: Store,
  outliers: Store,
  incompleteObs: Store,
  metricPlots: Store)

final case class SampleQcPcaClusterData(
  base: Path,
  fet: Store,
  clu: Store,
  klg: Store,
  log: Store,
  outliers: Store,
  plots: Store,
  xtab: Store)

final case class SampleQcMetricClusterData(
  base: Path,
  fet: Store,
  clu: Store,
  klg: Store,
  log: Store)

final case class FilterQc(
  samplesExclude: Store,
  samplesExcludeGoogle: Option[Store],
  samplesRestore: Store)

final case class FilterPostQc(
  samplesStats: Store,
  samplesExclude: Store,
  samplesStatsGoogle: Option[Store],
  samplesExcludeGoogle: Option[Store],
  variantsStats: Store,
  variantsExclude: Store,
  variantsStatsGoogle: Option[Store],
  variantsExcludeGoogle: Option[Store],
  hailLog: Store,
  hailLogGoogle: Option[Store])

final case class CleanData(
  vcf: Option[MultiPathVcf],
  hailLog: Store,
  hailLogGoogle: Option[Store])

final case class Array(
  rawData: RawData,
  preparedData: Option[PreparedData],
  annotatedData: Option[AnnotatedData],
  annotatedChrData: Option[Map[String, AnnotatedChrData]],
  harmonizedData: Option[HarmonizedData],
  refData: RefData,
  imputeData: ImputeData,
  filteredData: FilteredData,
  prunedData: PrunedData,
  kinshipData: KinshipData,
  ref1kgData: Ref1kgData,
  ancestryData: AncestryData,
  ancestryPcaData: AncestryPcaData,
  ancestryClusterData: AncestryClusterData,
  pcaData: PcaData,
  sexcheckData: SexcheckData,
  sampleQcData: SampleQcData,
  sampleQcPcaClusterData: SampleQcPcaClusterData,
  sampleQcMetricClusterData: Map[String, SampleQcMetricClusterData],
  filterQc: FilterQc,
  filterPostQc: FilterPostQc,
  cleanData: Option[CleanData])

val arrayStores = projectConfig.Arrays.map { arrayCfg =>

  val rawBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.raw"
  val rawDupVarsBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.raw.dup.vars"
  val preparedBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.prepared"
  val annotatedBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.prepared.annotated"
  val harmonizedBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.harmonized"
  val refBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.ref"
  val imputeBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.impute"
  val filteredBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.ref.filtered"
  val prunedBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.ref.filtered.pruned"
  val kinshipBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.kinship"
  val ref1kgBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.ref1kg"
  val ancestryBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.ancestry"
  val ancestryPcaBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.ancestry.pca"
  val ancestryClusterBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.ancestry.cluster"
  val pcaBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.pca"
  val sampleQcBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.sampleqc"
  val filterQcBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.qc"
  val filterPostQcBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.postqc"
  val cleanBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.clean"
  //val cleanBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.clean"

  val baseName = arrayCfg.filename.split("/").last
  val inputType = arrayCfg.technology + "_" + arrayCfg.format

  val plink = inputType match {
    case "gwas_plink" | "wgs_plink" | "wes_plink" =>
      Some(Plink(
        base = path(arrayCfg.filename),
        data = Seq(store(path(checkPath(arrayCfg.filename + s".bed"))).asInput,store(path(checkPath(arrayCfg.filename + s".bim"))).asInput,store(path(checkPath(arrayCfg.filename + s".fam"))).asInput),
      ))
    case "gwas_vcf" =>
      Some(Plink(
        base = dirTree.base.local.get / rawBaseString,
        data = bedBimFam(path(checkPlinkPath(s"${dirTree.base.local.get}" + s"/${rawBaseString}")))
      ))
    case "wgs_vcf" | "wes_vcf" => None
    case _ => throw new CfgException("invalid input type " + inputType)
  }

  val vcf = inputType match {
    case "gwas_vcf" =>
      Some(MultiPathVcf(
        base = MultiPath(local = Some(path(arrayCfg.filename.replaceAll(".vcf.gz$|.vcf.bgz$|.gz$|.bgz$",""))), google = None),
        data = MultiStore(local = Some(store(checkPath(arrayCfg.filename)).asInput), google = None),
        tbi = MultiStore(local = Some(store(checkPath(arrayCfg.filename + s".tbi")).asInput), google = None)
      ))
    case "wgs_vcf" | "wes_vcf" =>
      Some(MultiPathVcf(
        base = MultiPath(local = Some(path(arrayCfg.filename.replaceAll(".vcf.gz$|.vcf.bgz$|.gz$|.bgz$",""))), google = projectConfig.hailCloud match { case true => Some(dirTree.dataGlobal.google.get / baseName.replaceAll(".vcf.gz$|.vcf.bgz$|.gz$|.bgz$","")); case false => None }),
        data = MultiStore(local = Some(store(checkPath(arrayCfg.filename)).asInput), google = projectConfig.hailCloud match { case true => Some(store(dirTree.dataGlobal.google.get / baseName)); case false => None }),
        tbi = MultiStore(local = Some(store(checkPath(arrayCfg.filename + s".tbi")).asInput), google = projectConfig.hailCloud match { case true => Some(store(dirTree.dataGlobal.google.get / s"${baseName}.tbi")); case false => None })
      ))
    case "gwas_plink" | "wgs_plink" | "wes_plink" => None
    case _ => throw new CfgException("invalid input type " + inputType)
  }

  val rawData = RawData(
    plink = plink,
    vcf = vcf,
    rawBase = arrayCfg.technology match { case "gwas" => Some(dirTree.dataArrayMap(arrayCfg).prepare.local.get / rawBaseString); case _ => None },
    unplaced = arrayCfg.technology match { case "gwas" => Some(store(dirTree.dataArrayMap(arrayCfg).prepare.local.get / s"${rawBaseString}.unplaced")); case _ => None },
    unique = arrayCfg.technology match { case "gwas" => Some(store(dirTree.dataArrayMap(arrayCfg).prepare.local.get / s"${rawBaseString}.unique")); case _ => None },
    indel = arrayCfg.technology match { case "gwas" => Some(store(dirTree.dataArrayMap(arrayCfg).prepare.local.get / s"${rawBaseString}.indel")); case _ => None },
    lmiss = arrayCfg.technology match { case "gwas" => Some(store(dirTree.dataArrayMap(arrayCfg).prepare.local.get / s"${rawBaseString}.missing.lmiss")); case _ => None },
    imiss = arrayCfg.technology match { case "gwas" => Some(store(dirTree.dataArrayMap(arrayCfg).prepare.local.get / s"${rawBaseString}.missing.imiss")); case _ => None },
    imissRemove = arrayCfg.technology match { case "gwas" => Some(store(dirTree.dataArrayMap(arrayCfg).prepare.local.get / s"${rawBaseString}.missing.imiss.remove")); case _ => None },
    freq = arrayCfg.technology match { case "gwas" => Some(store(dirTree.dataArrayMap(arrayCfg).prepare.local.get / s"${rawBaseString}.freq.frq")); case _ => None },
    mono = arrayCfg.technology match { case "gwas" => Some(store(dirTree.dataArrayMap(arrayCfg).prepare.local.get / s"${rawBaseString}.mono")); case _ => None },
    dupVars = arrayCfg.technology match { case "gwas" => Some(store(dirTree.dataArrayMap(arrayCfg).prepare.local.get / s"${rawBaseString}.listdupvars.dupvar")); case _ => None },
    dupVarsPlink = arrayCfg.technology match { case "gwas" => Some(Plink(base = dirTree.dataArrayMap(arrayCfg).prepare.local.get / rawDupVarsBaseString, data = bedBimFam(path(checkPlinkPath(s"${dirTree.dataArrayMap(arrayCfg).prepare.local.get}" + s"/${rawDupVarsBaseString}"))))); case _ => None },
    dupVarsBase = arrayCfg.technology match { case "gwas" => Some(dirTree.dataArrayMap(arrayCfg).prepare.local.get / rawDupVarsBaseString); case _ => None },
    dupVarsFreq = arrayCfg.technology match { case "gwas" => Some(store(dirTree.dataArrayMap(arrayCfg).prepare.local.get / s"${rawDupVarsBaseString}.freq.frq")); case _ => None },
    dupVarsImiss = arrayCfg.technology match { case "gwas" => Some(store(dirTree.dataArrayMap(arrayCfg).prepare.local.get / s"${rawDupVarsBaseString}.missing.imiss")); case _ => None },
    dupVarsLmiss = arrayCfg.technology match { case "gwas" => Some(store(dirTree.dataArrayMap(arrayCfg).prepare.local.get / s"${rawDupVarsBaseString}.missing.lmiss")); case _ => None },
    dupVarsRemove = arrayCfg.technology match { case "gwas" => Some(store(dirTree.dataArrayMap(arrayCfg).prepare.local.get / s"${rawBaseString}.dup.vars.remove")); case _ => None }
  )

  val preparedData = arrayCfg.technology match {

    case "gwas" =>

      Some(PreparedData(
        plink = Plink(base = dirTree.dataArrayMap(arrayCfg).prepare.local.get / preparedBaseString, data = bedBimFam(dirTree.dataArrayMap(arrayCfg).prepare.local.get / preparedBaseString)),
        multiallelic = store(dirTree.dataArrayMap(arrayCfg).prepare.local.get / s"${preparedBaseString}.multiallelic"),
        chain = arrayCfg.liftOver.map(s => store(path(checkPath(s))).asInput),
        bed = arrayCfg.liftOver.map(s => store(dirTree.dataArrayMap(arrayCfg).prepare.local.get / s"${preparedBaseString}.liftover.bed")),
        lifted = arrayCfg.liftOver.map(s => store(dirTree.dataArrayMap(arrayCfg).prepare.local.get / s"${preparedBaseString}.lifted")),
        unlifted = arrayCfg.liftOver.map(s => store(dirTree.dataArrayMap(arrayCfg).prepare.local.get / s"${preparedBaseString}.unlifted")),
        liftedUpdate = arrayCfg.liftOver.map(s => store(dirTree.dataArrayMap(arrayCfg).prepare.local.get / s"${preparedBaseString}.lifted.update")),
        liftedExtract = arrayCfg.liftOver.map(s => store(dirTree.dataArrayMap(arrayCfg).prepare.local.get / s"${preparedBaseString}.lifted.extract"))))

    case _ => None

  }

  val annotatedData = arrayCfg.technology match {

    case "gwas" =>

      Some(AnnotatedData(
        plink = arrayCfg.liftOver match {
          case Some(s) => Plink(base = dirTree.dataArrayMap(arrayCfg).prepare.local.get / annotatedBaseString, data = bedBimFam(dirTree.dataArrayMap(arrayCfg).prepare.local.get / annotatedBaseString))
          case None => preparedData.get.plink
        }
      ))

    case _ => None

  }

  val annotatedChrData = arrayCfg.technology match {

    case "gwas" =>

      Some(expandChrList(arrayCfg.chrs).map { chr =>

        val chrBaseString = s"${projectConfig.projectId}.${arrayCfg.id}.chr${chr}"
        
        val mergedKgBaseString = s"${chrBaseString}.harmkg"
        val mergedKgHuRefBaseString = s"${mergedKgBaseString}.huref"
        val mergedKgNonKgBaseString = s"${mergedKgBaseString}.nonkg"
        
        chr -> AnnotatedChrData(
          plink = Plink(base = dirTree.dataArrayMap(arrayCfg).harmonize.local.get / chrBaseString, data = bedBimFam(dirTree.dataArrayMap(arrayCfg).harmonize.local.get / chrBaseString)),
          mergedKgPlink = Plink(base = dirTree.dataArrayMap(arrayCfg).harmonize.local.get / mergedKgBaseString, data = bedBimFam(dirTree.dataArrayMap(arrayCfg).harmonize.local.get / mergedKgBaseString)),
          mergedKgHuRefPlink = Plink(base = dirTree.dataArrayMap(arrayCfg).harmonize.local.get / mergedKgHuRefBaseString, data = bedBimFam(dirTree.dataArrayMap(arrayCfg).harmonize.local.get / mergedKgHuRefBaseString)),
          mergedKgNonKgBase = dirTree.dataArrayMap(arrayCfg).harmonize.local.get / mergedKgNonKgBaseString,
          nonKgRemove = store(dirTree.dataArrayMap(arrayCfg).harmonize.local.get / s"${mergedKgNonKgBaseString}.remove"),
          nonKgIgnore = store(dirTree.dataArrayMap(arrayCfg).harmonize.local.get / s"${mergedKgNonKgBaseString}.ignore"),
          nonKgMono = store(dirTree.dataArrayMap(arrayCfg).harmonize.local.get / s"${mergedKgNonKgBaseString}.mono"),
          nonKgNomatch = store(dirTree.dataArrayMap(arrayCfg).harmonize.local.get / s"${mergedKgNonKgBaseString}.nomatch"),
          nonKgFlip = store(dirTree.dataArrayMap(arrayCfg).harmonize.local.get / s"${mergedKgNonKgBaseString}.flip"),
          nonKgForceA1 = store(dirTree.dataArrayMap(arrayCfg).harmonize.local.get / s"${mergedKgNonKgBaseString}.force_a1"),
          mergedKgVarIdUpdate = store(dirTree.dataArrayMap(arrayCfg).harmonize.local.get / s"${mergedKgBaseString}_idUpdates.txt"),
          mergedKgVarSnpLog = store(dirTree.dataArrayMap(arrayCfg).harmonize.local.get / s"${mergedKgBaseString}_snpLog.log"))

      }.toMap)

    case _ => None

  }

  val harmonizedData = arrayCfg.technology match {

    case "gwas" =>

      Some(HarmonizedData(
        plink = Plink(base = dirTree.dataArrayMap(arrayCfg).harmonize.local.get / harmonizedBaseString, data = bedBimFam(dirTree.dataArrayMap(arrayCfg).harmonize.local.get / harmonizedBaseString)),
        mergeList = store(dirTree.dataArrayMap(arrayCfg).harmonize.local.get / s"${harmonizedBaseString}.merge.txt"),
        nonKgRemove = store(dirTree.dataArrayMap(arrayCfg).harmonize.local.get / s"${harmonizedBaseString}.nonkg.remove"),
        nonKgIgnore = store(dirTree.dataArrayMap(arrayCfg).harmonize.local.get / s"${harmonizedBaseString}.nonkg.ignore"),
        nonKgMono = store(dirTree.dataArrayMap(arrayCfg).harmonize.local.get / s"${harmonizedBaseString}.nonkg.mono"),
        nonKgNomatch = store(dirTree.dataArrayMap(arrayCfg).harmonize.local.get / s"${harmonizedBaseString}.nonkg.nomatch"),
        nonKgFlip = store(dirTree.dataArrayMap(arrayCfg).harmonize.local.get / s"${harmonizedBaseString}.nonkg.flip"),
        nonKgForceA1 = store(dirTree.dataArrayMap(arrayCfg).harmonize.local.get / s"${harmonizedBaseString}.nonkg.force_a1"),
        mergedKgVarIdUpdate = store(dirTree.dataArrayMap(arrayCfg).harmonize.local.get / s"${harmonizedBaseString}_idUpdates.txt"),
        mergedKgVarSnpLog = store(dirTree.dataArrayMap(arrayCfg).harmonize.local.get / s"${harmonizedBaseString}_snpLog.log"),
        forceA2 = store(dirTree.dataArrayMap(arrayCfg).harmonize.local.get / s"${harmonizedBaseString}.force_a2.txt")))

    case _ => None

  }

  val refVcf = inputType match {
    case "wgs_vcf" | "wes_vcf" => rawData.vcf
    case "gwas_vcf" | "gwas_plink" | "wgs_plink" | "wes_plink" => None
    case _ => throw new CfgException("invalid input type " + inputType)
  }

  val refPlink = inputType match {
    case "gwas_vcf" | "gwas_plink" =>
      Some(MultiPathPlink(
        base = MultiPath(
          local = Some(dirTree.dataArrayMap(arrayCfg).harmonize.local.get / refBaseString),
          google = projectConfig.hailCloud match {
            case true => Some(dirTree.dataArrayMap(arrayCfg).harmonize.google.get / refBaseString)
            case false => None
          }
        ),
        data = MultiSeqStore(
          local = Some(bedBimFam(dirTree.dataArrayMap(arrayCfg).harmonize.local.get / refBaseString)),
          google = projectConfig.hailCloud match {
            case true => Some(bedBimFam(dirTree.dataArrayMap(arrayCfg).harmonize.google.get / refBaseString))
            case false => None
          }
        )
      ))
    case "wgs_plink" | "wes_plink" => 
      Some(MultiPathPlink(
        base = MultiPath(
          local = Some(rawData.plink.get.base),
          google = projectConfig.hailCloud match {
            case true => Some(dirTree.dataGlobal.google.get / baseName)
            case false => None
          }
        ),
        data = MultiSeqStore(
          local = Some(rawData.plink.get.data),
          google = projectConfig.hailCloud match {
            case true => Some(bedBimFam(dirTree.dataGlobal.google.get / baseName))
            case false => None
          }
        )
      ))
    case "wgs_vcf" | "wes_vcf" => None
    case _ => throw new CfgException("invalid input type " + inputType)
  }

  val refData = RefData(
    plink = refPlink,
    vcf = refVcf,
    mtCheckpoint = projectConfig.hailCloud match { case false => Some(store(dirTree.dataArrayMap(arrayCfg).harmonize.local.get / s"${refBaseString}.mt.checkpoint")); case true => None },
    mtCheckpointGoogle = projectConfig.hailCloud match { case true => Some(store(dirTree.dataArrayMap(arrayCfg).harmonize.google.get / s"${refBaseString}.mt.checkpoint")); case false => None },
    mt = projectConfig.hailCloud match { case false => Some(store(dirTree.dataArrayMap(arrayCfg).harmonize.local.get / s"${refBaseString}.mt")); case true => None },
    mtGoogle = projectConfig.hailCloud match { case true => Some(store(dirTree.dataArrayMap(arrayCfg).harmonize.google.get / s"${refBaseString}.mt")); case false => None },
    hailLog = store(dirTree.dataArrayMap(arrayCfg).harmonize.local.get / s"${refBaseString}.hail.log"),
    hailLogGoogle = projectConfig.hailCloud match { case true => Some(store(dirTree.dataArrayMap(arrayCfg).harmonize.google.get / s"${refBaseString}.hail.log")); case false => None },
    variantMetrics = store(dirTree.dataArrayMap(arrayCfg).harmonize.local.get / s"${refBaseString}.variant.metrics.tsv.bgz"),
    variantMetricsGoogle = projectConfig.hailCloud match { case true => Some(store(dirTree.dataArrayMap(arrayCfg).harmonize.google.get / s"${refBaseString}.variant.metrics.tsv.bgz")); case false => None },
    sitesVcf = store(dirTree.dataArrayMap(arrayCfg).annotate.local.get / s"${refBaseString}.sites_only.vcf.bgz"),
    sitesVcfGoogle = projectConfig.hailCloud match { case true => Some(store(dirTree.dataArrayMap(arrayCfg).annotate.google.get / s"${refBaseString}.sites_only.vcf.bgz")); case false => None },
    annotations = store(dirTree.dataArrayMap(arrayCfg).annotate.local.get / s"${refBaseString}.annotations.bgz"),
    annotationWarnings = store(dirTree.dataArrayMap(arrayCfg).annotate.local.get / s"${refBaseString}.annotations.warnings"))

  val imputeData = ImputeData(
    data = bedBimFam(dirTree.dataArrayMap(arrayCfg).impute.local.get / imputeBaseString),
    base = dirTree.dataArrayMap(arrayCfg).impute.local.get / imputeBaseString)

  val filteredData = FilteredData(
    variantMetrics = store(dirTree.dataArrayMap(arrayCfg).sampleqc.local.get / s"${filteredBaseString}.variant.metrics.tsv.bgz"),
    variantMetricsGoogle = projectConfig.hailCloud match { case true => Some(store(dirTree.dataArrayMap(arrayCfg).sampleqc.google.get / s"${filteredBaseString}.variant.metrics.tsv.bgz")); case false => None },
    plink = MultiPathPlink(base = MultiPath(local = Some(dirTree.dataArrayMap(arrayCfg).sampleqc.local.get / filteredBaseString), google = projectConfig.hailCloud match { case true => Some(dirTree.dataArrayMap(arrayCfg).sampleqc.google.get / filteredBaseString); case false => None }), data = MultiSeqStore(local = Some(bedBimFam(dirTree.dataArrayMap(arrayCfg).sampleqc.local.get / filteredBaseString)), google = projectConfig.hailCloud match { case true => Some(bedBimFam(dirTree.dataArrayMap(arrayCfg).sampleqc.google.get / filteredBaseString)); case false => None })),
    hailLog = store(dirTree.dataArrayMap(arrayCfg).sampleqc.local.get / s"${filteredBaseString}.hail.log"),
    hailLogGoogle = projectConfig.hailCloud match { case true => Some(store(dirTree.dataArrayMap(arrayCfg).sampleqc.google.get / s"${filteredBaseString}.hail.log")); case false => None },
    pruneIn = store(dirTree.dataArrayMap(arrayCfg).sampleqc.local.get / s"${filteredBaseString}.prune.in"))

  val prunedData = PrunedData(
    plink = Plink(base = dirTree.dataArrayMap(arrayCfg).sampleqc.local.get / prunedBaseString, data = bedBimFam(dirTree.dataArrayMap(arrayCfg).sampleqc.local.get / prunedBaseString)),
    bimGoogle = projectConfig.hailCloud match { case true => Some(store(dirTree.dataArrayMap(arrayCfg).sampleqc.google.get / s"${prunedBaseString}.bim")); case false => None })

  val kinshipData = KinshipData(
    base = dirTree.dataArrayMap(arrayCfg).kinship.local.get / kinshipBaseString,
    log = store(dirTree.dataArrayMap(arrayCfg).kinship.local.get / s"${kinshipBaseString}.log"),
    kin0 = store(dirTree.dataArrayMap(arrayCfg).kinship.local.get / s"${kinshipBaseString}.kin0"),
    famSizes = store(dirTree.dataArrayMap(arrayCfg).kinship.local.get / s"${kinshipBaseString}.famsizes.tsv"))

  val ref1kgData = Ref1kgData(
    plink = MultiPathPlink(base = MultiPath(local = Some(dirTree.dataArrayMap(arrayCfg).ancestry.local.get / ref1kgBaseString), google = projectConfig.hailCloud match { case true => Some(dirTree.dataArrayMap(arrayCfg).ancestry.google.get / ref1kgBaseString); case false => None }), data = MultiSeqStore(local = Some(bedBimFam(dirTree.dataArrayMap(arrayCfg).ancestry.local.get / ref1kgBaseString)), google = projectConfig.hailCloud match { case true => Some(bedBimFam(dirTree.dataArrayMap(arrayCfg).ancestry.google.get / ref1kgBaseString)); case false => None })),
    hailLog = store(dirTree.dataArrayMap(arrayCfg).ancestry.local.get / s"${ref1kgBaseString}.hail.log"),
    hailLogGoogle = projectConfig.hailCloud match { case true => Some(store(dirTree.dataArrayMap(arrayCfg).ancestry.google.get / s"${ref1kgBaseString}.hail.log")); case false => None },
    kgSamples = store(dirTree.dataArrayMap(arrayCfg).ancestry.local.get / s"${ref1kgBaseString}.kgsamples.tsv"),
    kgSamplesGoogle = projectConfig.hailCloud match { case true => Some(store(dirTree.dataArrayMap(arrayCfg).ancestry.google.get / s"${ref1kgBaseString}.kgsamples.tsv")); case false => None },
    gds = store(dirTree.dataArrayMap(arrayCfg).ancestry.local.get / s"${ref1kgBaseString}.gds"))

  val ancestryData = AncestryData(
    inferred = store(dirTree.dataArrayMap(arrayCfg).ancestry.local.get / s"${ancestryBaseString}.inferred.tsv"))

  val ancestryPcaData = AncestryPcaData(
    base = dirTree.dataArrayMap(arrayCfg).ancestry.local.get / ancestryPcaBaseString,
    log = store(dirTree.dataArrayMap(arrayCfg).ancestry.local.get / s"${ancestryPcaBaseString}.log"),
    scores = store(dirTree.dataArrayMap(arrayCfg).ancestry.local.get / s"${ancestryPcaBaseString}.scores.tsv"),
    eigenVecs = store(dirTree.dataArrayMap(arrayCfg).ancestry.local.get / s"${ancestryPcaBaseString}.eigenvecs.tsv"),
    loadings = store(dirTree.dataArrayMap(arrayCfg).ancestry.local.get / s"${ancestryPcaBaseString}.loadings.tsv"),
    eigenVals = store(dirTree.dataArrayMap(arrayCfg).ancestry.local.get / s"${ancestryPcaBaseString}.eigenvals.txt"),
    pve = store(dirTree.dataArrayMap(arrayCfg).ancestry.local.get / s"${ancestryPcaBaseString}.pve.txt"),
    meansd = store(dirTree.dataArrayMap(arrayCfg).ancestry.local.get / s"${ancestryPcaBaseString}.meansd.tsv"),
    plots = store(dirTree.dataArrayMap(arrayCfg).ancestry.local.get / s"${ancestryPcaBaseString}.plots.pdf"))
  
  val ancestryClusterData = AncestryClusterData(
    base = dirTree.dataArrayMap(arrayCfg).ancestry.local.get / ancestryClusterBaseString,
    log = store(dirTree.dataArrayMap(arrayCfg).ancestry.local.get / s"${ancestryClusterBaseString}.log"),
    fet = store(dirTree.dataArrayMap(arrayCfg).ancestry.local.get / s"${ancestryClusterBaseString}.fet.1"),
    clu = store(dirTree.dataArrayMap(arrayCfg).ancestry.local.get / s"${ancestryClusterBaseString}.clu.1"),
    klg = store(dirTree.dataArrayMap(arrayCfg).ancestry.local.get / s"${ancestryClusterBaseString}.klg.1"),
    plots = store(dirTree.dataArrayMap(arrayCfg).ancestry.local.get / s"${ancestryClusterBaseString}.plots.pdf"),
    centerPlots = store(dirTree.dataArrayMap(arrayCfg).ancestry.local.get / s"${ancestryClusterBaseString}.plots.centers.pdf"),
    no1kgPlots = store(dirTree.dataArrayMap(arrayCfg).ancestry.local.get / s"${ancestryClusterBaseString}.plots.no1kg.pdf"),
    xtab = store(dirTree.dataArrayMap(arrayCfg).ancestry.local.get / s"${ancestryClusterBaseString}.xtab"),
    groups = store(dirTree.dataArrayMap(arrayCfg).ancestry.local.get / s"${ancestryClusterBaseString}.groups.tsv"))

  val pcaData = PcaData(
    log = store(dirTree.dataArrayMap(arrayCfg).pca.local.get / s"${pcaBaseString}.log"),
    scores = store(dirTree.dataArrayMap(arrayCfg).pca.local.get / s"${pcaBaseString}.scores.tsv"),
    eigenVecs = store(dirTree.dataArrayMap(arrayCfg).pca.local.get / s"${pcaBaseString}.eigenvecs.tsv"),
    loadings = store(dirTree.dataArrayMap(arrayCfg).pca.local.get / s"${pcaBaseString}.loadings.tsv"),
    eigenVals = store(dirTree.dataArrayMap(arrayCfg).pca.local.get / s"${pcaBaseString}.eigenvals.txt"),
    pve = store(dirTree.dataArrayMap(arrayCfg).pca.local.get / s"${pcaBaseString}.pve.txt"),
    meansd = store(dirTree.dataArrayMap(arrayCfg).pca.local.get / s"${pcaBaseString}.meansd.tsv"))

  val sexcheckData = SexcheckData(
    sexcheck = store(dirTree.dataArrayMap(arrayCfg).sexcheck.local.get / s"${sampleQcBaseString}.sexcheck.tsv"),
    sexcheckGoogle = projectConfig.hailCloud match { case true => Some(store(dirTree.dataArrayMap(arrayCfg).sexcheck.google.get / s"${sampleQcBaseString}.sexcheck.tsv")); case false => None },
    problems = store(dirTree.dataArrayMap(arrayCfg).sexcheck.local.get / s"${sampleQcBaseString}.sexcheck.problems.tsv"),
    problemsGoogle = projectConfig.hailCloud match { case true => Some(store(dirTree.dataArrayMap(arrayCfg).sexcheck.google.get / s"${sampleQcBaseString}.sexcheck.problems.tsv")); case false => None },
    hailLog = store(dirTree.dataArrayMap(arrayCfg).sexcheck.local.get / s"${sampleQcBaseString}.sexcheck.hail.log"),
    hailLogGoogle = projectConfig.hailCloud match { case true => Some(store(dirTree.dataArrayMap(arrayCfg).sexcheck.google.get / s"${sampleQcBaseString}.sexcheck.hail.log")); case false => None })

  val sampleQcData = SampleQcData(
    stats = store(dirTree.dataArrayMap(arrayCfg).metrics.local.get / s"${sampleQcBaseString}.stats.tsv"),
    statsGoogle = projectConfig.hailCloud match { case true => Some(store(dirTree.dataArrayMap(arrayCfg).metrics.google.get / s"${sampleQcBaseString}.stats.tsv")); case false => None },
    hailLog = store(dirTree.dataArrayMap(arrayCfg).metrics.local.get / s"${sampleQcBaseString}.stats.hail.log"),
    hailLogGoogle = projectConfig.hailCloud match { case true => Some(store(dirTree.dataArrayMap(arrayCfg).metrics.google.get / s"${sampleQcBaseString}.stats.hail.log")); case false => None },
    statsAdj = store(dirTree.dataArrayMap(arrayCfg).metrics.local.get / s"${sampleQcBaseString}.stats.adj.tsv"),
    corrPlots = store(dirTree.dataArrayMap(arrayCfg).metrics.local.get / s"${sampleQcBaseString}.corr.pdf"),
    boxPlots = store(dirTree.dataArrayMap(arrayCfg).metrics.local.get / s"${sampleQcBaseString}.boxplots.pdf"),
    discreteness = store(dirTree.dataArrayMap(arrayCfg).metrics.local.get / s"${sampleQcBaseString}.discreteness.txt"),
    pcaLoadings = store(dirTree.dataArrayMap(arrayCfg).metrics.local.get / s"${sampleQcBaseString}.pca.loadings.tsv"),
    pcaPlots = store(dirTree.dataArrayMap(arrayCfg).metrics.local.get / s"${sampleQcBaseString}.pca.plots.pdf"),
    pcaScores = store(dirTree.dataArrayMap(arrayCfg).metrics.local.get / s"${sampleQcBaseString}.pca.scores.tsv"),
    outliers = store(dirTree.dataArrayMap(arrayCfg).metrics.local.get / s"${sampleQcBaseString}.outliers.tsv"),
    incompleteObs = store(dirTree.dataArrayMap(arrayCfg).metrics.local.get / s"${sampleQcBaseString}.incomplete_obs.tsv"),
    metricPlots = store(dirTree.dataArrayMap(arrayCfg).metrics.local.get / s"${sampleQcBaseString}.metricplots.pdf"))

  val sampleQcPcaClusterData = SampleQcPcaClusterData(
    base = dirTree.dataArrayMap(arrayCfg).metrics.local.get / s"${sampleQcBaseString}.pca.cluster",
    fet = store(dirTree.dataArrayMap(arrayCfg).metrics.local.get / s"${sampleQcBaseString}.pca.cluster.fet.1"),
    clu = store(dirTree.dataArrayMap(arrayCfg).metrics.local.get / s"${sampleQcBaseString}.pca.cluster.clu.1"),
    klg = store(dirTree.dataArrayMap(arrayCfg).metrics.local.get / s"${sampleQcBaseString}.pca.cluster.klg.1"),
    log = store(dirTree.dataArrayMap(arrayCfg).metrics.local.get / s"${sampleQcBaseString}.pca.cluster.log"),
    outliers = store(dirTree.dataArrayMap(arrayCfg).metrics.local.get / s"${sampleQcBaseString}.pca.cluster.outliers.tsv"),
    plots = store(dirTree.dataArrayMap(arrayCfg).metrics.local.get / s"${sampleQcBaseString}.pca.cluster.plots.pdf"),
    xtab = store(dirTree.dataArrayMap(arrayCfg).metrics.local.get / s"${sampleQcBaseString}.pca.cluster.xtab"))

  val sampleQcMetricClusterData = arrayCfg.sampleQcMetrics.map { metric =>
  
      metric -> SampleQcMetricClusterData(
        base = dirTree.dataArrayMap(arrayCfg).metrics.local.get / s"${sampleQcBaseString}.${metric}.cluster",
        fet = store(dirTree.dataArrayMap(arrayCfg).metrics.local.get / s"${sampleQcBaseString}.${metric}.cluster.fet.1"),
        clu = store(dirTree.dataArrayMap(arrayCfg).metrics.local.get / s"${sampleQcBaseString}.${metric}.cluster.clu.1"),
        klg = store(dirTree.dataArrayMap(arrayCfg).metrics.local.get / s"${sampleQcBaseString}.${metric}.cluster.klg.1"),
        log = store(dirTree.dataArrayMap(arrayCfg).metrics.local.get / s"${sampleQcBaseString}.${metric}.cluster.log"))

  }.toMap

  val filterQc = FilterQc(
    samplesExclude = store(dirTree.dataArrayMap(arrayCfg).filterQc.local.get / s"${filterQcBaseString}.samples.exclude.txt"),
    samplesExcludeGoogle = projectConfig.hailCloud match { case true => Some(store(dirTree.dataArrayMap(arrayCfg).filterQc.google.get / s"${filterQcBaseString}.samples.exclude.txt")); case false => None },
	samplesRestore = store(dirTree.dataArrayMap(arrayCfg).filterQc.local.get / s"${filterQcBaseString}.samples.restore.tbl"))

  val filterPostQc = FilterPostQc(
    samplesStats = store(dirTree.dataArrayMap(arrayCfg).filterPostQc.local.get / s"${filterPostQcBaseString}.samples.stats.tsv.bgz"),
    samplesExclude = store(dirTree.dataArrayMap(arrayCfg).filterPostQc.local.get / s"${filterPostQcBaseString}.samples.exclude.txt"),
    samplesStatsGoogle = projectConfig.hailCloud match { case true => Some(store(dirTree.dataArrayMap(arrayCfg).filterPostQc.google.get / s"${filterPostQcBaseString}.samples.stats.tsv.bgz")); case false => None },
    samplesExcludeGoogle = projectConfig.hailCloud match { case true => Some(store(dirTree.dataArrayMap(arrayCfg).filterPostQc.google.get / s"${filterPostQcBaseString}.samples.exclude.txt")); case false => None },
    variantsStats = store(dirTree.dataArrayMap(arrayCfg).filterPostQc.local.get / s"${filterPostQcBaseString}.variants.stats.tsv.bgz"),
    variantsExclude = store(dirTree.dataArrayMap(arrayCfg).filterPostQc.local.get / s"${filterPostQcBaseString}.variants.exclude.txt"),
    variantsStatsGoogle = projectConfig.hailCloud match { case true => Some(store(dirTree.dataArrayMap(arrayCfg).filterPostQc.google.get / s"${filterPostQcBaseString}.variants.stats.tsv.bgz")); case false => None },
    variantsExcludeGoogle = projectConfig.hailCloud match { case true => Some(store(dirTree.dataArrayMap(arrayCfg).filterPostQc.google.get / s"${filterPostQcBaseString}.variants.exclude.txt")); case false => None },
    hailLog = store(dirTree.dataArrayMap(arrayCfg).filterPostQc.local.get / s"${filterPostQcBaseString}.hail.log"),
    hailLogGoogle = projectConfig.hailCloud match { case true => Some(store(dirTree.dataArrayMap(arrayCfg).filterPostQc.google.get / s"${filterPostQcBaseString}.hail.log")); case false => None })

  val cleanData = projectConfig.exportCleanData match {

    case true =>

      Some(CleanData(
        vcf = Some(MultiPathVcf(
          base = MultiPath(local = Some(dirTree.dataArrayMap(arrayCfg).clean.local.get / cleanBaseString), google = Some(dirTree.dataArrayMap(arrayCfg).clean.google.get / cleanBaseString)),
          data = MultiStore(local = Some(store(dirTree.dataArrayMap(arrayCfg).clean.local.get / s"${cleanBaseString}.vcf.bgz")), google = Some(store(dirTree.dataArrayMap(arrayCfg).clean.google.get / s"${cleanBaseString}.vcf.bgz"))),
          tbi = MultiStore(local = Some(store(dirTree.dataArrayMap(arrayCfg).clean.local.get / s"${cleanBaseString}.vcf.bgz.tbi")), google = None)
        )),
        hailLog = store(dirTree.dataArrayMap(arrayCfg).clean.local.get / s"${cleanBaseString}.hail.log"),
        hailLogGoogle = projectConfig.hailCloud match { case true => Some(store(dirTree.dataArrayMap(arrayCfg).clean.google.get / s"${cleanBaseString}.hail.log")); case false => None }
      ))

    case _ => None

  }

  arrayCfg -> Array(
    rawData = rawData,
    preparedData = preparedData,
    annotatedData = annotatedData,
    annotatedChrData = annotatedChrData,
    harmonizedData = harmonizedData,
    refData = refData,
    imputeData = imputeData,
    filteredData = filteredData,
    prunedData = prunedData,
    kinshipData = kinshipData,
    ref1kgData = ref1kgData,
    ancestryData = ancestryData,
    ancestryPcaData = ancestryPcaData,
    ancestryClusterData = ancestryClusterData,
    pcaData = pcaData,
    sexcheckData = sexcheckData,
    sampleQcData = sampleQcData,
    sampleQcPcaClusterData = sampleQcPcaClusterData,
    sampleQcMetricClusterData = sampleQcMetricClusterData,
    filterQc = filterQc,
    filterPostQc = filterPostQc,
    cleanData = cleanData)

}.toMap
