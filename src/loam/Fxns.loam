import scala.util.{Try, Success, Failure}
import scala.util.control.NonFatal
import java.nio.file.{Paths, Files}
import scala.sys.process._

final case class CfgException(s: String) extends Exception(s)

trait Debug{
  def debugVars(): Any = {
    val vars = this.getClass.getDeclaredFields
    val name = this.getClass.getName.split("\\$")(1)
    for(v <- vars) {
      v.setAccessible(true)
      println("Class: " + name + " Field: " + v.getName() + " => " + v.get(this))
    }
  }
}

def requiredStr(config: loamstream.conf.DataConfig, field: String, regex: String = ".*", default: Option[String] = None): String = {
  Try(config.getStr(field)) match {
    case Success(o) =>
      o.matches(regex) match {
        case false => throw new CfgException("requiredStr: field " + field + " value " + o + " does not match regex format " + regex)
        case true  => o
      }
    case Failure(NonFatal(e)) => 
      default match {
        case Some(s) => s
        case None    => throw new CfgException("requiredStr: field '" + field + "' not found")
      }
    case Failure(_)           => throw new CfgException("requiredStr: field '" + field + "' fatal error")
  }
}

def optionalStr(config: loamstream.conf.DataConfig, field: String, regex: String = ".*"): Option[String] = {
  Try(config.getStr(field)) match {
    case Success(o)           =>
      o.matches(regex) match {
        case false => throw new CfgException("optionalStr: field " + field + " value " + o + " does not match regex format " + regex)
        case true  => Some(o)
      }
    case Failure(NonFatal(e)) => None
    case Failure(_)           => throw new CfgException("optionalStr: field '" + field + "' fatal error")
  }
}

def getStrOrBlank(config: loamstream.conf.DataConfig, field: String, regex: String = ".*"): String = {
  Try(config.getStr(field)) match {
    case Success(o)           =>
      o.matches(regex) match {
        case false => throw new CfgException("getStrOrBlank: field " + field + " value " + o + " does not match regex format " + regex)
        case true  => o
      }
    case Failure(NonFatal(e)) => ""
    case Failure(_)           => throw new CfgException("getStrOrBlank: field '" + field + "' fatal error")
  }
}

def requiredInt(config: loamstream.conf.DataConfig, field: String, default: Option[Int] = None): Int = {
  Try(config.getInt(field)) match {
    case Success(o) => o
    case Failure(NonFatal(e)) =>
      default match {
        case Some(i) => i
        case None    => throw new CfgException("requiredInt: field '" + field + "' not found")
      }
    case Failure(_)           => throw new CfgException("requiredInt: field '" + field + "' fatal error")
  }
}

def optionalInt(config: loamstream.conf.DataConfig, field: String, regex: String = ".*"): Option[Int] = {
  Try(config.getInt(field)) match {
    case Success(o)           =>
      o.toString.matches(regex) match {
        case false => throw new CfgException("optionalInt: field " + field + " value " + o.toString + " does not match regex format " + regex)
        case true  => Some(o)
      }
    case Failure(NonFatal(e)) => None
    case Failure(_)           => throw new CfgException("optionalInt: field '" + field + "' fatal error")
  }
}

def requiredBool(config: loamstream.conf.DataConfig, field: String, default: Option[Boolean] = None): Boolean = {
  Try(config.getBool(field)) match {
    case Success(o) => o
    case Failure(NonFatal(e)) =>
      default match {
        case Some(i) => i
        case None    => throw new CfgException("requiredBool: field '" + field + "' not found")
      }
    case Failure(_)           => throw new CfgException("requiredBool: field '" + field + "' fatal error")
  }
}

def requiredStrList(config: loamstream.conf.DataConfig, field: String, regex: String = ".*" , default: Option[Seq[String]] = None): Seq[String] = {
  Try(config.getStrList(field)) match {
    case Success(o)           =>
      for ( x <- o ) {
        x.toString.matches(regex) match {
          case false => throw new CfgException("requiredStrList: field " + field + " value " + x.toString + " does not match regex format " + regex)
          case true  => ()
        }
      }
      o.size match {
        case x if(x >= 1) => o
        case _ => throw new CfgException("requiredStrList: field " + field + " list must have at least 1 element")
      }
    case Failure(NonFatal(e)) => 
      default match {
        case Some(s) =>
          s.toString.matches(regex) match {
            case false => throw new CfgException("requiredStrList: field " + field + " value " + s.toString + " does not match regex format " + regex)
            case true  => s
          }
        case None    => throw new CfgException("requiredStrList: field '" + field + "' not found")
      }
    case Failure(_)           => throw new CfgException("requiredStrList: field '" + field + "' fatal error")
  }
}

def optionalStrList(config: loamstream.conf.DataConfig, field: String): Option[Seq[String]] = {
  Try(config.getStrList(field)) match {
    case Success(o)           => 
      o.size match {
        case x if(x >= 1) => Some(o)
        case _ => None
      }
    case Failure(NonFatal(e)) => None
    case Failure(_)           => throw new CfgException("optionalStrList: field '" + field + "' fatal error")
  }
}

def requiredObj(config: loamstream.conf.DataConfig, field: String, default: Option[loamstream.conf.DataConfig] = None): loamstream.conf.DataConfig = {
  Try(config.getObj(field)) match {
    case Success(o)           => o
    case Failure(NonFatal(e)) => 
      default match {
        case Some(s) => s
        case None    => throw new CfgException("requiredObj: field '" + field + "' not found")
      }
    case Failure(_)           => throw new CfgException("requiredObj: field '" + field + "' fatal error")
  }
}

def optionalObj(config: loamstream.conf.DataConfig, field: String): Option[loamstream.conf.DataConfig] = {
  Try(config.getObj(field)) match {
    case Success(o)           => Some(o)
    case Failure(NonFatal(e)) => None
    case Failure(_)           => throw new CfgException("optionalObj: field '" + field + "' fatal error")
  }
}

def requiredObjList(config: loamstream.conf.DataConfig, field: String, default: Option[Seq[loamstream.conf.DataConfig]] = None): Seq[loamstream.conf.DataConfig] = {
  Try(config.getObjList(field)) match {
    case Success(o)           => o
    case Failure(NonFatal(e)) => 
      default match {
        case Some(s) => s
        case None    => throw new CfgException("requiredObjList: field '" + field + "' not found")
      }
    case Failure(_)           => throw new CfgException("requiredObjList: field '" + field + "' fatal error")
  }
}

def checkPath(s: String): String = {
  Files.exists(Paths.get(s)) match {
    case false => throw new CfgException("checkPath: " + s + " not found")
    case true  => s
  }
}

def initDir(s: String): String = {
  val dir = Paths.get(s)
  Files.exists(dir) match {
    case false =>
      Files.createDirectory(dir)
      s
    case true  => s
  }
}

def expandChrList(chrs: Seq[String]): Seq[String] = {
  val y = for {
    x <- chrs
  } yield {
    x.matches("([1-9]|1[0-9]|2[0-1])-([2-9]|1[0-9]|2[0-2])") match {
      case true => (x.split("-").head.toInt to x.split("-").tail.head.toInt).toList.map(_.toString)
      case false => Seq(x)
    }
  }
  y.flatten
}

def checkPlinkPath(s: String): String = {
  val bed = Files.exists(Paths.get(s + ".bed")) 
  val bim = Files.exists(Paths.get(s + ".bim")) 
  val fam = Files.exists(Paths.get(s + ".fam"))
  val bedMessage = bed match {
    case true => s + ".bed exists"
	case false => s + ".bed does not exist"
  }
  val bimMessage = bim match {
    case true => s + ".bim exists"
	case false => s + ".bim does not exist"
  }
  val famMessage = fam match {
    case true => s + ".fam exists"
	case false => s + ".fam does not exist"
  }
  Seq(bed, bim, fam).contains(false) match {
    case true => 
	  throw new CfgException("checkPlinkPath: files missing from Plink fileset " + s + "\n  " + s"${bedMessage}\n  ${bimMessage}\n  ${famMessage}")
    case false => s
  }
}

def checkURI(s: String): Int = {
  val cmd = s"gsutil -m ls ${s}"
  cmd.!
}

def intervalToExpression(s: String, i: String): String = {
  val intervals = i.replace(" ","").split("\\+")
  val expressions = {
    for {
      interval <- intervals
    } yield {
      val lowerBound = interval(0)
      val upperBound = interval.takeRight(1)
      val min = interval.drop(1).dropRight(1).split(",")(0)
      val max = interval.drop(1).dropRight(1).split(",").size match {
        case 1 => ""
        case _ => interval.drop(1).dropRight(1).split(",")(1)
      }
      (min, max) match {
        case ("", _) | (_, "") => ()
        case (v1, v2) if v2 <= v1 => throw new CfgException("intervalToExpression: user supplied interval for " + s + ", " + i + ", is invalid due to max <= min")
        case _ => ()
      }
      val lowerInequality = lowerBound match {
        case '[' => ">="
        case '(' => ">"
        case _ => throw new CfgException("intervalToExpression: user supplied interval for " + s + " contains unsupported symbol " + lowerBound + s"... [, ], (, and ) are currently supported")
      }
      val upperInequality = upperBound match {
        case "]" => "<="
        case ")" => "<"
        case _ => throw new CfgException("intervalToExpression: user supplied interval for " + s + " contains unsupported symbol " + upperBound + s"... [, ], (, and ) are currently supported")
      }
      (min, max) match {
        case ("", v) => s + " " + upperInequality + " " + max
        case (v, "") => s + " " + lowerInequality + " " + min
        case _ => "(" + s + " " + lowerInequality + " " + min + ") & (" + s + " " + upperInequality + " " + max + ")"
      }
    }
  }
  expressions.size match {
    case x if x > 1 => expressions.map(e => "(" + e + ")").mkString(" | ")
    case _ => expressions.mkString("")
  }
}

def booleanToExpression(s: String, i: String): String = {
  i match {
    case "true" => s + " == True"
    case "false" => s + " == False"
    case _ => throw new CfgException("booleanToExpression: user supplied value " + i + " for " + s + " is not currently supported... true and false are currently supported")
  }
}

def categoricalToExpression(s: String, i: Seq[String]): String = {
  s match {
    case "chr" =>
      "hl.literal({'" + expandChrList(i).mkString("','") + "'}).contains(" + s + ")"
    case _ =>
      "hl.literal({'" + i.mkString("','") + "'}).contains(" + s + ")"
  }
}
