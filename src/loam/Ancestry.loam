/**
  * Ancestry PCA Step
  *  Description: Calculate PCs combined with 1KG Phase 3 Purcell 5k data
  *  Requires: Hail, R, ${utils.r.rPlotAncestryPca}
  *  Notes:
  *     To perform ancestry inference and clustering with 1KG data, we must combine on common variants with reference data (clustering does not work when only using PCA loadings and projecting)
  */
import ProjectConfig._
import ArrayStores._
import ProjectStores._

def AncestryPca(array: ConfigArray): Unit = {

  projectConfig.hailCloud match {

    case true =>

      google {
      
        hail"""${utils.python.pyHailAncestryPcaMerge1kg} --
          --hail-utils ${ProjectStores.hailUtilsGoogle.get}
          --reference-genome ${projectConfig.referenceGenome}
          --mt-in ${arrayStores(array).refData.mtGoogle.get}
          --kg-vcf-in ${ProjectStores.kgPurcellVcfGoogle.get}
          --kg-sample ${ProjectStores.kgSampleGoogle.get}
          --plink-out ${arrayStores(array).ref1kgData.plink.base.google.get}
          --kg-samples-out ${arrayStores(array).ref1kgData.kgSamplesGoogle.get}
          --cloud
          --log ${arrayStores(array).ref1kgData.hailLogGoogle.get}"""
          .in(ProjectStores.hailUtilsGoogle.get, arrayStores(array).refData.mtGoogle.get, ProjectStores.kgPurcellVcfGoogle.get, ProjectStores.kgSampleGoogle.get)
          .out(arrayStores(array).ref1kgData.plink.data.google.get :+ arrayStores(array).ref1kgData.kgSamplesGoogle.get :+ arrayStores(array).ref1kgData.hailLogGoogle.get)
          .tag(s"${arrayStores(array).ref1kgData.plink.base.local.get}.pyHailAncestryPcaMerge1kg".split("/").last)
      
      }
      
      local {
      
        googleCopy(arrayStores(array).ref1kgData.plink.data.google.get, arrayStores(array).ref1kgData.plink.data.local.get)
        googleCopy(arrayStores(array).ref1kgData.kgSamplesGoogle.get, arrayStores(array).ref1kgData.kgSamples)
        googleCopy(arrayStores(array).ref1kgData.hailLogGoogle.get, arrayStores(array).ref1kgData.hailLog)
      
      }

    case false =>

      drmWith(imageName = s"${utils.image.imgHail}", cores = projectConfig.resources.ancestryPcaHail.cpus, mem = projectConfig.resources.ancestryPcaHail.mem, maxRunTime = projectConfig.resources.ancestryPcaHail.maxRunTime) {

        cmd"""${utils.binary.binPython} ${utils.python.pyHailAncestryPcaMerge1kg}
          --reference-genome ${projectConfig.referenceGenome}
          --mt-in ${arrayStores(array).refData.mt.get}
          --kg-vcf-in ${ProjectStores.kgPurcellVcf}
          --kg-sample ${ProjectStores.kgSample}
          --plink-out ${arrayStores(array).ref1kgData.plink.base.local.get}
          --kg-samples-out ${arrayStores(array).ref1kgData.kgSamples}
          --log ${arrayStores(array).ref1kgData.hailLog}"""
          .in(arrayStores(array).refData.mt.get, ProjectStores.kgPurcellVcf, ProjectStores.kgSample)
          .out(arrayStores(array).ref1kgData.plink.data.local.get :+ arrayStores(array).ref1kgData.kgSamples :+ arrayStores(array).ref1kgData.hailLog)
          .tag(s"${arrayStores(array).ref1kgData.plink.base.local.get}".split("/").last)

      }

  }

  drmWith(imageName = s"${utils.image.imgFlashPca}", cores = projectConfig.resources.ancestryPcaFlashPca.cpus, mem = projectConfig.resources.ancestryPcaFlashPca.mem, maxRunTime = projectConfig.resources.ancestryPcaFlashPca.maxRunTime) {
  
    cmd"""${utils.binary.binFlashPca} --verbose
      --seed 1
      --numthreads ${projectConfig.resources.ancestryPcaFlashPca.cpus}
      --ndim 20
      --bfile ${arrayStores(array).ref1kgData.plink.base.local.get}
      --outpc ${arrayStores(array).ancestryPcaData.scores}
      --outvec ${arrayStores(array).ancestryPcaData.eigenVecs}
      --outload ${arrayStores(array).ancestryPcaData.loadings}
      --outval ${arrayStores(array).ancestryPcaData.eigenVals}
      --outpve ${arrayStores(array).ancestryPcaData.pve}
      --outmeansd ${arrayStores(array).ancestryPcaData.meansd}
      > ${arrayStores(array).ancestryPcaData.log}"""
      .in(arrayStores(array).ref1kgData.plink.data.local.get)
      .out(arrayStores(array).ancestryPcaData.log, arrayStores(array).ancestryPcaData.scores, arrayStores(array).ancestryPcaData.eigenVecs, arrayStores(array).ancestryPcaData.loadings, arrayStores(array).ancestryPcaData.eigenVals, arrayStores(array).ancestryPcaData.pve, arrayStores(array).ancestryPcaData.meansd)
      .tag(s"${arrayStores(array).ancestryPcaData.scores}".split("/").last)
  
  }

  drmWith(imageName = s"${utils.image.imgR}") {

    cmd"""${utils.binary.binRscript} --vanilla --verbose
      ${utils.r.rPlotAncestryPca}
      --id ${projectConfig.projectId}
      --update-pop ID POP ${arrayStores(array).ref1kgData.kgSamples}
      --update-group ID GROUP ${arrayStores(array).ref1kgData.kgSamples}
      --pca-scores ${arrayStores(array).ancestryPcaData.scores}
      --out ${arrayStores(array).ancestryPcaData.plots}"""
      .in(arrayStores(array).ref1kgData.kgSamples, arrayStores(array).ancestryPcaData.scores)
      .out(arrayStores(array).ancestryPcaData.plots)
      .tag(s"${arrayStores(array).ancestryPcaData.plots}".split("/").last)

  }

}
  
/**
  * Ancestry Cluster Step
  *  Description: Cluster with 1KG samples using Gaussian Mixture Modeling and infer ancestry
  *  Requires: Hail, R
  *  Notes:
  *     *.ancestry.inferred.tsv contains the final inferred ancestry for each sample, including OUTLIERS
  *     This file is array specific
  */

def AncestryCluster(array: ConfigArray): Unit = {

  drmWith(imageName = s"${utils.image.imgTools}") {

    cmd"""bash -c "(echo 20; sed '1d' ${arrayStores(array).ancestryPcaData.scores} | cut -f4- | sed 's/\t/ /g') > ${arrayStores(array).ancestryClusterData.fet}""""
      .in(arrayStores(array).ancestryPcaData.scores)
      .out(arrayStores(array).ancestryClusterData.fet)
      .tag(s"${arrayStores(array).ancestryClusterData.fet}".split("/").last)

  }

  drmWith(imageName = s"${utils.image.imgTools}", cores = projectConfig.resources.ancestryClusterKlustakwik.cpus, mem = projectConfig.resources.ancestryClusterKlustakwik.mem, maxRunTime = projectConfig.resources.ancestryClusterKlustakwik.maxRunTime) {
  
    cmd"""${utils.binary.binKlustakwik} ${arrayStores(array).ancestryClusterData.base} 1 -UseFeatures ${projectConfig.ancestryInferenceFeatures} -UseDistributional 0 > ${arrayStores(array).ancestryClusterData.log}"""
      .in(arrayStores(array).ancestryClusterData.fet)
      .out(arrayStores(array).ancestryClusterData.clu, arrayStores(array).ancestryClusterData.klg, arrayStores(array).ancestryClusterData.log)
      .tag(s"${arrayStores(array).ancestryClusterData.base}.binKlustakwik".split("/").last)

  }

  drmWith(imageName = s"${utils.image.imgR}") {
  
    cmd"""${utils.binary.binRscript} --vanilla --verbose
      ${utils.r.rPlotAncestryCluster}
      --pca-scores ${arrayStores(array).ancestryPcaData.scores}
      --cluster ${arrayStores(array).ancestryClusterData.clu}
      --sample-file ${ProjectStores.sampleFile}
      --project-id ${projectConfig.projectId}
      --sample-id ${projectConfig.sampleFileId}
      --sr-race ${projectConfig.sampleFileSrRace}
      --afr-codes "${projectConfig.sampleFileAFRCodes.mkString(",")}"
      --amr-codes "${projectConfig.sampleFileAMRCodes.mkString(",")}"
      --eur-codes "${projectConfig.sampleFileEURCodes.mkString(",")}"
      --eas-codes "${projectConfig.sampleFileEASCodes.mkString(",")}"
      --sas-codes "${projectConfig.sampleFileSASCodes.mkString(",")}"
      --cluster-plots ${arrayStores(array).ancestryClusterData.plots}
      --xtabs ${arrayStores(array).ancestryClusterData.xtab}
      --plots-centers ${arrayStores(array).ancestryClusterData.centerPlots}
      --cluster-groups ${arrayStores(array).ancestryClusterData.groups}
      --ancestry-inferred ${arrayStores(array).ancestryData.inferred}
      --cluster-plots-no1kg ${arrayStores(array).ancestryClusterData.no1kgPlots}"""
      .in(arrayStores(array).ancestryPcaData.scores, arrayStores(array).ancestryClusterData.clu, ProjectStores.sampleFile)
      .out(arrayStores(array).ancestryClusterData.plots, arrayStores(array).ancestryClusterData.xtab, arrayStores(array).ancestryClusterData.centerPlots, arrayStores(array).ancestryClusterData.groups, arrayStores(array).ancestryData.inferred, arrayStores(array).ancestryClusterData.no1kgPlots)
      .tag(s"${arrayStores(array).ancestryPcaData.scores}.rPlotAncestryCluster".split("/").last)

  }

}

/**
  * Merge Inferred Ancestry
  *  Description: Merge inferred ancestry from all arrays
  *  Requires: R
  *  Notes:
  */

def MergeInferredAncestry(): Unit = {

  val inferredList = projectConfig.Arrays.map(e => arrayStores(e).ancestryData.inferred).map(_.path).mkString(",")

  drmWith(imageName = s"${utils.image.imgR}") {
  
    cmd"""${utils.binary.binRscript} --vanilla --verbose
      ${utils.r.rAncestryClusterMerge}
      --ancestry-in $inferredList
      --out-table ${ProjectStores.ancestryInferred}
      --out-outliers ${ProjectStores.ancestryOutliers}"""
      .in(projectConfig.Arrays.map(e => arrayStores(e).ancestryData.inferred))
      .out(ProjectStores.ancestryInferred, ProjectStores.ancestryOutliers)
      .tag(s"${ProjectStores.ancestryInferred}".split("/").last)
  
  }

}
