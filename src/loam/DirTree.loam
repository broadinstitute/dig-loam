import java.io.{File, BufferedWriter, FileWriter}
import ProjectConfig._
import Collections._
import Stores._
import Fxns._

final case class DirTreeDataArray(
  base: MultiPath,
  prepare: MultiPath,
  harmonize: MultiPath,
  annotate: MultiPath,
  impute: MultiPath,
  sampleqc: MultiPath,
  kinship: MultiPath,
  ancestry: MultiPath,
  pca: MultiPath,
  sexcheck: MultiPath,
  metrics: MultiPath,
  filter: MultiPath,
  filterQc: MultiPath,
  filterPostQc: MultiPath,
  clean: MultiPath) extends Debug

final case class DirTreeDataCohort(
  base: MultiPath,
  filter: MultiPath) extends Debug

final case class DirTreeAnalysisModel(
  base: MultiPath,
  base_cohort: Option[MultiPath],
  base_meta: Option[MultiPath],
  base_merge: Option[MultiPath],
  merges: Map[ConfigMerge, MultiPath],
  metas: Map[ConfigMeta, MultiPath],
  cohorts: Map[ConfigCohort, MultiPath]) extends Debug

final case class DirTreeAnalysisPheno(
  base: MultiPath,
  models: Map[ConfigModel, DirTreeAnalysisModel]) extends Debug

final case class DirTree(
  base: MultiPath,
  data: MultiPath,
  dataArray: MultiPath,
  dataArrayMap: Map[ConfigArray, DirTreeDataArray],
  dataGlobal: MultiPath,
  dataGlobalAncestry: MultiPath,
  dataGlobalKinship: MultiPath,
  dataGlobalKinshipMap: Map[ConfigMeta, MultiPath],
  analysis: MultiPath,
  analysisPhenoMap: Map[ConfigPheno, DirTreeAnalysisPheno],
  report: MultiPath,
  reportQc: MultiPath,
  reportAnalysis: MultiPath,
  reportAnalysisMap: Map[ConfigReport, MultiPath]) extends Debug

def appendSubDir(msp: MultiPath, name: String): MultiPath = {
  MultiPath(
    local = Some(path(initDir(s"${msp.local.get}" + "/" + name))),
    google = projectConfig.hailCloud match {
      case true => Some(msp.google.get / name)
      case false => None
    }
  )
}

object DirTree {

  def initDirTree(cfg: ProjectConfig): DirTree = {

    val base = MultiPath(
      local = Some(path(initDir("loam_out"))),
      google = cfg.hailCloud match {
        case true => Some(cfg.cloudHome.get / "loam_out")
        case false => None
      }
    )

    val data = appendSubDir(base, "data")
    val dataArray = appendSubDir(data, "array")
    val dataGlobal = appendSubDir(data, "global")
    val dataGlobalAncestry = appendSubDir(dataGlobal, "ancestry")
    val dataGlobalKinship = appendSubDir(dataGlobal, "kinship")
    val analysis = appendSubDir(base, "analysis")
    val report = appendSubDir(base, "report")
    val reportQc = appendSubDir(report, "qc")
    val reportAnalysis = appendSubDir(report, "analysis")

    val dataArrayMap = cfg.Arrays.map { array =>
      val base = appendSubDir(dataArray, array.id)
      val sampleqc = appendSubDir(base, "sampleqc")
      val filter = appendSubDir(base, "filter")
      array -> DirTreeDataArray(
        base = base,
        prepare = appendSubDir(base, "prepare"),
        harmonize = appendSubDir(base, "harmonize"),
        annotate = appendSubDir(base, "annotate"),
        impute = appendSubDir(base, "impute"),
        sampleqc = sampleqc,
        kinship = appendSubDir(sampleqc, "kinship"),
        ancestry = appendSubDir(sampleqc, "ancestry"),
        pca = appendSubDir(sampleqc, "pca"),
        sexcheck = appendSubDir(sampleqc, "sexcheck"),
        metrics = appendSubDir(sampleqc, "metrics"),
        filter = filter,
        filterQc = appendSubDir(filter, "qc"),
        filterPostQc = appendSubDir(filter, "postqc"),
        clean = appendSubDir(base, "clean")
      )
    }.toMap

    val dataGlobalKinshipMap = projectConfig.Metas.map { meta =>
      meta -> appendSubDir(dataGlobalKinship, meta.id)
    }.toMap

    val analysisPhenoMap = projectConfig.Phenos.filter(e => projectConfig.Models.map(e => e.pheno).contains(e.id)).map { pheno =>

      val base_pheno = appendSubDir(analysis, pheno.id)

      pheno -> DirTreeAnalysisPheno(
        base = base_pheno,
        models = projectConfig.Models.filter(e => e.pheno == pheno.id).map { model =>
          val base_model = appendSubDir(base_pheno, model.id)
          val base_cohort = model.design match {
            case "strat" => Some(appendSubDir(base_model, "cohort"))
            case _ => None
          }
          val base_meta = model.design match {
            case "strat" => model.metas.size match { case 0 => None; case _ => Some(appendSubDir(base_model, "meta")) }
            case _ => None
          }
          val base_merge = model.design match {
            case "strat" => model.merges.size match { case 0 => None; case _ => Some(appendSubDir(base_model, "merge")) }
            case _ => None
          }
          model -> DirTreeAnalysisModel(
            base = base_model,
            base_cohort = base_cohort,
            base_meta = base_meta,
            base_merge = base_merge,
            merges = base_merge match {
              case Some(s) => 
                projectConfig.Merges.filter(e => model.merges.get.contains(e.id)).map { merge =>
                  merge -> appendSubDir(s, merge.id)
                }.toMap
              case None => Map[ConfigMerge, MultiPath]()
            },
            metas =  base_meta match {
              case Some(s) => 
                projectConfig.Metas.filter(e => model.metas.get.contains(e.id)).map { meta =>
                  meta -> appendSubDir(s, meta.id)
                }.toMap
              case None => Map[ConfigMeta, MultiPath]()
            },
            cohorts = base_cohort match {
              case Some(s) => 
                projectConfig.Cohorts.filter(e => model.cohorts.contains(e.id)).map { cohort =>
                  cohort -> appendSubDir(s, cohort.id)
                }.toMap
              case None => Map[ConfigCohort, MultiPath]()
            }
          )
        }.toMap
      )

    }.toMap
    
    val reportAnalysisMap = cfg.Reports.map { report =>
      report -> appendSubDir(reportAnalysis, report.id)
    }.toMap

    new DirTree(
      base = base,
      data = data,
      dataArray = dataArray,
      dataArrayMap = dataArrayMap,
      dataGlobal = dataGlobal,
      dataGlobalAncestry = dataGlobalAncestry,
      dataGlobalKinship = dataGlobalKinship,
      dataGlobalKinshipMap = dataGlobalKinshipMap,
      analysis = analysis,
      analysisPhenoMap = analysisPhenoMap,
      report = report,
      reportQc = reportQc,
      reportAnalysis = reportAnalysis,
      reportAnalysisMap = reportAnalysisMap
    )

  }

}

println("Initializing Directory Tree ...")
val dirTree = DirTree.initDirTree(projectConfig)
println("... Finished Initializing Directory Tree")

def writeConfig(cfg: ProjectConfig, utils: Utils): Any = {
  val f = new File(s"${dirTree.base.local.get}/cfg.objects")
  val bw = new BufferedWriter(new FileWriter(f))
  val objs = Seq(dirTree, cfg) ++ cfg.Arrays
  for ( o <- objs ) {
    val vars = o.getClass.getDeclaredFields
    val name = o.getClass.getName.split("\\$")(1)
    bw.write("Class: " + name + "\n")
    for ( v <- vars ) {
      v.setAccessible(true)
      bw.write("  " + v.getName() + " => " + v.get(o).toString + "\n")
    }
    bw.write("\n")
  }
  for ( o <- Seq(utils, utils.image, utils.binary, utils.python, utils.bash, utils.r, utils) ) {
    val vars = o.getClass.getDeclaredFields
    val name = o.getClass.getName.split("\\$")(1)
    bw.write("Class: " + name + "\n")
    for ( v <- vars ) {
      v.setAccessible(true)
      bw.write("  " + v.getName() + " => " + v.get(o).toString + "\n")
    }
    bw.write("\n")
  }
  bw.close()
}

writeConfig(projectConfig, utils)
