import scala.util.{Try, Success, Failure}
import scala.util.control.NonFatal
import java.nio.file.{Paths, Files}
import java.io.{File, BufferedWriter, FileWriter}

final case class CfgException(s: String) extends Exception(s)

trait Debug{
  def debugVars(): Any = {
    val vars = this.getClass.getDeclaredFields
    val name = this.getClass.getName.split("\\$")(1)
    for(v <- vars) {
      v.setAccessible(true)
      println("Class: " + name + " Field: " + v.getName() + " => " + v.get(this))
    }
  }
}

final case class MultiStrPath(
  local: String,
  google: String)

final case class Dir(
  base: MultiStrPath,
  data: MultiStrPath,
  kinship: MultiStrPath,
  ancestry: MultiStrPath,
  cloudShare: String,
  cloudHome: String) extends Debug

final case class MultiStore(
  local: Store,
  google: Store)

sealed trait GenotypeData

final case class Vcf(
  base: MultiStrPath,
  vcf: MultiStore) extends GenotypeData

final case class Plink(
  base: MultiStrPath,
  bed: MultiStore,
  bim: MultiStore,
  fam: MultiStore) extends GenotypeData

final case class Data(
  id: String,
  file: GenotypeData,
  basename: String,
  format: String,
  tech: String,
  desc: String,
  build: String,
  nAncPcs: Int,
  metrics: Seq[String],
  ancestryOutliersKeep: Option[Seq[String]],
  duplicatesKeep: Option[Seq[String]],
  famsizeKeep: Option[Seq[String]],
  sampleqcKeep: Option[Seq[String]],
  sexcheckKeep: Option[Seq[String]]) extends Debug

final case class Cfg(
  dir: Dir,
  id: String,
  regExcl: Option[String],
  genePos: String,
  aimRef: String,
  refSam: Store,
  refSamId: String,
  refSamPop: String,
  refSamGrp: String,
  refVcfs: Map[String, Store],
  refVcfsIDs: Map[String, Store],
  huRefs: Map[String, Store],
  pheno: Store,
  phenoStatus: String,
  phenoId: String,
  phenoSex: String,
  phenoRace: String,
  qcReportAuthors: Seq[String],
  analysisReportAuthors: Seq[String],
  analysisReportAcknowledgements: Seq[String],
  data: Seq[Data]) extends Debug
  
final case class Binary(
  gsutil: Path,
  gcloud: Path
  //liftOver: Path,
  //genotypeHarmonizer: Path,
  //king: Path,
  //plink: Path,
  //tabix: Path,
  //ghostscript: Path,
  //klustakwik: Path,
  //python: Path,
  //locuszoom: Path,
  //pdflatex: Path,
  //rscript: Path,
  ) extends Debug

final case class Python(
  hailLoad: Path
  //hailFilter: Path,
  //hailAncestryPcaMerge1kg: Path,
  //hailPcaMerge1kg: Path,
  //hailSampleqc: Path,
  //hailSexcheck: Path,
  //hailFilterFinal: Path,
  //hailListSamples: Path,
  //hailAssoc: Path,
  //hailMerge: Path,
  //hailMetaAnalysis: Path,
  //alignNon1kgVariants: Path,
  //qqPlot: Path,
  //mhtPlot: Path,
  //extractTopRegions: Path,
  //compileExclusions: Path,
  //generateReportHeader: Path,
  //generateQcReportIntro: Path,
  //generateQcReportData: Path,
  //generateQcReportAncestry: Path,
  //generateQcReportIbdSexcheck: Path,
  //generateQcReportSampleqc: Path,
  //generateQcReportVariantqc: Path,
  //generateQcReportBibliography: Path,
  //generateAnalysisReportIntro: Path,
  //generateAnalysisReportData: Path,
  //generateAnalysisReportStrategy: Path,
  //generateAnalysisReportPhenoSummary: Path,
  //generateAnalysisReportPhenoCalibration: Path,
  //generateAnalysisReportPhenoTopLoci: Path,
  //generateAnalysisReportPhenoKnownLoci: Path,
  //generateAnalysisReportBibliography: Path,
  //mergeVariantLists: Path,
  //top1000: Path,
  //addGeneAnnot: Path,
  //phenoDistPlot: Path
  ) extends Debug

final case class Bash(
  shTest: Path
  //regPlot: Path,
  //king: Path
  ) extends Debug

final case class R(
  rTest: Path
  //findBestDuplicateVariants: Path,
  //ancestryClusterMerge: Path,
  //ancestryClusterTable: Path,
  //calcKinshipFamSizes: Path,
  //pcair: Path,
  //plotAncestryPca: Path,
  //plotAncestryCluster: Path,
  //istatsPcsGmmClusterPlot: Path,
  //istatsAdjGmmPlotMetrics: Path,
  //calcIstatsAdj: Path,
  //istatsAdjPca: Path,
  //excludeCrossArray: Path,
  //generatePheno: Path,
  //variantsSummaryTable: Path,
  //upsetplotBimFam: Path,
  //makeOutlierTable: Path,
  //makeMetricDistPlot: Path,
  //makeSampleqcOutlierPlot: Path,
  //top20: Path,
  //top50Known: Path,
  //metaExclusionsTable: Path
  ) extends Debug
  
final case class Utils(
  binary: Binary,
  python: Python,
  bash: Bash,
  r: R) extends Debug

object Cfg{

  def requiredStr(config: loamstream.conf.DataConfig, field: String, regex: String = ".*", default: Option[String] = None): String = {
    Try(config.getStr(field)) match {
      case Success(o) =>
        o.matches(regex) match {
          case false => throw new CfgException("requiredStr: field " + field + " value " + o + " does not match regex format " + regex)
          case true  => o
        }
      case Failure(NonFatal(e)) => 
        default match {
          case Some(s) => s
          case None    => throw new CfgException("requiredStr: field '" + field + "' not found")
        }
      case Failure(_)           => throw new CfgException("requiredStr: field '" + field + "' fatal error")
    }
  }

  def optionalStr(config: loamstream.conf.DataConfig, field: String, regex: String = ".*"): Option[String] = {
    Try(config.getStr(field)) match {
      case Success(o)           =>
        o.matches(regex) match {
          case false => throw new CfgException("optionalStr: field " + field + " value " + o + " does not match regex format " + regex)
          case true  => Some(o)
        }
      case Failure(NonFatal(e)) => None
      case Failure(_)           => throw new CfgException("optionalStr: field '" + field + "' fatal error")
    }
  }
  
  def requiredInt(config: loamstream.conf.DataConfig, field: String, default: Option[Int]): Int = {
    Try(config.getInt(field)) match {
      case Success(o) => o
      case Failure(NonFatal(e)) =>
        default match {
          case Some(i) => i
          case None    => throw new CfgException("requiredInt: field '" + field + "' not found")
        }
      case Failure(_)           => throw new CfgException("requiredInt: field '" + field + "' fatal error")
    }
  }
  
  def requiredStrList(config: loamstream.conf.DataConfig, field: String, default: Option[Seq[String]] = None): Seq[String] = {
    Try(config.getStrList(field)) match {
      case Success(o)           => o
      case Failure(NonFatal(e)) => 
        default match {
          case Some(s) => s
          case None    => throw new CfgException("requiredStrList: field '" + field + "' not found")
        }
      case Failure(_)           => throw new CfgException("requiredStrList: field '" + field + "' fatal error")
    }
  }
  
  def optionalStrList(config: loamstream.conf.DataConfig, field: String): Option[Seq[String]] = {
    Try(config.getStrList(field)) match {
      case Success(o)           => Some(o)
      case Failure(NonFatal(e)) => None
      case Failure(_)           => throw new CfgException("optionalStrList: field '" + field + "' fatal error")
    }
  }

  def checkPath(s: String): String = {
    Files.exists(Paths.get(s)) match {
      case false => throw new CfgException("checkPath: " + s + " not found")
      case true  => s
    }
  }

  def initDir(s: String): String = {
    val dir = Paths.get(s)
    Files.exists(dir) match {
      case false =>
        Files.createDirectory(dir)
        s
      case true  => s
    }
  }

  def parseCfg(config: loamstream.conf.DataConfig): Cfg = {

    val id = requiredStr(config = config, field = "id", regex = "^[a-zA-Z0-9]*$")
    val cloudShare = requiredStr(config = config, field = "cloudShare")
    val cloudHome = requiredStr(config = config, field = "cloudHome")

    val dir = {

      val base = MultiStrPath(
        local = initDir("results"),
        google = cloudHome + "/" + id + "/results")

      val data = MultiStrPath(
        local = initDir(base.local + "/data"),
        google = base.google + "/data")

      val kinship = MultiStrPath(
        local = initDir(base.local + "/kinship"),
        google = base.google + "/kinship")

      val ancestry = MultiStrPath(
        local = initDir(base.local + "/ancestry"),
        google = base.google + "/ancestry")

      new Dir(
        base = base,
        data = data,
        kinship = kinship,
        ancestry = ancestry,
        cloudShare = cloudShare,
        cloudHome = cloudHome)

    }

    val regExcl = optionalStr(config = config, field = "regExcl")
    val genePos = checkPath(requiredStr(config = config, field = "genePos"))
    val aimRef = checkPath(requiredStr(config = config, field = "aimRef"))

    val refSam = store(checkPath(requiredStr(config = config, field = "refSam"))).asInput
    val refSamId = requiredStr(config = config, field = "refSamId", default = Some("ID"))
    val refSamPop = requiredStr(config = config, field = "refSamPop", default = Some("POP"))
    val refSamGrp = requiredStr(config = config, field = "refSamGrp", default = Some("GROUP"))
    val chrSeq = (1 to 22).map(e => e.toString).toSeq ++ Seq("X","Y","MT")
    val refVcfs = chrSeq.map { chr =>
      val vcf = store(checkPath(requiredStr(config = config, field = "refVcfs").replace("[CHROMOSOME]", s"$chr"))).asInput
      chr -> vcf
    }.toMap
    val refVcfsIDs = chrSeq.map { chr =>
      val vcfsIDs = store(checkPath(requiredStr(config = config, field = "refVcfsIDs").replace("[CHROMOSOME]", s"$chr"))).asInput
      chr -> vcfsIDs
    }.toMap
    val huRefs = chrSeq.map { chr =>
      val huRef = store(checkPath(requiredStr(config = config, field = "huRefs").replace("[CHROMOSOME]", s"$chr"))).asInput
      chr -> huRef
    }.toMap

    val pheno = store(checkPath(requiredStr(config = config, field = "pheno"))).asInput
    val phenoStatus = requiredStr(config = config, field = "phenoStatus")
    val phenoId = requiredStr(config = config, field = "phenoId", default = Some("ID"))
    val phenoSex = requiredStr(config = config, field = "phenoSex", default = Some("SEX"))
    val phenoRace = requiredStr(config = config, field = "phenoRace", default = Some("RACE"))

    val qcReportAuthors = requiredStrList(config = config, field = "qcReportAuthors")
    val analysisReportAuthors = requiredStrList(config = config, field = "analysisReportAuthors")
    val analysisReportAcknowledgements = requiredStrList(config = config, field = "analysisReportAcknowledgements")

    val data = {
      for {
        dat <- config.getObjList("data")
      } yield {
        val format = requiredStr(config = dat, field = "format", regex = "vcf|plink")
        val basename = Paths.get(requiredStr(config = dat, field = "file")).getFileName().toString()
        val file = {
          format match {
            case "plink" =>
              Plink(
                base = MultiStrPath(local = requiredStr(config = dat, field = "file"), google = dir.data.google + "/" + Paths.get(requiredStr(config = dat, field = "file")).getFileName().toString()),
                bed = MultiStore(local = store(checkPath(requiredStr(config = dat, field = "file") + ".bed")).asInput, google = store(uri(dir.data.google + "/" + Paths.get(requiredStr(config = dat, field = "file") + ".bed").getFileName().toString()))),
                bim = MultiStore(local = store(checkPath(requiredStr(config = dat, field = "file") + ".bim")).asInput, google = store(uri(dir.data.google + "/" + Paths.get(requiredStr(config = dat, field = "file") + ".bim").getFileName().toString()))),
                fam = MultiStore(local = store(checkPath(requiredStr(config = dat, field = "file") + ".fam")).asInput, google = store(uri(dir.data.google + "/" + Paths.get(requiredStr(config = dat, field = "file") + ".fam").getFileName().toString()))))
            case "vcf" =>
              Vcf(
                base = MultiStrPath(local = requiredStr(config = dat, field = "file").replaceAll(".vcf.gz$","").replaceAll(".vcf.bgz$","").replaceAll(".gz$","").replaceAll(".bgz$",""), google = dir.data.google + "/" + Paths.get(requiredStr(config = dat, field = "file")).getFileName().toString().replaceAll(".vcf.gz$","").replaceAll(".vcf.bgz$","").replaceAll(".gz$","").replaceAll(".bgz$","")),
                vcf = MultiStore(local = store(checkPath(requiredStr(config = dat, field = "file"))).asInput, google = store(uri(dir.data.google + "/" + basename))))
          }
        }
        Data(
          id = requiredStr(config = dat, field = "id", regex = "^[a-zA-Z0-9_]*$"),
          file = file,
          basename = basename,
          format = format,
          tech = requiredStr(config = dat, field = "tech", regex = "ex_array|gwas_array|custom_array|wes|wgs"),
          desc = requiredStr(config = dat, field = "desc"),
          build = requiredStr(config = dat, field = "build", regex = "hg18|hg19|hg38"),
          nAncPcs = requiredInt(config = dat, field = "nAncPcs", default = Some(3)),
          metrics = requiredStrList(config = dat, field = "sampleQcMetrics", default = Some(Seq("nNonRef_res","nHet_res","nCalled_res","callRate_res","rTiTv_res","het_res","hetLow_res","hetHigh_res","nHomVar_res","rHetHomVar_res"))),
          ancestryOutliersKeep = optionalStrList(config = dat, field = "ancestryOutliersKeep"),
          duplicatesKeep = optionalStrList(config = dat, field = "duplicatesKeep"),
          famsizeKeep = optionalStrList(config = dat, field = "famsizeKeep"),
          sampleqcKeep = optionalStrList(config = dat, field = "sampleqcKeep"),
          sexcheckKeep = optionalStrList(config = dat, field = "sexcheckKeep"))
      }
    }

    new Cfg(
      dir = dir,
      id = id,
      regExcl = regExcl,
      genePos = genePos,
      aimRef = aimRef,
      refSam = refSam,
      refSamId = refSamId,
      refSamPop = refSamPop,
      refSamGrp = refSamGrp,
      refVcfs = refVcfs,
      refVcfsIDs = refVcfsIDs,
      huRefs = huRefs,
      pheno = pheno,
      phenoStatus = phenoStatus,
      phenoId = phenoId,
      phenoSex = phenoSex,
      phenoRace = phenoRace,
      qcReportAuthors = qcReportAuthors,
      analysisReportAuthors = analysisReportAuthors,
      analysisReportAcknowledgements = analysisReportAcknowledgements,
      data = data)

  }
  
  def parseUtils(config: loamstream.conf.DataConfig): Utils = {

    val binary = Binary(
      gsutil = path(checkPath(requiredStr(config = config, field = "gsutil"))),
      gcloud = path(checkPath(requiredStr(config = config, field = "gcloud"))))

    val python = Python(
      hailLoad = path(checkPath(requiredStr(config = config, field = "hailLoad"))))
    
    val bash = Bash(
      shTest = path(checkPath(requiredStr(config = config, field = "shTest"))))

    val r = R(
      rTest = path(checkPath(requiredStr(config = config, field = "rTest"))))

    new Utils(
      binary = binary,
      python = python,
      bash = bash,
      r = r)

  }

}

def writeCfg(cfg: Cfg, utils: Utils): Any = {
  val f = new File(cfg.dir.base.local + "/cfg.classes")
  val bw = new BufferedWriter(new FileWriter(f))
  val objs = Seq(cfg.dir, cfg) ++ cfg.data
  for ( o <- objs ) {
    val vars = o.getClass.getDeclaredFields
    val name = o.getClass.getName.split("\\$")(1)
    bw.write("Class: " + name + "\n")
    for ( v <- vars ) {
      v.setAccessible(true)
      bw.write("  " + v.getName() + " => " + v.get(o).toString + "\n")
    }
    bw.write("\n")
  }
  for ( o <- Seq(utils.binary, utils.python, utils.bash, utils.r, utils) ) {
    val vars = o.getClass.getDeclaredFields
    val name = o.getClass.getName.split("\\$")(1)
    bw.write("Class: " + name + "\n")
    for ( v <- vars ) {
      v.setAccessible(true)
      bw.write("  " + v.getName() + " => " + v.get(o).toString + "\n")
    }
    bw.write("\n")
  }
  bw.close()
}

// Initialize configuration
println("Loading Project Configuration File ...")
val cfg = Cfg.parseCfg(loadConfig("dataConfig", ""))
cfg.dir.debugVars()
cfg.debugVars()
for ( d <- cfg.data ) {
d.debugVars()
}
println("... Project Configuration Loaded Successfully!")

val utils = Cfg.parseUtils(loadConfig("pipelineConfig", ""))
utils.binary.debugVars()
utils.python.debugVars()
utils.bash.debugVars()
utils.r.debugVars()
utils.debugVars()
println("... Pipeline Configuration Loaded Successfully!")

writeCfg(cfg, utils)
