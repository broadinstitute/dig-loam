import ProjectConfig._

final case class ArrayPheno(
    array: ConfigArray,
    pheno: ConfigPheno) {
  def canEqual(a: Any) = a.isInstanceOf[ArrayPheno]
  override def equals(that: Any): Boolean = that match {
    case that: ArrayPheno => that.canEqual(this) && this.hashCode == that.hashCode
    case _ => false
  }
  override def hashCode: Int = {
      val prime = 31
      var result = 1
      result = prime * result + array.id.hashCode
      result = prime * result + pheno.id.hashCode
      result
  }
}

final case class ModelCohort(
    model: ConfigModel,
    cohort: ConfigCohort) {
  def canEqual(a: Any) = a.isInstanceOf[ModelCohort]
  override def equals(that: Any): Boolean = that match {
    case that: ModelCohort => that.canEqual(this) && this.hashCode == that.hashCode
    case _ => false
  }
  override def hashCode: Int = {
      val prime = 31
      var result = 1
      result = prime * result + model.id.hashCode
      result = prime * result + cohort.id.hashCode
      result
  }
}

final case class ModelCohortKnown(
    model: ConfigModel,
    cohort: ConfigCohort,
    known: ConfigKnown) {
  def canEqual(a: Any) = a.isInstanceOf[ModelCohortKnown]
  override def equals(that: Any): Boolean = that match {
    case that: ModelCohortKnown => that.canEqual(this) && this.hashCode == that.hashCode
    case _ => false
  }
  override def hashCode: Int = {
      val prime = 31
      var result = 1
      result = prime * result + model.id.hashCode
      result = prime * result + cohort.id.hashCode
      result = prime * result + known.id.hashCode
      result
  }
}

final case class ModelCohortMeta(
    model: ConfigModel,
    cohort: ConfigCohort,
    meta: ConfigMeta) {
  def canEqual(a: Any) = a.isInstanceOf[ModelCohortMeta]
  override def equals(that: Any): Boolean = that match {
    case that: ModelCohortMeta => that.canEqual(this) && this.hashCode == that.hashCode
    case _ => false
  }
  override def hashCode: Int = {
      val prime = 31
      var result = 1
      result = prime * result + model.id.hashCode
      result = prime * result + cohort.id.hashCode
      result = prime * result + meta.id.hashCode
      result
  }
}

final case class ModelCohortMetaKnown(
    model: ConfigModel,
    cohort: ConfigCohort,
    meta: ConfigMeta,
    known: ConfigKnown) {
  def canEqual(a: Any) = a.isInstanceOf[ModelCohortMetaKnown]
  override def equals(that: Any): Boolean = that match {
    case that: ModelCohortMetaKnown => that.canEqual(this) && this.hashCode == that.hashCode
    case _ => false
  }
  override def hashCode: Int = {
      val prime = 31
      var result = 1
      result = prime * result + model.id.hashCode
      result = prime * result + cohort.id.hashCode
      result = prime * result + meta.id.hashCode
      result = prime * result + known.id.hashCode
      result
  }
}

final case class ModelMeta(
    model: ConfigModel,
    meta: ConfigMeta) {
  def canEqual(a: Any) = a.isInstanceOf[ModelMeta]
  override def equals(that: Any): Boolean = that match {
    case that: ModelMeta => that.canEqual(this) && this.hashCode == that.hashCode
    case _ => false
  }
  override def hashCode: Int = {
      val prime = 31
      var result = 1
      result = prime * result + model.id.hashCode
      result = prime * result + meta.id.hashCode
      result
  }
}

final case class ModelMerge(
    model: ConfigModel,
    merge: ConfigMerge) {
  def canEqual(a: Any) = a.isInstanceOf[ModelMerge]
  override def equals(that: Any): Boolean = that match {
    case that: ModelMerge => that.canEqual(this) && this.hashCode == that.hashCode
    case _ => false
  }
  override def hashCode: Int = {
      val prime = 31
      var result = 1
      result = prime * result + model.id.hashCode
      result = prime * result + merge.id.hashCode
      result
  }
}

final case class ModelMetaKnown(
    model: ConfigModel,
    meta: ConfigMeta,
    known: ConfigKnown) {
  def canEqual(a: Any) = a.isInstanceOf[ModelMetaKnown]
  override def equals(that: Any): Boolean = that match {
    case that: ModelMetaKnown => that.canEqual(this) && this.hashCode == that.hashCode
    case _ => false
  }
  override def hashCode: Int = {
      val prime = 31
      var result = 1
      result = prime * result + model.id.hashCode
      result = prime * result + meta.id.hashCode
      result = prime * result + known.id.hashCode
      result
  }
}

final case class ModelMergeKnown(
    model: ConfigModel,
    merge: ConfigMerge,
    known: ConfigKnown) {
  def canEqual(a: Any) = a.isInstanceOf[ModelMergeKnown]
  override def equals(that: Any): Boolean = that match {
    case that: ModelMergeKnown => that.canEqual(this) && this.hashCode == that.hashCode
    case _ => false
  }
  override def hashCode: Int = {
      val prime = 31
      var result = 1
      result = prime * result + model.id.hashCode
      result = prime * result + merge.id.hashCode
      result = prime * result + known.id.hashCode
      result
  }
}

val cohorts: Seq[ConfigCohort] = {

  val x = for {
    section <- cfg.Reports.flatMap(e => e.sections).filter(e => e.cohorts.isDefined)
  } yield {
   
    for {
      c <- section.cohorts.get
    } yield {
      cfg.Cohorts.filter(e => e.id == c).head
    }
  
  }

  val y = for {
    section <- cfg.Reports.flatMap(e => e.sections).filter(e => e.merges.isDefined)
  } yield {
   
    for {
      g <- section.merges.get
      c <- cfg.Merges.filter(e => e.id == g).head.cohorts_metas if cfg.Cohorts.filter(e => e.id == c).size > 0
    } yield {
      cfg.Cohorts.filter(e => e.id == c).head
    }
  
  }
  x ++ y

}.flatten.distinct

val modelCohorts: Seq[ModelCohort] = {

  val x = for {
    section <- cfg.Reports.flatMap(e => e.sections).filter(e => e.cohorts.isDefined)
  } yield {
   
    for {
      m <- section.models
      c <- section.cohorts.get
    } yield {
      ModelCohort(
        model = cfg.Models.filter(e => e.id == m).head,
        cohort = cfg.Cohorts.filter(e => e.id == c).head)
    }
  
  }

  val y = for {
    section <- cfg.Reports.flatMap(e => e.sections).filter(e => e.merges.isDefined)
  } yield {
   
    for {
      m <- section.models
      g <- section.merges.get
      c <- cfg.Merges.filter(e => e.id == g).head.cohorts_metas if cfg.Cohorts.filter(e => e.id == c).size > 0
    } yield {
      ModelCohort(
        model = cfg.Models.filter(e => e.id == m).head,
        cohort = cfg.Cohorts.filter(e => e.id == c).head)
    }
  
  }
  x ++ y

}.flatten.distinct

val modelCohortKnowns: Seq[ModelCohortKnown] = {

  val x = for {
    section <- cfg.Reports.flatMap(e => e.sections).filter(e => e.cohorts.isDefined && e.knowns.isDefined)
  } yield {
   
    for {
      m <- section.models
      c <- section.cohorts.get
      k <- section.knowns.get
    } yield {
      ModelCohortKnown(
        model = cfg.Models.filter(e => e.id == m).head,
        cohort = cfg.Cohorts.filter(e => e.id == c).head,
        known = cfg.Knowns.filter(e => e.id == k).head)
    }

  }

  val y = for {
    section <- cfg.Reports.flatMap(e => e.sections).filter(e => e.merges.isDefined && e.knowns.isDefined)
  } yield {
   
    for {
      m <- section.models
      g <- section.merges.get
      c <- cfg.Merges.filter(e => e.id == g).head.cohorts_metas if cfg.Cohorts.filter(e => e.id == c).size > 0
      k <- section.knowns.get
    } yield {
      ModelCohortKnown(
        model = cfg.Models.filter(e => e.id == m).head,
        cohort = cfg.Cohorts.filter(e => e.id == c).head,
        known = cfg.Knowns.filter(e => e.id == k).head)
    }
  
  }
  x ++ y

}.flatten.distinct

val modelCohortMetas: Seq[ModelCohortMeta] = {

  val x = for {
    section <- cfg.Reports.flatMap(e => e.sections).filter(e => e.metas.isDefined)
  } yield {
   
    for {
      m <- section.models
      t <- section.metas.get
      c <- cfg.Metas.filter(e => e.id == t).head.cohorts
    } yield {
      ModelCohortMeta(
        model = cfg.Models.filter(e => e.id == m).head,
        meta = cfg.Metas.filter(e => e.id == t).head,
        cohort = cfg.Cohorts.filter(e => e.id == c).head)
    }
  
  }

  val y = for {
    section <- cfg.Reports.flatMap(e => e.sections).filter(e => e.merges.isDefined)
  } yield {
   
    for {
      m <- section.models
      g <- section.merges.get
      t <- cfg.Merges.filter(e => e.id == g).head.cohorts_metas if cfg.Metas.filter(e => e.id == t).size > 0
      c <- cfg.Cohorts.filter(e => cfg.Metas.filter(e => e.id == t).head.cohorts contains e.id).map(e => e.id)
    } yield {
      ModelCohortMeta(
        model = cfg.Models.filter(e => e.id == m).head,
        meta = cfg.Metas.filter(e => e.id == t).head,
        cohort = cfg.Cohorts.filter(e => e.id == c).head)
    }
  
  }
  x ++ y

}.flatten.distinct

val modelCohortMetaKnowns: Seq[ModelCohortMetaKnown] = {

  val x = for {
    section <- cfg.Reports.flatMap(e => e.sections).filter(e => e.metas.isDefined && e.knowns.isDefined)
  } yield {
   
    for {
      m <- section.models
      t <- section.metas.get
      c <- cfg.Metas.filter(e => e.id == t).head.cohorts
      k <- section.knowns.get
    } yield {
      ModelCohortMetaKnown(
        model = cfg.Models.filter(e => e.id == m).head,
        meta = cfg.Metas.filter(e => e.id == t).head,
        cohort = cfg.Cohorts.filter(e => e.id == c).head,
        known = cfg.Knowns.filter(e => e.id == k).head)
    }

  }

  val y = for {
    section <- cfg.Reports.flatMap(e => e.sections).filter(e => e.merges.isDefined && e.knowns.isDefined)
  } yield {
   
    for {
      m <- section.models
      g <- section.merges.get
      t <- cfg.Merges.filter(e => e.id == g).head.cohorts_metas if cfg.Metas.filter(e => e.id == t).size > 0
      c <- cfg.Cohorts.filter(e => cfg.Metas.filter(e => e.id == t).head.cohorts contains e.id).map(e => e.id)
      k <- section.knowns.get
    } yield {
      ModelCohortMetaKnown(
        model = cfg.Models.filter(e => e.id == m).head,
        meta = cfg.Metas.filter(e => e.id == t).head,
        cohort = cfg.Cohorts.filter(e => e.id == c).head,
        known = cfg.Knowns.filter(e => e.id == k).head)
    }
  
  }
  x ++ y

}.flatten.distinct

val models: Seq[ConfigModel] = {

  for {
    section <- cfg.Reports.flatMap(e => e.sections)
  } yield {
    for {
      m <- section.models
    } yield {
      cfg.Models.filter(e => e.id == m).head
    }
  }

}.flatten.distinct

val phenos: Seq[ConfigPheno] = {

  for {
    m <- models
  } yield {
    cfg.Phenos.filter(e => e.id == m.pheno).head
  }

}.distinct

val metas: Seq[ConfigMeta] = {

  val x = for {
    section <- cfg.Reports.flatMap(e => e.sections).filter(e => e.metas.isDefined)
  } yield {
    for {
      t <- section.metas.get
    } yield {
      cfg.Metas.filter(e => e.id == t).head
    }
  }

  val y = for {
    section <- cfg.Reports.flatMap(e => e.sections).filter(e => e.merges.isDefined)
  } yield {
    for {
      g <- section.merges.get
      t <- cfg.Merges.filter(e => e.id == g).head.cohorts_metas if cfg.Metas.filter(e => e.id == t).size > 0
    } yield {
      cfg.Metas.filter(e => e.id == t).head
    }
  }
  x ++ y

}.flatten.distinct

val merges: Seq[ConfigMerge] = {

  for {
    section <- cfg.Reports.flatMap(e => e.sections).filter(e => e.merges.isDefined)
  } yield {
    for {
      m <- section.merges.get
    } yield {
      cfg.Merges.filter(e => e.id == m).head
    }
  }

}.flatten.distinct

val knowns: Seq[ConfigKnown] = {

  for {
    section <- cfg.Reports.flatMap(e => e.sections).filter(e => e.knowns.isDefined)
  } yield {
    for {
      k <- section.knowns.get
    } yield {
      cfg.Knowns.filter(e => e.id == k).head
    }
  }

}.flatten.distinct

val modelMetas: Seq[ModelMeta] = {

  val x = for {
    section <- cfg.Reports.flatMap(e => e.sections).filter(e => e.metas.isDefined)
  } yield {
    for {
      m <- section.models
      t <- section.metas.get
    } yield {
      ModelMeta(
        model = cfg.Models.filter(e => e.id == m).head,
        meta = cfg.Metas.filter(e => e.id == t).head)
    }
  }

  val y = for {
    section <- cfg.Reports.flatMap(e => e.sections).filter(e => e.merges.isDefined)
  } yield {
    for {
      m <- section.models
      g <- section.merges.get
      t <- cfg.Merges.filter(e => e.id == g).head.cohorts_metas if cfg.Metas.filter(e => e.id == t).size > 0
    } yield {
      ModelMeta(
        model = cfg.Models.filter(e => e.id == m).head,
        meta = cfg.Metas.filter(e => e.id == t).head)
    }
  }
  x ++ y

}.flatten.distinct

val modelMerges: Seq[ModelMerge] = {

  for {
    section <- cfg.Reports.flatMap(e => e.sections).filter(e => e.merges.isDefined)
  } yield {
    for {
      m <- section.models
      t <- section.merges.get
    } yield {
      ModelMerge(
        model = cfg.Models.filter(e => e.id == m).head,
        merge = cfg.Merges.filter(e => e.id == t).head)
    }
  }

}.flatten.distinct

val modelMetaKnowns: Seq[ModelMetaKnown] = {

  val x = for {
    section <- cfg.Reports.flatMap(e => e.sections).filter(e => e.metas.isDefined && e.knowns.isDefined)
  } yield {
    for {
      m <- section.models
      t <- section.metas.get
      k <- section.knowns.get
    } yield {
      ModelMetaKnown(
        model = cfg.Models.filter(e => e.id == m).head,
        meta = cfg.Metas.filter(e => e.id == t).head,
        known = cfg.Knowns.filter(e => e.id == k).head)
    }
  }

  val y = for {
    section <- cfg.Reports.flatMap(e => e.sections).filter(e => e.merges.isDefined && e.knowns.isDefined)
  } yield {
    for {
      m <- section.models
      g <- section.merges.get
      t <- cfg.Merges.filter(e => e.id == g).head.cohorts_metas if cfg.Metas.filter(e => e.id == t).size > 0
      k <- section.knowns.get
    } yield {
      ModelMetaKnown(
        model = cfg.Models.filter(e => e.id == m).head,
        meta = cfg.Metas.filter(e => e.id == t).head,
        known = cfg.Knowns.filter(e => e.id == k).head)
    }
  }
  x ++ y

}.flatten.distinct

val modelMergeKnowns: Seq[ModelMergeKnown] = {

  for {
    section <- cfg.Reports.flatMap(e => e.sections).filter(e => e.merges.isDefined && e.knowns.isDefined)
  } yield {
    for {
      m <- section.models
      t <- section.merges.get
      k <- section.knowns.get
    } yield {
      ModelMergeKnown(
        model = cfg.Models.filter(e => e.id == m).head,
        merge = cfg.Merges.filter(e => e.id == t).head,
        known = cfg.Knowns.filter(e => e.id == k).head)
    }
  }

}.flatten.distinct

val cohortsList: Seq[ConfigCohort] = {

  val w = for {
    section <- cfg.Reports.flatMap(e => e.sections).filter(e => e.cohorts.isDefined)
  } yield {
   
    for {
      c <- section.cohorts.get
    } yield {
      cfg.Cohorts.filter(e => e.id == c).head
    }
  
  }

  val x = for {
    section <- cfg.Reports.flatMap(e => e.sections).filter(e => e.metas.isDefined)
  } yield {
   
    for {
      t <- section.metas.get
      c <- cfg.Metas.filter(e => e.id == t).head.cohorts
    } yield {
      cfg.Cohorts.filter(e => e.id == c).head
    }
  
  }

  val y = for {
    section <- cfg.Reports.flatMap(e => e.sections).filter(e => e.merges.isDefined)
  } yield {
   
    for {
      g <- section.merges.get
      c <- cfg.Merges.filter(e => e.id == g).head.cohorts_metas if cfg.Cohorts.filter(e => e.id == c).size > 0
    } yield {
      cfg.Cohorts.filter(e => e.id == c).head
    }
  
  }

  val z = for {
    section <- cfg.Reports.flatMap(e => e.sections).filter(e => e.merges.isDefined)
  } yield {
   
    for {
      g <- section.merges.get
      t <- cfg.Merges.filter(e => e.id == g).head.cohorts_metas if cfg.Metas.filter(e => e.id == t).size > 0
      c <- cfg.Metas.filter(e => e.id == t).head.cohorts
    } yield {
      cfg.Cohorts.filter(e => e.id == c).head
    }
  
  }

  w ++ x ++ y ++ z

}.flatten.distinct

val phenosReport: Seq[ConfigPheno] = {

  for {
    section <- cfg.Reports.flatMap(e => e.sections)
    model <- cfg.Models.filter(e => section.models.contains(e.id))
  } yield {
    cfg.Phenos.filter(e => e.id == model.pheno).head
  }

}.distinct

val modelsReport: Seq[ConfigModel] = {

  for {
    section <- cfg.Reports.flatMap(e => e.sections)
    m <- section.models
  } yield {
    cfg.Models.filter(e => e.id == m).head
  }

}.distinct

val cohortsReport: Seq[ConfigCohort] = {

  for {
    section <- cfg.Reports.flatMap(e => e.sections).filter(e => e.cohorts.isDefined)
  } yield {
    for {
      c <- section.cohorts.get
    } yield {
      cfg.Cohorts.filter(e => e.id == c).head
    }
  }

}.flatten.distinct

val metasReport: Seq[ConfigMeta] = {

  for {
    section <- cfg.Reports.flatMap(e => e.sections).filter(e => e.metas.isDefined)
  } yield {
    for {
      t <- section.metas.get
    } yield {
      cfg.Metas.filter(e => e.id == t).head
    }
  }

}.flatten.distinct

val modelCohortsReport: Seq[ModelCohort] = {

  for {
    section <- cfg.Reports.flatMap(e => e.sections).filter(e => e.cohorts.isDefined)
  } yield {
    for {
      m <- section.models
      c <- section.cohorts.get
    } yield {
      ModelCohort(
        model = cfg.Models.filter(e => e.id == m).head,
        cohort = cfg.Cohorts.filter(e => e.id == c).head)
    }
  }

}.flatten.distinct

val modelCohortKnownsReport: Seq[ModelCohortKnown] = {

  for {
    section <- cfg.Reports.flatMap(e => e.sections).filter(e => e.cohorts.isDefined && e.knowns.isDefined)
  } yield {
    for {
      m <- section.models
      c <- section.cohorts.get
      k <- section.knowns.get
    } yield {
      ModelCohortKnown(
        model = cfg.Models.filter(e => e.id == m).head,
        cohort = cfg.Cohorts.filter(e => e.id == c).head,
        known = cfg.Knowns.filter(e => e.id == k).head)
    }
  }

}.flatten.distinct

val modelMetasReport: Seq[ModelMeta] = {

  for {
    section <- cfg.Reports.flatMap(e => e.sections).filter(e => e.metas.isDefined)
  } yield {
    for {
      m <- section.models
      t <- section.metas.get
    } yield {
      ModelMeta(
        model = cfg.Models.filter(e => e.id == m).head,
        meta = cfg.Metas.filter(e => e.id == t).head)
    }
  }

}.flatten.distinct

val modelMetaKnownsReport: Seq[ModelMetaKnown] = {

  for {
    section <- cfg.Reports.flatMap(e => e.sections).filter(e => e.metas.isDefined && e.knowns.isDefined)
  } yield {
    for {
      m <- section.models
      t <- section.metas.get
      k <- section.knowns.get
    } yield {
      ModelMetaKnown(
        model = cfg.Models.filter(e => e.id == m).head,
        meta = cfg.Metas.filter(e => e.id == t).head,
        known = cfg.Knowns.filter(e => e.id == k).head)
    }
  }

}.flatten.distinct
