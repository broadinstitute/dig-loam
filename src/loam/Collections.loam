import ProjectConfig._

final case class ModelCohort(
    model: ConfigModel,
    cohorts: Seq[ConfigCohort]) {
  def canEqual(a: Any) = a.isInstanceOf[ModelCohort]
  override def equals(that: Any): Boolean = that match {
    case that: ModelCohort => that.canEqual(this) && this.hashCode == that.hashCode
    case _ => false
  }
  override def hashCode: Int = {
      val prime = 31
      var result = 1
      result = prime * result + model.id.hashCode
      result = prime * result + cohorts.map(e => e.id).hashCode
      result
  }
}

final case class ModelCohortKnown(
    model: ConfigModel,
    cohorts: Seq[ConfigCohort],
    known: ConfigKnown) {
  def canEqual(a: Any) = a.isInstanceOf[ModelCohortKnown]
  override def equals(that: Any): Boolean = that match {
    case that: ModelCohortKnown => that.canEqual(this) && this.hashCode == that.hashCode
    case _ => false
  }
  override def hashCode: Int = {
      val prime = 31
      var result = 1
      result = prime * result + model.id.hashCode
      result = prime * result + cohorts.map(e => e.id).hashCode
      result = prime * result + known.id.hashCode
      result
  }
}

final case class ModelMetaCohort(
    model: ConfigModel,
    meta: ConfigMeta,
    cohorts: Seq[ConfigCohort]) {
  def canEqual(a: Any) = a.isInstanceOf[ModelMetaCohort]
  override def equals(that: Any): Boolean = that match {
    case that: ModelMetaCohort => that.canEqual(this) && this.hashCode == that.hashCode
    case _ => false
  }
  override def hashCode: Int = {
      val prime = 31
      var result = 1
      result = prime * result + model.id.hashCode
      result = prime * result + meta.id.hashCode
      result = prime * result + cohorts.map(e => e.id).hashCode
      result
  }
}

final case class ModelMetaCohortKnown(
    model: ConfigModel,
    meta: ConfigMeta,
    cohorts: Seq[ConfigCohort],
    known: ConfigKnown) {
  def canEqual(a: Any) = a.isInstanceOf[ModelMetaCohortKnown]
  override def equals(that: Any): Boolean = that match {
    case that: ModelMetaCohortKnown => that.canEqual(this) && this.hashCode == that.hashCode
    case _ => false
  }
  override def hashCode: Int = {
      val prime = 31
      var result = 1
      result = prime * result + model.id.hashCode
      result = prime * result + meta.id.hashCode
      result = prime * result + cohorts.map(e => e.id).hashCode
      result = prime * result + known.id.hashCode
      result
  }
}

val modelCohorts: Seq[ModelCohort] = {
  val x = for {
    model <- projectConfig.Models.filter(e => ! e.metas.isDefined)
  } yield {
    model.design match {
      case "full" =>
        Seq(ModelCohort(
          model = model,
          cohorts = projectConfig.Cohorts.filter(e => model.cohorts.contains(e.id))
        ))
      case "strat" =>
        for {
          cohort <- projectConfig.Cohorts.filter(e => model.cohorts.contains(e.id))
        } yield {
         ModelCohort(
           model = model,
           cohorts = Seq(cohort)
         )
        }
    }
  }
  val y = for {
    model <- projectConfig.Models.filter(e => e.metas.isDefined && e.design == "strat")
  } yield {
    val metaCohorts = for {
      meta <- projectConfig.Metas.filter(e => model.metas.get.contains(e.id))
      cohort <- projectConfig.Cohorts.filter(e => meta.cohorts.contains(e.id))
    } yield {
      cohort
    }
    for {
      cohort <- projectConfig.Cohorts.filter(e => model.cohorts.contains(e.id)) diff metaCohorts
    } yield {
      ModelCohort(
        model = model,
        cohorts = Seq(cohort)
      )
    }
  }
  (x ++ y).flatten
}.distinct

val modelMetaCohorts: Seq[ModelMetaCohort] = {
  for {
    model <- projectConfig.Models.filter(e => e.metas.isDefined && e.design == "strat")
    meta <- projectConfig.Metas.filter(e => model.metas.get.contains(e.id))
    cohort <- projectConfig.Cohorts.filter(e => meta.cohorts.contains(e.id))
  } yield {
    ModelMetaCohort(
      model = model,
      meta = meta,
      cohorts = Seq(cohort)
    )
  }
}.distinct

val modelCohortKnowns: Seq[ModelCohortKnown] = {
  val x = for {
    model <- projectConfig.Models.filter(e => ! e.metas.isDefined && e.knowns.isDefined)
    known <- projectConfig.Knowns.filter(e => model.knowns.contains(e.id))
  } yield {
    model.design match {
      case "full" =>
        Seq(ModelCohortKnown(
          model = model,
          cohorts = projectConfig.Cohorts.filter(e => model.cohorts.contains(e.id)),
          known = known
        ))
      case "strat" =>
        for {
          cohort <- projectConfig.Cohorts.filter(e => model.cohorts.contains(e.id))
        } yield {
          ModelCohortKnown(
            model = model,
            cohorts = Seq(cohort),
            known = known
          )
        }
    }
  }
  val y = for {
    model <- projectConfig.Models.filter(e => e.metas.isDefined && e.design == "strat" && e.knowns.isDefined)
  } yield {
    val metaCohorts = for {
      meta <- projectConfig.Metas.filter(e => model.metas.get.contains(e.id))
      cohort <- projectConfig.Cohorts.filter(e => meta.cohorts.contains(e.id))
    } yield {
      cohort
    }
    for {
      cohort <- projectConfig.Cohorts.filter(e => model.cohorts.contains(e.id)) diff metaCohorts
      known <- projectConfig.Knowns.filter(e => model.knowns.contains(e.id))
    } yield {
      ModelCohortKnown(
        model = model,
        cohorts = Seq(cohort),
        known = known
      )
    }
  }
  (x ++ y).flatten
}.distinct

val modelMetaCohortKnowns: Seq[ModelMetaCohortKnown] = {
  for {
    model <- projectConfig.Models.filter(e => e.metas.isDefined && e.knowns.isDefined && e.design == "strat")
    meta <- projectConfig.Metas.filter(e => model.metas.get.contains(e.id))
    known <- projectConfig.Knowns.filter(e => model.knowns.contains(e.id))
    cohort <- projectConfig.Cohorts.filter(e => meta.cohorts.contains(e.id))
  } yield {
    ModelMetaCohortKnown(
      model = model,
      meta = meta,
      cohorts = Seq(cohort),
      known = known
    )
  }
}.distinct
