/**
  * Cross Cohort Relatedness Step
  *  Description: Check for cross cohort relatedness
  *  Requires: Plink, King
  */
import ProjectConfig._
import PipelineConfig._
import ArrayStores._
import ProjectStores._
import AssocStores._

def CrossCohortPrep(configModel: ConfigModel, configCohort: ConfigCohort, configMeta: ConfigMeta): Unit = {

  val meta = metaStores((configModel, configMeta))

  drmWith(imageName = s"$imgTools") {

    cmd"""join -1 2 -2 1 <(sort -k 2 ${arrayStores(configCohort.array).harmonizedData.refBase}.fam) <(sort -k 1 ${ProjectStores.ancestryInferred}) | awk -v var=${configCohort.ancestry.mkString(",")} '{ split(var,arr,","); for ( a in arr ) { if (arr[a] == $$7 ) print $$2"\t"$$1 } }' > ${meta.metaCohortData(configCohort.id).samples}"""
    .in(ProjectStores.ancestryInferred)
    .out(meta.metaCohortData(configCohort.id).samples)
    .tag(s"${meta.metaCohortData(configCohort.id).samples}".split("/").last)

    cmd"""$binPlink --bfile ${arrayStores(configCohort.array).harmonizedData.refBase} --keep ${meta.metaCohortData(configCohort.id).samples} --make-bed --out ${meta.metaCohortData(configCohort.id).base}"""
    .in(arrayStores(configCohort.array).harmonizedData.refData :+ meta.metaCohortData(configCohort.id).samples)
    .out(meta.metaCohortData(configCohort.id).data)
    .tag(s"${meta.metaCohortData(configCohort.id).base}".split("/").last)

    cmd"""awk -v c=${configCohort.id} '{print $$1"_"c"\t"$$2"_"c"\t"$$3"\t"$$4"\t"$$5"\t"$$6}' ${meta.metaCohortData(configCohort.id).base}.fam > ${meta.metaCohortData(configCohort.id).famMerge}"""
    .in(meta.metaCohortData(configCohort.id).data)
    .out(meta.metaCohortData(configCohort.id).famMerge)
    .tag(s"${meta.metaCohortData(configCohort.id).famMerge}".split("/").last)

  }

}

def CrossCohortKinship(configMeta: ConfigMeta): Unit = {

  val metaKinship = metaKinshipStores(configMeta)

  val mergeString = metaKinship.metaCohort.map(e => e._2.base.toString + ".bed " + e._2.base.toString + ".bim " + e._2.famMerge.toString.split("@")(1)).mkString("\n")
  val mergeStoresList = metaKinship.metaCohort.map(e => e._2).flatMap(e => e.data).toSeq

  drmWith(imageName = s"$imgTools") {

    cmd"""echo "${mergeString}" > ${metaKinship.mergeList}"""
    .out(metaKinship.mergeList)
    .tag(s"${metaKinship.mergeList}".split("/").last)

    cmd"""$binPlink --merge-list ${metaKinship.mergeList} --chr 1-22 --maf 0.01 --geno 0.02 --make-bed --out ${metaKinship.baseFiltered}"""
    .in(mergeStoresList :+ metaKinship.mergeList)
    .out(metaKinship.dataFiltered)
    .tag(s"${metaKinship.baseFiltered}".split("/").last)

    cmd"""$shKing $binKing ${metaKinship.baseFiltered}.bed ${metaKinship.baseKinship.toString} ${metaKinship.log} ${metaKinship.kin0} ${metaKinship.kin0Related} 4"""
    .in(metaKinship.dataFiltered)
    .out(metaKinship.log, metaKinship.kin0, metaKinship.kin0Related)
    .tag(s"${metaKinship.baseFiltered}.shKing".split("/").last)

  }

}

def CrossCohortExclude(configCohort: ConfigCohort, configMeta: ConfigMeta): Unit = {

  val metaKinship = metaKinshipStores(configMeta)
  val metaCohort = metaKinship.metaCohort(configCohort)

  drmWith(imageName = s"$imgR34") {
  
    cmd"""$binRscript --vanilla --verbose
      $rExcludeCrossArray
      --kinship ${metaKinship.kin0Related}
      --samples ${metaCohort.samples}
      --meta-cohorts ${configMeta.cohorts.mkString(",")}
      --cohort ${configCohort.id}
      --out ${metaCohort.kinshipSamplesExclude}
      """
      .in(metaKinship.kin0Related, metaCohort.samples)
      .out(metaCohort.kinshipSamplesExclude)
      .tag(s"${metaCohort.kinshipSamplesExclude}".split("/").last)
  
  }

}
